<!DOCTYPE html>
<html lang="en-US">
  <head>
    <meta charset="utf-8">
    <meta name="viewport" content="width=device-width,initial-scale=1">
    <title>快速浏览react API | Shymean</title>
    <meta name="description" content="fe">
    <link rel="stylesheet" href="/interview/assets/style.4eab0d57.css">
    <link rel="modulepreload" href="/interview/assets/app.062798f6.js">
    <link rel="modulepreload" href="/interview/assets/源码分析_React源码分析.md.71769f59.lean.js">
    
    <meta name="twitter:title" content="快速浏览react API | Shymean">
  <meta property="og:title" content="快速浏览react API | Shymean">
  </head>
  <body>
    <div id="app"><!--[--><div class="theme"><header class="nav-bar" data-v-40587210><div class="sidebar-button" data-v-40587210><svg class="icon" xmlns="http://www.w3.org/2000/svg" aria-hidden="true" role="img" viewBox="0 0 448 512"><path fill="currentColor" d="M436 124H12c-6.627 0-12-5.373-12-12V80c0-6.627 5.373-12 12-12h424c6.627 0 12 5.373 12 12v32c0 6.627-5.373 12-12 12zm0 160H12c-6.627 0-12-5.373-12-12v-32c0-6.627 5.373-12 12-12h424c6.627 0 12 5.373 12 12v32c0 6.627-5.373 12-12 12zm0 160H12c-6.627 0-12-5.373-12-12v-32c0-6.627 5.373-12 12-12h424c6.627 0 12 5.373 12 12v32c0 6.627-5.373 12-12 12z" class></path></svg></div><a class="nav-bar-title" href="/interview/" aria-label="Shymean, back to home" data-v-40587210 data-v-016a8bd8><!----> Shymean</a><div class="flex-grow" data-v-40587210></div><div class="nav" data-v-40587210><nav class="nav-links" data-v-40587210 data-v-35b91e7e><!--[--><div class="item" data-v-35b91e7e><div class="nav-link" data-v-35b91e7e data-v-49fe041d><a class="item" href="/interview/导读" data-v-49fe041d>导读 <!----></a></div></div><div class="item" data-v-35b91e7e><div class="nav-dropdown-link" data-v-35b91e7e data-v-18d75f62><button class="button" data-v-18d75f62><span class="button-text" data-v-18d75f62>前端</span><span class="right button-arrow" data-v-18d75f62></span></button><ul class="dialog" data-v-18d75f62><!--[--><li class="dialog-item" data-v-18d75f62><div class="nav-dropdown-link-item" data-v-18d75f62 data-v-07381bdb><a class="item" href="/interview/前端/HTML/HTML" data-v-07381bdb><span class="arrow" data-v-07381bdb></span><span class="text" data-v-07381bdb>HTML</span><span class="icon" data-v-07381bdb><!----></span></a></div></li><li class="dialog-item" data-v-18d75f62><div class="nav-dropdown-link-item" data-v-18d75f62 data-v-07381bdb><a class="item" href="/interview/前端/CSS/README" data-v-07381bdb><span class="arrow" data-v-07381bdb></span><span class="text" data-v-07381bdb>CSS</span><span class="icon" data-v-07381bdb><!----></span></a></div></li><li class="dialog-item" data-v-18d75f62><div class="nav-dropdown-link-item" data-v-18d75f62 data-v-07381bdb><a class="item" href="/interview/前端/JavaScript/README" data-v-07381bdb><span class="arrow" data-v-07381bdb></span><span class="text" data-v-07381bdb>JavaScript</span><span class="icon" data-v-07381bdb><!----></span></a></div></li><li class="dialog-item" data-v-18d75f62><div class="nav-dropdown-link-item" data-v-18d75f62 data-v-07381bdb><a class="item" href="/interview/前端/库与框架/README" data-v-07381bdb><span class="arrow" data-v-07381bdb></span><span class="text" data-v-07381bdb>库与框架</span><span class="icon" data-v-07381bdb><!----></span></a></div></li><li class="dialog-item" data-v-18d75f62><div class="nav-dropdown-link-item" data-v-18d75f62 data-v-07381bdb><a class="item" href="/interview/前端/业务相关/前端工程化" data-v-07381bdb><span class="arrow" data-v-07381bdb></span><span class="text" data-v-07381bdb>业务相关</span><span class="icon" data-v-07381bdb><!----></span></a></div></li><li class="dialog-item" data-v-18d75f62><div class="nav-dropdown-link-item" data-v-18d75f62 data-v-07381bdb><a class="item active" href="/interview/源码分析/README" data-v-07381bdb><span class="arrow" data-v-07381bdb></span><span class="text" data-v-07381bdb>源码分析</span><span class="icon" data-v-07381bdb><!----></span></a></div></li><!--]--></ul></div></div><div class="item" data-v-35b91e7e><div class="nav-link" data-v-35b91e7e data-v-49fe041d><a class="item" href="/interview/App/Android" data-v-49fe041d>App <!----></a></div></div><div class="item" data-v-35b91e7e><div class="nav-link" data-v-35b91e7e data-v-49fe041d><a class="item" href="/interview/后台/README" data-v-49fe041d>后台 <!----></a></div></div><div class="item" data-v-35b91e7e><div class="nav-dropdown-link" data-v-35b91e7e data-v-18d75f62><button class="button" data-v-18d75f62><span class="button-text" data-v-18d75f62>计算机基础</span><span class="right button-arrow" data-v-18d75f62></span></button><ul class="dialog" data-v-18d75f62><!--[--><li class="dialog-item" data-v-18d75f62><div class="nav-dropdown-link-item" data-v-18d75f62 data-v-07381bdb><a class="item" href="/interview/计算机基础/README" data-v-07381bdb><span class="arrow" data-v-07381bdb></span><span class="text" data-v-07381bdb>计算机基础</span><span class="icon" data-v-07381bdb><!----></span></a></div></li><li class="dialog-item" data-v-18d75f62><div class="nav-dropdown-link-item" data-v-18d75f62 data-v-07381bdb><a class="item" href="/interview/数据结构和算法/README" data-v-07381bdb><span class="arrow" data-v-07381bdb></span><span class="text" data-v-07381bdb>数据结构和算法</span><span class="icon" data-v-07381bdb><!----></span></a></div></li><li class="dialog-item" data-v-18d75f62><div class="nav-dropdown-link-item" data-v-18d75f62 data-v-07381bdb><a class="item" href="/interview/网络/README" data-v-07381bdb><span class="arrow" data-v-07381bdb></span><span class="text" data-v-07381bdb>网络</span><span class="icon" data-v-07381bdb><!----></span></a></div></li><!--]--></ul></div></div><div class="item" data-v-35b91e7e><div class="nav-link" data-v-35b91e7e data-v-49fe041d><a class="item" href="/interview/面试/README" data-v-49fe041d>面试 <!----></a></div></div><div class="item" data-v-35b91e7e><div class="nav-link" data-v-35b91e7e data-v-49fe041d><a class="item" href="/interview/游戏开发/README" data-v-49fe041d>游戏开发 <!----></a></div></div><div class="item" data-v-35b91e7e><div class="nav-link" data-v-35b91e7e data-v-49fe041d><a class="item" href="/interview/读书笔记/README" data-v-49fe041d>读书笔记 <!----></a></div></div><div class="item" data-v-35b91e7e><div class="nav-link" data-v-35b91e7e data-v-49fe041d><a class="item isExternal" href="https://github.com/tangxiangmin/interview" target="_blank" rel="noopener noreferrer" data-v-49fe041d>github <svg class="icon outbound" xmlns="http://www.w3.org/2000/svg" aria-hidden="true" x="0px" y="0px" viewbox="0 0 100 100" width="15" height="15" data-v-49fe041d><path fill="currentColor" d="M18.8,85.1h56l0,0c2.2,0,4-1.8,4-4v-32h-8v28h-48v-48h28v-8h-32l0,0c-2.2,0-4,1.8-4,4v56C14.8,83.3,16.6,85.1,18.8,85.1z"></path><polygon fill="currentColor" points="45.7,48.7 51.3,54.3 77.2,28.5 77.2,37.2 85.2,37.2 85.2,14.9 62.8,14.9 62.8,22.9 71.5,22.9"></polygon></svg></a></div></div><div class="item" data-v-35b91e7e><div class="nav-link" data-v-35b91e7e data-v-49fe041d><a class="item isExternal" href="https://shymean.com" target="_blank" rel="noopener noreferrer" data-v-49fe041d>shymean <svg class="icon outbound" xmlns="http://www.w3.org/2000/svg" aria-hidden="true" x="0px" y="0px" viewbox="0 0 100 100" width="15" height="15" data-v-49fe041d><path fill="currentColor" d="M18.8,85.1h56l0,0c2.2,0,4-1.8,4-4v-32h-8v28h-48v-48h28v-8h-32l0,0c-2.2,0-4,1.8-4,4v56C14.8,83.3,16.6,85.1,18.8,85.1z"></path><polygon fill="currentColor" points="45.7,48.7 51.3,54.3 77.2,28.5 77.2,37.2 85.2,37.2 85.2,14.9 62.8,14.9 62.8,22.9 71.5,22.9"></polygon></svg></a></div></div><!--]--><!----><!----></nav></div><!--[--><!--]--></header><aside class="sidebar" data-v-17c48e2f><nav class="nav-links nav" data-v-17c48e2f data-v-35b91e7e><!--[--><div class="item" data-v-35b91e7e><div class="nav-link" data-v-35b91e7e data-v-49fe041d><a class="item" href="/interview/导读" data-v-49fe041d>导读 <!----></a></div></div><div class="item" data-v-35b91e7e><div class="nav-dropdown-link" data-v-35b91e7e data-v-18d75f62><button class="button" data-v-18d75f62><span class="button-text" data-v-18d75f62>前端</span><span class="right button-arrow" data-v-18d75f62></span></button><ul class="dialog" data-v-18d75f62><!--[--><li class="dialog-item" data-v-18d75f62><div class="nav-dropdown-link-item" data-v-18d75f62 data-v-07381bdb><a class="item" href="/interview/前端/HTML/HTML" data-v-07381bdb><span class="arrow" data-v-07381bdb></span><span class="text" data-v-07381bdb>HTML</span><span class="icon" data-v-07381bdb><!----></span></a></div></li><li class="dialog-item" data-v-18d75f62><div class="nav-dropdown-link-item" data-v-18d75f62 data-v-07381bdb><a class="item" href="/interview/前端/CSS/README" data-v-07381bdb><span class="arrow" data-v-07381bdb></span><span class="text" data-v-07381bdb>CSS</span><span class="icon" data-v-07381bdb><!----></span></a></div></li><li class="dialog-item" data-v-18d75f62><div class="nav-dropdown-link-item" data-v-18d75f62 data-v-07381bdb><a class="item" href="/interview/前端/JavaScript/README" data-v-07381bdb><span class="arrow" data-v-07381bdb></span><span class="text" data-v-07381bdb>JavaScript</span><span class="icon" data-v-07381bdb><!----></span></a></div></li><li class="dialog-item" data-v-18d75f62><div class="nav-dropdown-link-item" data-v-18d75f62 data-v-07381bdb><a class="item" href="/interview/前端/库与框架/README" data-v-07381bdb><span class="arrow" data-v-07381bdb></span><span class="text" data-v-07381bdb>库与框架</span><span class="icon" data-v-07381bdb><!----></span></a></div></li><li class="dialog-item" data-v-18d75f62><div class="nav-dropdown-link-item" data-v-18d75f62 data-v-07381bdb><a class="item" href="/interview/前端/业务相关/前端工程化" data-v-07381bdb><span class="arrow" data-v-07381bdb></span><span class="text" data-v-07381bdb>业务相关</span><span class="icon" data-v-07381bdb><!----></span></a></div></li><li class="dialog-item" data-v-18d75f62><div class="nav-dropdown-link-item" data-v-18d75f62 data-v-07381bdb><a class="item active" href="/interview/源码分析/README" data-v-07381bdb><span class="arrow" data-v-07381bdb></span><span class="text" data-v-07381bdb>源码分析</span><span class="icon" data-v-07381bdb><!----></span></a></div></li><!--]--></ul></div></div><div class="item" data-v-35b91e7e><div class="nav-link" data-v-35b91e7e data-v-49fe041d><a class="item" href="/interview/App/Android" data-v-49fe041d>App <!----></a></div></div><div class="item" data-v-35b91e7e><div class="nav-link" data-v-35b91e7e data-v-49fe041d><a class="item" href="/interview/后台/README" data-v-49fe041d>后台 <!----></a></div></div><div class="item" data-v-35b91e7e><div class="nav-dropdown-link" data-v-35b91e7e data-v-18d75f62><button class="button" data-v-18d75f62><span class="button-text" data-v-18d75f62>计算机基础</span><span class="right button-arrow" data-v-18d75f62></span></button><ul class="dialog" data-v-18d75f62><!--[--><li class="dialog-item" data-v-18d75f62><div class="nav-dropdown-link-item" data-v-18d75f62 data-v-07381bdb><a class="item" href="/interview/计算机基础/README" data-v-07381bdb><span class="arrow" data-v-07381bdb></span><span class="text" data-v-07381bdb>计算机基础</span><span class="icon" data-v-07381bdb><!----></span></a></div></li><li class="dialog-item" data-v-18d75f62><div class="nav-dropdown-link-item" data-v-18d75f62 data-v-07381bdb><a class="item" href="/interview/数据结构和算法/README" data-v-07381bdb><span class="arrow" data-v-07381bdb></span><span class="text" data-v-07381bdb>数据结构和算法</span><span class="icon" data-v-07381bdb><!----></span></a></div></li><li class="dialog-item" data-v-18d75f62><div class="nav-dropdown-link-item" data-v-18d75f62 data-v-07381bdb><a class="item" href="/interview/网络/README" data-v-07381bdb><span class="arrow" data-v-07381bdb></span><span class="text" data-v-07381bdb>网络</span><span class="icon" data-v-07381bdb><!----></span></a></div></li><!--]--></ul></div></div><div class="item" data-v-35b91e7e><div class="nav-link" data-v-35b91e7e data-v-49fe041d><a class="item" href="/interview/面试/README" data-v-49fe041d>面试 <!----></a></div></div><div class="item" data-v-35b91e7e><div class="nav-link" data-v-35b91e7e data-v-49fe041d><a class="item" href="/interview/游戏开发/README" data-v-49fe041d>游戏开发 <!----></a></div></div><div class="item" data-v-35b91e7e><div class="nav-link" data-v-35b91e7e data-v-49fe041d><a class="item" href="/interview/读书笔记/README" data-v-49fe041d>读书笔记 <!----></a></div></div><div class="item" data-v-35b91e7e><div class="nav-link" data-v-35b91e7e data-v-49fe041d><a class="item isExternal" href="https://github.com/tangxiangmin/interview" target="_blank" rel="noopener noreferrer" data-v-49fe041d>github <svg class="icon outbound" xmlns="http://www.w3.org/2000/svg" aria-hidden="true" x="0px" y="0px" viewbox="0 0 100 100" width="15" height="15" data-v-49fe041d><path fill="currentColor" d="M18.8,85.1h56l0,0c2.2,0,4-1.8,4-4v-32h-8v28h-48v-48h28v-8h-32l0,0c-2.2,0-4,1.8-4,4v56C14.8,83.3,16.6,85.1,18.8,85.1z"></path><polygon fill="currentColor" points="45.7,48.7 51.3,54.3 77.2,28.5 77.2,37.2 85.2,37.2 85.2,14.9 62.8,14.9 62.8,22.9 71.5,22.9"></polygon></svg></a></div></div><div class="item" data-v-35b91e7e><div class="nav-link" data-v-35b91e7e data-v-49fe041d><a class="item isExternal" href="https://shymean.com" target="_blank" rel="noopener noreferrer" data-v-49fe041d>shymean <svg class="icon outbound" xmlns="http://www.w3.org/2000/svg" aria-hidden="true" x="0px" y="0px" viewbox="0 0 100 100" width="15" height="15" data-v-49fe041d><path fill="currentColor" d="M18.8,85.1h56l0,0c2.2,0,4-1.8,4-4v-32h-8v28h-48v-48h28v-8h-32l0,0c-2.2,0-4,1.8-4,4v56C14.8,83.3,16.6,85.1,18.8,85.1z"></path><polygon fill="currentColor" points="45.7,48.7 51.3,54.3 77.2,28.5 77.2,37.2 85.2,37.2 85.2,14.9 62.8,14.9 62.8,22.9 71.5,22.9"></polygon></svg></a></div></div><!--]--><!----><!----></nav><!--[--><!--]--><ul class="sidebar-links" data-v-17c48e2f><!--[--><li class="sidebar-link"><a class="sidebar-link-item" href="/interview/源码分析/ReactFibler源码分析">ReactFibler源码分析</a><!----></li><li class="sidebar-link"><a class="sidebar-link-item active" href="/interview/源码分析/React源码分析">React源码分析</a><ul class="sidebar-links"><li class="sidebar-link"><a class="sidebar-link-item" href="#快速浏览react-api">快速浏览react API</a><!----></li><li class="sidebar-link"><a class="sidebar-link-item" href="#类组件生命周期">类组件生命周期</a><ul class="sidebar-links"><li class="sidebar-link"><a class="sidebar-link-item" href="#beginwork阶段">beginWork阶段</a><!----></li><li class="sidebar-link"><a class="sidebar-link-item" href="#commit阶段">commit阶段</a><!----></li></ul></li><li class="sidebar-link"><a class="sidebar-link-item" href="#setstate批量更新">setState批量更新</a><ul class="sidebar-links"><li class="sidebar-link"><a class="sidebar-link-item" href="#小结">小结</a><!----></li></ul></li><li class="sidebar-link"><a class="sidebar-link-item" href="#react中的事件">React中的事件</a><ul class="sidebar-links"><li class="sidebar-link"><a class="sidebar-link-item" href="#事件注册">事件注册</a><!----></li><li class="sidebar-link"><a class="sidebar-link-item" href="#事件分发">事件分发</a><!----></li></ul></li><li class="sidebar-link"><a class="sidebar-link-item" href="#react性能优化">React性能优化</a><ul class="sidebar-links"><li class="sidebar-link"><a class="sidebar-link-item" href="#代码分割">代码分割</a><!----></li><li class="sidebar-link"><a class="sidebar-link-item" href="#合并渲染">合并渲染</a><!----></li><li class="sidebar-link"><a class="sidebar-link-item" href="#减少渲染次数">减少渲染次数</a><!----></li></ul></li><li class="sidebar-link"><a class="sidebar-link-item" href="#hooks实现原理">Hooks实现原理</a><!----></li><li class="sidebar-link"><a class="sidebar-link-item" href="#全局context">全局Context</a><!----></li></ul></li><li class="sidebar-link"><a class="sidebar-link-item" href="/interview/源码分析/Redux源码分析">Redux源码分析</a><!----></li><li class="sidebar-link"><a class="sidebar-link-item" href="/interview/源码分析/axios源码分析">axios源码分析</a><!----></li><li class="sidebar-link"><a class="sidebar-link-item" href="/interview/源码分析/koa源码分析">koa源码分析</a><!----></li><!--]--></ul><!--[--><!--]--></aside><div class="sidebar-mask"></div><main class="page" data-v-8fcebc32><div class="container" data-v-8fcebc32><!--[--><!--]--><div style="position:relative;" class="content" data-v-8fcebc32><div><h1 id="react中的一些核心实现" tabindex="-1">React中的一些核心实现 <a class="header-anchor" href="#react中的一些核心实现" aria-hidden="true">#</a></h1><p>本文并非按照代码运行流程解析相关源码，而是按照常用的API去了解源码中的实现，因此章节阅读顺序可以随意切换。</p><h2 id="快速浏览react-api" tabindex="-1">快速浏览react API <a class="header-anchor" href="#快速浏览react-api" aria-hidden="true">#</a></h2><p>参考：<a href="https://zh-hans.reactjs.org/docs/react-api.html" target="_blank" rel="noopener noreferrer">React顶层API</a></p><p>为了便于理解源码，我们需要大致了解下面API及其使用</p><p><a href="https://zh-hans.reactjs.org/docs/refs-and-the-dom.html" target="_blank" rel="noopener noreferrer">ref</a>提供了访问DOM节点或组件实例的方式</p><ul><li>可以用于集成第三方库、绕开<code>props</code>与子节点通信等</li><li>使用方式：通过<code>React.createRef</code>创建Refs，将其赋给子节点的ref属性，在挂载之后可以通过<code>ref.current</code>访问</li><li>如果需要把子组件的ref暴露给父组件，可以通过<code>React.forwardRef</code>使用<a href="https://zh-hans.reactjs.org/docs/forwarding-refs.html" target="_blank" rel="noopener noreferrer">refs转发</a></li></ul><p><a href="https://zh-hans.reactjs.org/docs/fragments.html" target="_blank" rel="noopener noreferrer">Fragments</a>允许在render函数或函数组件中返回子组件列表，而非单个子组件</p><ul><li>无需向DOM中添加额外的子节点</li><li>使用方式：<code>&lt;React.Fragment&gt;&lt;/React.Fragment&gt;</code> 或更简单的<code>&lt;&gt;&lt;/&gt;</code>包裹子组件列表</li></ul><p><a href="https://zh-hans.reactjs.org/docs/portals.html" target="_blank" rel="noopener noreferrer">Portal</a>，提供了一种将子节点渲染到存在于父组件以外的 DOM 节点的方案，</p><ul><li>可以用来实现全局弹窗组件等需求</li><li>使用方式：在render方法中返回<code>ReactDOM.createPortal(child, container)</code></li></ul><p><a href="https://zh-hans.reactjs.org/docs/hooks-intro.html" target="_blank" rel="noopener noreferrer">Hooks</a>可以让开发者在不编写 class 的情况下使用 state 以及其他的 React 特性</p><ul><li>继<strong>高阶组件</strong>、<strong>render props</strong>之后，一种更方便的在组件之间重用状态逻辑的方案</li><li>使用方式：使用<code>useState</code>、<code>useEffect</code>等内置Hook，支持自定义Hook</li></ul><p><a href="https://zh-hans.reactjs.org/docs/context.html" target="_blank" rel="noopener noreferrer">Context</a>提供了一种无须通过props直接在组件树之间进行数据传递的方式</p><ul><li>可以在多个组件之间使用全局数据，如主题、偏好设置等</li><li>使用方式：通过<code>React.createContext</code>创建上下文<code>context</code>，然后使用<code>&lt;context.Provider&gt;</code>组件提供数据，在子组件中通过指定<code>static contextType</code>属性或者<code>&lt;context.Consumer&gt;</code>组件，访问到上下文数据</li></ul><h2 id="类组件生命周期" tabindex="-1">类组件生命周期 <a class="header-anchor" href="#类组件生命周期" aria-hidden="true">#</a></h2><p>参考：</p><ul><li><a href="https://zh-hans.reactjs.org/docs/react-component.html#the-component-lifecycle" target="_blank" rel="noopener noreferrer">组件的生命周期</a></li><li><a href="http://projects.wojtekmaj.pl/react-lifecycle-methods-diagram/" target="_blank" rel="noopener noreferrer">React生命周期图谱</a></li></ul><h3 id="beginwork阶段" tabindex="-1">beginWork阶段 <a class="header-anchor" href="#beginwork阶段" aria-hidden="true">#</a></h3><p>在之前的源码分析中我们了解到, 在<code>beginWork</code>方法中会根据<code>fiber.tag</code>判断对应子节点的类型，如果是<code>ClassComponent</code>，则调用<code>updateClassComponent</code></p><div class="language-js"><pre><code><span class="token comment">// 为了方便理解，下面方法移除了大量代码</span>
<span class="token keyword">function</span> <span class="token function">updateClassComponent</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">{</span>
  <span class="token keyword">const</span> instance <span class="token operator">=</span> workInProgress<span class="token punctuation">.</span>stateNode<span class="token punctuation">;</span>
  <span class="token keyword">if</span> <span class="token punctuation">(</span>instance <span class="token operator">===</span> <span class="token keyword">null</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>
    <span class="token comment">// 初始化</span>
    <span class="token function">constructClassInstance</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
    <span class="token function">mountClassInstance</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
  <span class="token punctuation">}</span> <span class="token keyword">else</span> <span class="token keyword">if</span> <span class="token punctuation">(</span>current <span class="token operator">===</span> <span class="token keyword">null</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>
    <span class="token comment">// 当unitOfWork.alternate为null</span>
    shouldUpdate <span class="token operator">=</span> <span class="token function">resumeMountClassInstance</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
  <span class="token punctuation">}</span> <span class="token keyword">else</span> <span class="token punctuation">{</span>
    <span class="token comment">// 直接更新</span>
    shouldUpdate <span class="token operator">=</span> <span class="token function">updateClassInstance</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
  <span class="token punctuation">}</span>
	<span class="token comment">// 如果shouldUpdate为false，则不会重新渲染</span>
  <span class="token keyword">return</span> <span class="token function">finishClassComponent</span><span class="token punctuation">(</span>shouldUpdate<span class="token punctuation">)</span>
<span class="token punctuation">}</span>
</code></pre></div><p>接下来看看初始化时的生命周期函数调用顺序。</p><div class="language-js"><pre><code><span class="token keyword">function</span> <span class="token function">constructClassInstance</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">{</span>
  <span class="token keyword">const</span> instance <span class="token operator">=</span> <span class="token keyword">new</span> <span class="token class-name">ctor</span><span class="token punctuation">(</span>props<span class="token punctuation">,</span> context<span class="token punctuation">)</span><span class="token punctuation">;</span>
  <span class="token function">adoptClassInstance</span><span class="token punctuation">(</span>workInProgress<span class="token punctuation">,</span> instance<span class="token punctuation">)</span><span class="token punctuation">;</span> <span class="token comment">// 将instance挂载到workInProgress.stateNode</span>
<span class="token punctuation">}</span>
<span class="token keyword">function</span> <span class="token function">mountClassInstance</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">{</span>
  <span class="token keyword">const</span> instance <span class="token operator">=</span> workInProgress<span class="token punctuation">.</span>stateNode<span class="token punctuation">;</span>
  instance<span class="token punctuation">.</span>props <span class="token operator">=</span> newProps<span class="token punctuation">;</span>
  instance<span class="token punctuation">.</span>state <span class="token operator">=</span> workInProgress<span class="token punctuation">.</span>memoizedState<span class="token punctuation">;</span>
  instance<span class="token punctuation">.</span>refs <span class="token operator">=</span> emptyRefsObject<span class="token punctuation">;</span>

  workInProgress<span class="token punctuation">.</span>updateQueue <span class="token operator">!==</span> <span class="token keyword">null</span> <span class="token operator">&amp;&amp;</span> <span class="token function">processUpdateQueue</span><span class="token punctuation">(</span><span class="token punctuation">)</span>

  <span class="token comment">// 调用static getDerivedStateFromProps 生命周期函数</span>
  <span class="token keyword">const</span> getDerivedStateFromProps <span class="token operator">=</span> ctor<span class="token punctuation">.</span>getDerivedStateFromProps<span class="token punctuation">;</span>
  getDerivedStateFromProps <span class="token operator">&amp;&amp;</span> <span class="token function">applyDerivedStateFromProps</span><span class="token punctuation">(</span><span class="token punctuation">)</span>

  <span class="token comment">// 当未使用新的生命周期函数时，作为补丁，则会调用旧的生命周期函数componentWillMount</span>
  <span class="token keyword">if</span> <span class="token punctuation">(</span>
    <span class="token keyword">typeof</span> ctor<span class="token punctuation">.</span>getDerivedStateFromProps <span class="token operator">!==</span> <span class="token string">&#39;function&#39;</span> <span class="token operator">&amp;&amp;</span>
    <span class="token keyword">typeof</span> instance<span class="token punctuation">.</span>getSnapshotBeforeUpdate <span class="token operator">!==</span> <span class="token string">&#39;function&#39;</span> <span class="token operator">&amp;&amp;</span>
    <span class="token punctuation">(</span><span class="token keyword">typeof</span> instance<span class="token punctuation">.</span>UNSAFE_componentWillMount <span class="token operator">===</span> <span class="token string">&#39;function&#39;</span> <span class="token operator">||</span>
      <span class="token keyword">typeof</span> instance<span class="token punctuation">.</span>componentWillMount <span class="token operator">===</span> <span class="token string">&#39;function&#39;</span><span class="token punctuation">)</span>
  <span class="token punctuation">)</span> <span class="token punctuation">{</span>
     <span class="token function">callComponentWillMount</span><span class="token punctuation">(</span>workInProgress<span class="token punctuation">,</span> instance<span class="token punctuation">)</span><span class="token punctuation">;</span>
     workInProgress<span class="token punctuation">.</span>updateQueue <span class="token operator">!==</span> <span class="token keyword">null</span> <span class="token operator">&amp;&amp;</span> <span class="token function">processUpdateQueue</span><span class="token punctuation">(</span><span class="token punctuation">)</span>
  <span class="token punctuation">}</span>
<span class="token punctuation">}</span>
<span class="token comment">// 开始调用render方法获取子节点，然后构建新的fiber树</span>
<span class="token keyword">function</span> <span class="token function">finishClassComponent</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">{</span>
  <span class="token keyword">const</span> instance <span class="token operator">=</span> workInProgress<span class="token punctuation">.</span>stateNode<span class="token punctuation">;</span>
  <span class="token keyword">let</span> nextChildren <span class="token operator">=</span> instance<span class="token punctuation">.</span><span class="token function">render</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
  <span class="token function">reconcileChildren</span><span class="token punctuation">(</span><span class="token punctuation">)</span>
  <span class="token keyword">return</span> workInProgress<span class="token punctuation">.</span>child<span class="token punctuation">;</span>
<span class="token punctuation">}</span>
</code></pre></div><h4 id="getderivedstatefromprops" tabindex="-1">getDerivedStateFromProps <a class="header-anchor" href="#getderivedstatefromprops" aria-hidden="true">#</a></h4><p>从源码可以看出，在<code>getDerivedStateFromProps</code>接收nextProps和当前的state，并返回新的state</p><div class="language-js"><pre><code><span class="token keyword">function</span> <span class="token function">applyDerivedStateFromProps</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">{</span>
  <span class="token keyword">const</span> partialState <span class="token operator">=</span> <span class="token function">getDerivedStateFromProps</span><span class="token punctuation">(</span>nextProps<span class="token punctuation">,</span> prevState<span class="token punctuation">)</span><span class="token punctuation">;</span>
  <span class="token keyword">const</span> memoizedState <span class="token operator">=</span>
    partialState <span class="token operator">===</span> <span class="token keyword">null</span> <span class="token operator">||</span> partialState <span class="token operator">===</span> <span class="token keyword">undefined</span>
      <span class="token operator">?</span> prevState
      <span class="token operator">:</span> Object<span class="token punctuation">.</span><span class="token function">assign</span><span class="token punctuation">(</span><span class="token punctuation">{</span><span class="token punctuation">}</span><span class="token punctuation">,</span> prevState<span class="token punctuation">,</span> partialState<span class="token punctuation">)</span><span class="token punctuation">;</span>
  workInProgress<span class="token punctuation">.</span>memoizedState <span class="token operator">=</span> memoizedState<span class="token punctuation">;</span>
<span class="token punctuation">}</span>
</code></pre></div><p>可见该方法的作用是:让组件在 props 变化时更新 state。</p><p>参考官方提供的这篇文档:<a href="https://zh-hans.reactjs.org/blog/2018/06/07/you-probably-dont-need-derived-state.html#when-to-use-derived-state" target="_blank" rel="noopener noreferrer">什么时候使用派生 state</a></p><p>注意该钩子为静态方法，也就是说不能在其中通过this获得组件实例。</p><h4 id="componentwillmount-将废弃" tabindex="-1">componentWillMount(将废弃) <a class="header-anchor" href="#componentwillmount-将废弃" aria-hidden="true">#</a></h4><p>注意只有当未调用新的生命周期函数时，才会调用componentWillMount</p><div class="language-js"><pre><code><span class="token keyword">function</span> <span class="token function">callComponentWillMount</span><span class="token punctuation">(</span><span class="token parameter">workInProgress<span class="token punctuation">,</span> instance</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>
  <span class="token keyword">const</span> oldState <span class="token operator">=</span> instance<span class="token punctuation">.</span>state<span class="token punctuation">;</span>
  instance<span class="token punctuation">.</span>componentWillMount <span class="token operator">&amp;&amp;</span> instance<span class="token punctuation">.</span><span class="token function">componentWillMount</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span> <span class="token comment">// 调用componentWillMount</span>

  <span class="token keyword">if</span> <span class="token punctuation">(</span>oldState <span class="token operator">!==</span> instance<span class="token punctuation">.</span>state<span class="token punctuation">)</span> <span class="token punctuation">{</span>
    classComponentUpdater<span class="token punctuation">.</span><span class="token function">enqueueReplaceState</span><span class="token punctuation">(</span>instance<span class="token punctuation">,</span> instance<span class="token punctuation">.</span>state<span class="token punctuation">,</span> <span class="token keyword">null</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
  <span class="token punctuation">}</span>
<span class="token punctuation">}</span>
</code></pre></div><p>可以看见该方法主要是执行了componentWillMount钩子函数，如果在其中显式修改了<code>this.state</code>的指向，则相当于调用了<code>this.setState</code>方法</p><h4 id="componentwillreceiveprops-将废弃" tabindex="-1">componentWillReceiveProps(将废弃) <a class="header-anchor" href="#componentwillreceiveprops-将废弃" aria-hidden="true">#</a></h4><p>回到前面的<code>updateClassComponent</code>中，如果不是初始化</p><blockquote><p>当节点未挂载时，则调用<code>resumeMountClassInstance</code></p></blockquote><div class="language-js"><pre><code><span class="token keyword">function</span> <span class="token function">resumeMountClassInstance</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">{</span>
	<span class="token keyword">const</span> instance <span class="token operator">=</span> workInProgress<span class="token punctuation">.</span>stateNode<span class="token punctuation">;</span>
  <span class="token comment">// 只有未使用新的生命周期函数时</span>
  <span class="token keyword">if</span> <span class="token punctuation">(</span><span class="token operator">!</span>hasNewLifecycles <span class="token operator">&amp;&amp;</span> instance<span class="token punctuation">.</span>componentWillReceiveProps<span class="token punctuation">)</span><span class="token punctuation">{</span>
     <span class="token comment">// 新旧props不相同</span>
     <span class="token keyword">if</span> <span class="token punctuation">(</span>oldProps <span class="token operator">!==</span> newProps <span class="token operator">||</span> oldContext <span class="token operator">!==</span> nextContext<span class="token punctuation">)</span> <span class="token punctuation">{</span>
       <span class="token comment">// 调用组件的componentWillReceiveProps方法</span>
      <span class="token function">callComponentWillReceiveProps</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
    <span class="token punctuation">}</span>
  <span class="token punctuation">}</span>
   <span class="token comment">// 调用applyDerivedStateFromProps方法</span>
  ctor<span class="token punctuation">.</span>getDerivedStateFromProps <span class="token operator">&amp;&amp;</span> <span class="token function">applyDerivedStateFromProps</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
  
  <span class="token keyword">const</span> shouldUpdate <span class="token operator">=</span> 
        <span class="token function">checkHasForceUpdateAfterProcessing</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token operator">||</span>  <span class="token comment">// 判断是否是forceUpdate</span>
        <span class="token function">checkShouldComponentUpdate</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span> <span class="token comment">// 调用组件的 instance.shouldComponentUpdate</span>
  <span class="token keyword">if</span><span class="token punctuation">(</span>shouldUpdate<span class="token punctuation">)</span><span class="token punctuation">{</span>
    	<span class="token comment">// 调用componentWillMount</span>
     <span class="token operator">!</span>hasNewLifecycles <span class="token operator">&amp;&amp;</span> instance<span class="token punctuation">.</span><span class="token function">componentWillMount</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
  <span class="token punctuation">}</span>
<span class="token punctuation">}</span>
</code></pre></div><p>首先调用了<code>componentWillReceiveProps</code>，然后在非强制更新的情况下调用<code>checkShouldComponentUpdate</code>检测是否需要更新，如果需要，再调用<code>componentWillMount</code></p><blockquote><p>当节点只需要更新时，调用<code>updateClassInstance</code></p></blockquote><div class="language-js"><pre><code><span class="token keyword">function</span> <span class="token function">updateClassInstance</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">{</span>
	<span class="token keyword">const</span> instance <span class="token operator">=</span> workInProgress<span class="token punctuation">.</span>stateNode<span class="token punctuation">;</span>
  <span class="token keyword">if</span> <span class="token punctuation">(</span><span class="token operator">!</span>hasNewLifecycles <span class="token operator">&amp;&amp;</span> instance<span class="token punctuation">.</span>componentWillReceiveProps<span class="token punctuation">)</span> <span class="token punctuation">{</span>
     <span class="token keyword">if</span> <span class="token punctuation">(</span>oldProps <span class="token operator">!==</span> newProps <span class="token operator">||</span> oldContext <span class="token operator">!==</span> nextContext<span class="token punctuation">)</span> <span class="token punctuation">{</span>
      <span class="token function">callComponentWillReceiveProps</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
    <span class="token punctuation">}</span>
  <span class="token punctuation">}</span>
  <span class="token comment">// 调用applyDerivedStateFromProps方法</span>
  ctor<span class="token punctuation">.</span>getDerivedStateFromProps <span class="token operator">&amp;&amp;</span> <span class="token function">applyDerivedStateFromProps</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
  
  <span class="token keyword">const</span> shouldUpdate <span class="token operator">=</span> 
        <span class="token function">checkHasForceUpdateAfterProcessing</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token operator">||</span>  <span class="token comment">// 判断是否是forceUpdate</span>
        <span class="token function">checkShouldComponentUpdate</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span> <span class="token comment">// 调用组件的 instance.shouldComponentUpdate</span>
  <span class="token keyword">if</span><span class="token punctuation">(</span>shouldUpdate<span class="token punctuation">)</span><span class="token punctuation">{</span>
    <span class="token comment">// 调用componentWillUpdate</span>
    <span class="token operator">!</span>hasNewLifecycles <span class="token operator">&amp;&amp;</span> instance<span class="token punctuation">.</span><span class="token function">componentWillUpdate</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
  <span class="token punctuation">}</span>
<span class="token punctuation">}</span>
</code></pre></div><p>可以看见与上面的<code>resumeMountClassInstance</code>相比，除了<code>shouldUpdate</code>为true时调用的是<code>componentWillUpdate</code>之外，其余流程基本类似。</p><h4 id="shouldcomponentupdate" tabindex="-1">shouldComponentUpdate <a class="header-anchor" href="#shouldcomponentupdate" aria-hidden="true">#</a></h4><p>在非强制更新时，上面两个方法都调用了<code>shouldComponentUpdate</code></p><div class="language-js"><pre><code><span class="token keyword">function</span> <span class="token function">checkShouldComponentUpdate</span><span class="token punctuation">(</span>
	<span class="token keyword">const</span> instance <span class="token operator">=</span> workInProgress<span class="token punctuation">.</span>stateNode<span class="token punctuation">;</span>
  <span class="token keyword">if</span><span class="token punctuation">(</span>instance<span class="token punctuation">.</span>shouldComponentUpdate<span class="token punctuation">)</span> <span class="token punctuation">{</span>
     <span class="token keyword">const</span> shouldUpdate <span class="token operator">=</span> instance<span class="token punctuation">.</span><span class="token function">shouldComponentUpdate</span><span class="token punctuation">(</span>
      newProps<span class="token punctuation">,</span>
      newState<span class="token punctuation">,</span>
      nextContext<span class="token punctuation">,</span>
    <span class="token punctuation">)</span><span class="token punctuation">;</span>
    <span class="token keyword">return</span> shouldUpdate<span class="token punctuation">;</span>
  <span class="token punctuation">}</span>	
	<span class="token keyword">if</span> <span class="token punctuation">(</span>ctor<span class="token punctuation">.</span>prototype <span class="token operator">&amp;&amp;</span> ctor<span class="token punctuation">.</span>prototype<span class="token punctuation">.</span>isPureReactComponent<span class="token punctuation">)</span> <span class="token punctuation">{</span>
		<span class="token keyword">return</span> <span class="token punctuation">(</span>
      <span class="token operator">!</span><span class="token function">shallowEqual</span><span class="token punctuation">(</span>oldProps<span class="token punctuation">,</span> newProps<span class="token punctuation">)</span> <span class="token operator">||</span> <span class="token operator">!</span><span class="token function">shallowEqual</span><span class="token punctuation">(</span>oldState<span class="token punctuation">,</span> newState<span class="token punctuation">)</span>
    <span class="token punctuation">)</span><span class="token punctuation">;</span>
  <span class="token punctuation">}</span>
	<span class="token keyword">return</span> <span class="token boolean">true</span>
<span class="token punctuation">}</span>
</code></pre></div><p>可以看见其内部，优先调用组件<code>shouldComponentUpdate</code>方法，如果是<code>PureReactComponent</code>，则进行浅比较，最终返回<code>shouldUpdate</code>。在后续的<code>finishClassComponent</code>方法中，如果传入的<code>shouldUpdate</code>为false，则不会重新渲染组件。</p><div class="language-js"><pre><code><span class="token keyword">function</span> <span class="token function">finishClassComponent</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">{</span>
  <span class="token keyword">if</span> <span class="token punctuation">(</span><span class="token operator">!</span>shouldUpdate <span class="token operator">&amp;&amp;</span> <span class="token operator">!</span>didCaptureError<span class="token punctuation">)</span> <span class="token punctuation">{</span>
    <span class="token keyword">return</span> <span class="token function">bailoutOnAlreadyFinishedWork</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
  <span class="token punctuation">}</span>
<span class="token punctuation">}</span>
</code></pre></div><h4 id="注意事项" tabindex="-1">注意事项 <a class="header-anchor" href="#注意事项" aria-hidden="true">#</a></h4><p>引入了Fiber之后，如果<code>renderRoot</code>方法是传入了异步调用参数，则在上面提到的、在<code>commit</code>之前的所有生命周期函数都可能会被调用多次，程序就可能不会按照开发者预期的流程运行。</p><h3 id="commit阶段" tabindex="-1">commit阶段 <a class="header-anchor" href="#commit阶段" aria-hidden="true">#</a></h3><p>当fiber树构建完毕之后，会进入<code>commit</code>阶段，之前分析过<code>commitRoot</code>的大致流程</p><p>在<code>commitRootImpl</code>方法中提交更新任务，可以分为如下三个阶段</p><div class="language-js"><pre><code><span class="token keyword">function</span> <span class="token function">commitRoot</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">{</span>
   <span class="token function">runWithPriority</span><span class="token punctuation">(</span>ImmediatePriority<span class="token punctuation">,</span> <span class="token function">commitRootImpl</span><span class="token punctuation">.</span><span class="token function">bind</span><span class="token punctuation">(</span><span class="token keyword">null</span><span class="token punctuation">,</span> root<span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
<span class="token punctuation">}</span>
<span class="token keyword">function</span> <span class="token function">commitRootImpl</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">{</span>
  <span class="token keyword">let</span> firstEffect <span class="token operator">=</span> finishedWork <span class="token comment">// 获取需要提交的列表</span>
  
  <span class="token comment">// before mutation 阶段</span>
  nextEffect <span class="token operator">=</span> firstEffect<span class="token punctuation">;</span> <span class="token comment">// nextEffect是一个全局变量</span>
  <span class="token keyword">do</span> <span class="token punctuation">{</span>
    <span class="token function">commitBeforeMutationEffects</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
  <span class="token punctuation">}</span> <span class="token keyword">while</span> <span class="token punctuation">(</span>nextEffect <span class="token operator">!==</span> <span class="token keyword">null</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
  
  <span class="token comment">// mutation阶段</span>
  nextEffect <span class="token operator">=</span> firstEffect<span class="token punctuation">;</span>
  <span class="token keyword">do</span> <span class="token punctuation">{</span>
    <span class="token function">commitMutationEffects</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
  <span class="token punctuation">}</span> <span class="token keyword">while</span> <span class="token punctuation">(</span>nextEffect <span class="token operator">!==</span> <span class="token keyword">null</span><span class="token punctuation">)</span><span class="token punctuation">;</span>

  <span class="token comment">// layout阶段</span>
  nextEffect <span class="token operator">=</span> firstEffect<span class="token punctuation">;</span>
  <span class="token keyword">do</span> <span class="token punctuation">{</span>
    <span class="token function">commitLayoutEffects</span><span class="token punctuation">(</span>root<span class="token punctuation">,</span> expirationTime<span class="token punctuation">)</span><span class="token punctuation">;</span>
  <span class="token punctuation">}</span> <span class="token keyword">while</span> <span class="token punctuation">(</span>nextEffect <span class="token operator">!==</span> <span class="token keyword">null</span><span class="token punctuation">)</span><span class="token punctuation">;</span>

  nextEffect <span class="token operator">=</span> <span class="token keyword">null</span><span class="token punctuation">;</span>
  <span class="token function">requestPaint</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span> <span class="token comment">// 告诉调度器可以开始绘制下一帧</span>

  <span class="token function">onCommitRoot</span><span class="token punctuation">(</span>finishedWork<span class="token punctuation">.</span>stateNode<span class="token punctuation">,</span> expirationTime<span class="token punctuation">)</span><span class="token punctuation">;</span>
  <span class="token function">flushSyncCallbackQueue</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
<span class="token punctuation">}</span>
</code></pre></div><h4 id="getsnapshotbeforeupdate" tabindex="-1">getSnapshotBeforeUpdate <a class="header-anchor" href="#getsnapshotbeforeupdate" aria-hidden="true">#</a></h4><p>在<code>commitBeforeMutationEffects</code>阶段，会根据<code>nextEffect.effectTag</code>来判断，如果<code>(nextEffect.effectTag &amp; Snapshot) !== NoEffect</code>，则调用<code>commitBeforeMutationEffectOnFiber</code></p><div class="language-js"><pre><code><span class="token comment">// commitBeforeMutationEffectOnFiber，根据`finishedWork.tag`调用对应节点的方法，如果是`ClassComponent`</span>
<span class="token keyword">if</span> <span class="token punctuation">(</span>finishedWork<span class="token punctuation">.</span>effectTag <span class="token operator">&amp;</span> Snapshot<span class="token punctuation">)</span> <span class="token punctuation">{</span>
  <span class="token comment">// 当更新时调用getSnapshotBeforeUpdate</span>
  <span class="token keyword">if</span> <span class="token punctuation">(</span>current <span class="token operator">!==</span> <span class="token keyword">null</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>
    <span class="token keyword">const</span> snapshot <span class="token operator">=</span> instance<span class="token punctuation">.</span><span class="token function">getSnapshotBeforeUpdate</span><span class="token punctuation">(</span>
      finishedWork<span class="token punctuation">.</span>elementType <span class="token operator">===</span> finishedWork<span class="token punctuation">.</span>type
        <span class="token operator">?</span> prevProps
        <span class="token operator">:</span> <span class="token function">resolveDefaultProps</span><span class="token punctuation">(</span>finishedWork<span class="token punctuation">.</span>type<span class="token punctuation">,</span> prevProps<span class="token punctuation">)</span><span class="token punctuation">,</span>
      prevState<span class="token punctuation">,</span>
    <span class="token punctuation">)</span><span class="token punctuation">;</span>
    instance<span class="token punctuation">.</span>__reactInternalSnapshotBeforeUpdate <span class="token operator">=</span> snapshot<span class="token punctuation">;</span>
  <span class="token punctuation">}</span>
<span class="token punctuation">}</span>
</code></pre></div><p>可以看见<code>getSnapshotBeforeUpdate</code>在commit的<code>before mutation</code>阶段调用，它使得组件能在发生更改之前从 DOM 中捕获一些信息。</p><h4 id="componentditmounted、componentdidupdate" tabindex="-1">componentDitMounted、componentDidUpdate <a class="header-anchor" href="#componentditmounted、componentdidupdate" aria-hidden="true">#</a></h4><p>在<code>commitLayoutEffects</code>阶段，会根据<code>nextEffect.effectTag</code>来判断，如果是</p><ul><li><code>effectTag &amp; (Update | Callback)</code>，则调用<code>commitLayoutEffectOnFiber</code>，即<code>commitLifeCycles</code></li><li><code>effectTag &amp; Ref</code>，则调用<code>commitAttachRef</code></li></ul><div class="language-js"><pre><code><span class="token comment">// commitLifeCycles，根据`finishedWork.tag`调用不同类型节点的方法，当其为`ClassComponent`时</span>
<span class="token keyword">const</span> instance <span class="token operator">=</span> finishedWork<span class="token punctuation">.</span>stateNode<span class="token punctuation">;</span>
<span class="token comment">// 如果有更新</span>
<span class="token keyword">if</span> <span class="token punctuation">(</span>finishedWork<span class="token punctuation">.</span>effectTag <span class="token operator">&amp;</span> Update<span class="token punctuation">)</span> <span class="token punctuation">{</span>
    <span class="token keyword">if</span> <span class="token punctuation">(</span>current <span class="token operator">===</span> <span class="token keyword">null</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>
        <span class="token comment">// 初始化时调用componentDidMount</span>
        instance<span class="token punctuation">.</span><span class="token function">componentDidMount</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
    <span class="token punctuation">}</span> <span class="token keyword">else</span> <span class="token punctuation">{</span>
        <span class="token keyword">const</span> prevState <span class="token operator">=</span> current<span class="token punctuation">.</span>memoizedState<span class="token punctuation">;</span>
        <span class="token comment">// 更新时调用componentDidUpdate</span>
        instance<span class="token punctuation">.</span><span class="token function">componentDidUpdate</span><span class="token punctuation">(</span>
            prevProps<span class="token punctuation">,</span>
            prevState<span class="token punctuation">,</span>
          	<span class="token comment">// 该字段是上面getSnapshotBeforeUpdate钩子的返回值</span>
            instance<span class="token punctuation">.</span>__reactInternalSnapshotBeforeUpdate
        <span class="token punctuation">)</span><span class="token punctuation">;</span>
    <span class="token punctuation">}</span>
<span class="token punctuation">}</span>
<span class="token keyword">const</span> updateQueue <span class="token operator">=</span> finishedWork<span class="token punctuation">.</span>updateQueue<span class="token punctuation">;</span>
<span class="token function">commitUpdateQueue</span><span class="token punctuation">(</span>updateQueue<span class="token punctuation">)</span>
</code></pre></div><p>可见初始化时调用的是<code>componentDidMount</code>钩子，后续更新时调用的是<code>componentDidUpdate</code>。</p><p>碰巧看见了<code>commitAttachRef</code>，我们顺道看看ref是如何挂载的</p><div class="language-js"><pre><code><span class="token keyword">function</span> <span class="token function">commitAttachRef</span><span class="token punctuation">(</span><span class="token parameter"><span class="token literal-property property">finishedWork</span><span class="token operator">:</span> Fiber</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>
  <span class="token keyword">const</span> ref <span class="token operator">=</span> finishedWork<span class="token punctuation">.</span>ref<span class="token punctuation">;</span>
  <span class="token keyword">if</span> <span class="token punctuation">(</span>ref <span class="token operator">!==</span> <span class="token keyword">null</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>
    <span class="token comment">// 获取节点的实例，DOM节点为实际元素，类组件为组件实例</span>
    <span class="token keyword">const</span> instance <span class="token operator">=</span> finishedWork<span class="token punctuation">.</span>stateNode<span class="token punctuation">;</span>
    <span class="token keyword">let</span> instanceToUse <span class="token operator">=</span> instance<span class="token punctuation">;</span>
    <span class="token keyword">if</span> <span class="token punctuation">(</span><span class="token keyword">typeof</span> ref <span class="token operator">===</span> <span class="token string">&#39;function&#39;</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>
      <span class="token comment">// ref={(el)=&gt;{this.xxx = el}}形式的ref</span>
      <span class="token function">ref</span><span class="token punctuation">(</span>instanceToUse<span class="token punctuation">)</span><span class="token punctuation">;</span>
    <span class="token punctuation">}</span> <span class="token keyword">else</span> <span class="token punctuation">{</span>
      <span class="token comment">// React.createRef形式的ref</span>
      ref<span class="token punctuation">.</span>current <span class="token operator">=</span> instanceToUse<span class="token punctuation">;</span>
    <span class="token punctuation">}</span>
  <span class="token punctuation">}</span>
<span class="token punctuation">}</span>
</code></pre></div><p>初始化时可以通过ref获取子节点的引用，在后续的声明周期如<code>getSnapshotBeforeUpdate</code>中，可以通过ref获取DOM节点，并获取该节点在发生变化之前的信息（如滚动位置等）</p><h4 id="componentwillunmount" tabindex="-1">componentWillUnmount <a class="header-anchor" href="#componentwillunmount" aria-hidden="true">#</a></h4><p>在Commit过程的<code>mutation</code>阶段，调用<code>commitMutationEffects</code>，根据<code>effectTag</code>判断实际的改动</p><ul><li><code>Placement</code>，调用<code>commitPlacement</code>插入节点</li><li><code>PlacementAndUpdate</code>，调用<code>commitPlacement</code>和<code>commitWork</code></li><li><code>Update</code>，调用<code>commitWork</code>更新容器</li><li><code>Deletion</code>，调用<code>commitDeletion</code>删除节点，此处会调用卸载<code>Unmount</code>函数</li></ul><div class="language-js"><pre><code><span class="token keyword">function</span> <span class="token function">commitDeletion</span><span class="token punctuation">(</span><span class="token parameter"><span class="token literal-property property">current</span><span class="token operator">:</span> Fiber</span><span class="token punctuation">)</span><span class="token operator">:</span> <span class="token keyword">void</span> <span class="token punctuation">{</span>
  <span class="token comment">// 实际上ReactDOM中调用的是unmountHostComponents，将DOM从父节点移除，</span>
  <span class="token comment">// 其内部调用commitNestedUnmounts</span>
  <span class="token function">commitNestedUnmounts</span><span class="token punctuation">(</span>current<span class="token punctuation">)</span><span class="token punctuation">;</span>
  <span class="token comment">// 清空fiber的相关引用，准备释放</span>
  <span class="token function">detachFiber</span><span class="token punctuation">(</span>current<span class="token punctuation">)</span><span class="token punctuation">;</span>
<span class="token punctuation">}</span>
<span class="token keyword">function</span> <span class="token function">commitNestedUnmounts</span><span class="token punctuation">(</span><span class="token parameter"><span class="token literal-property property">root</span><span class="token operator">:</span> Fiber</span><span class="token punctuation">)</span><span class="token operator">:</span> <span class="token keyword">void</span> <span class="token punctuation">{</span>
  <span class="token keyword">let</span> <span class="token literal-property property">node</span><span class="token operator">:</span> Fiber <span class="token operator">=</span> root<span class="token punctuation">;</span>
  <span class="token keyword">while</span> <span class="token punctuation">(</span><span class="token boolean">true</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>
    <span class="token comment">// 依次调用commitUnmount</span>
    <span class="token function">commitUnmount</span><span class="token punctuation">(</span>node<span class="token punctuation">)</span><span class="token punctuation">;</span>
    <span class="token comment">// node遍历顺序 root-&gt;子节点-&gt;兄弟节点-&gt;父节点</span>
  <span class="token punctuation">}</span>
<span class="token punctuation">}</span>
<span class="token keyword">function</span> <span class="token function">commitUnmount</span><span class="token punctuation">(</span><span class="token parameter"><span class="token literal-property property">current</span><span class="token operator">:</span> Fiber</span><span class="token punctuation">)</span><span class="token operator">:</span> <span class="token keyword">void</span> <span class="token punctuation">{</span>
  <span class="token keyword">if</span><span class="token punctuation">(</span>current<span class="token punctuation">.</span>tag <span class="token operator">===</span> ClassComponent<span class="token punctuation">)</span><span class="token punctuation">{</span>
    <span class="token comment">// 清除ref</span>
    <span class="token function">safelyDetachRef</span><span class="token punctuation">(</span>current<span class="token punctuation">)</span><span class="token punctuation">;</span>
    <span class="token keyword">const</span> instance <span class="token operator">=</span> current<span class="token punctuation">.</span>stateNode<span class="token punctuation">;</span>
    <span class="token comment">// 调用componentWillUnmount方法</span>
    <span class="token keyword">if</span> <span class="token punctuation">(</span><span class="token keyword">typeof</span> instance<span class="token punctuation">.</span>componentWillUnmount <span class="token operator">===</span> <span class="token string">&#39;function&#39;</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>
      <span class="token function">safelyCallComponentWillUnmount</span><span class="token punctuation">(</span>current<span class="token punctuation">,</span> instance<span class="token punctuation">)</span><span class="token punctuation">;</span>
    <span class="token punctuation">}</span>
    <span class="token keyword">return</span><span class="token punctuation">;</span>
  <span class="token punctuation">}</span>
<span class="token punctuation">}</span>
</code></pre></div><p><code>instance.componentWillUnmount</code>会在组件卸载及销毁之前直接调用，该钩子函数主要用于执行一些清除操作，如计数器、网络请求、事件订阅等。</p><h2 id="setstate批量更新" tabindex="-1">setState批量更新 <a class="header-anchor" href="#setstate批量更新" aria-hidden="true">#</a></h2><p>参考：</p><ul><li><a href="https://juejin.im/post/5b45c57c51882519790c7441" target="_blank" rel="noopener noreferrer">你真的了解setState吗</a></li></ul><p>每次<code>setState</code>都会重新渲染子树。如果你想提高性能，就尽量在低层次结构中调用<code>setState</code>或者使用<code>shouldComponentUpdate</code>去阻止渲染很大的子树。</p><p>之前在整理<code>ReactDOM.render</code>方法时了解到，在初始化时<code>legacyRenderSubtreeIntoContainer</code>方法内部调用的是</p><div class="language-js"><pre><code><span class="token function">unbatchedUpdates</span><span class="token punctuation">(</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token operator">=&gt;</span> <span class="token punctuation">{</span>
	<span class="token function">updateContainer</span><span class="token punctuation">(</span>children<span class="token punctuation">,</span> fiberRoot<span class="token punctuation">,</span> parentComponent<span class="token punctuation">,</span> callback<span class="token punctuation">)</span><span class="token punctuation">;</span>
<span class="token punctuation">}</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
</code></pre></div><p>这里我们来看看<code>unbatchedUpdates</code>方法的作用，可见其内部只是将全局变量<code>executionContext</code>设置为了</p><div class="language-js"><pre><code><span class="token keyword">export</span> <span class="token keyword">function</span> unbatchedUpdates<span class="token operator">&lt;</span><span class="token constant">A</span><span class="token punctuation">,</span> <span class="token constant">R</span><span class="token operator">&gt;</span><span class="token punctuation">(</span><span class="token function-variable function">fn</span><span class="token operator">:</span> <span class="token punctuation">(</span><span class="token parameter"><span class="token literal-property property">a</span><span class="token operator">:</span> <span class="token constant">A</span></span><span class="token punctuation">)</span> <span class="token operator">=&gt;</span> <span class="token constant">R</span><span class="token punctuation">,</span> <span class="token literal-property property">a</span><span class="token operator">:</span> <span class="token constant">A</span><span class="token punctuation">)</span><span class="token operator">:</span> <span class="token constant">R</span> <span class="token punctuation">{</span>
  <span class="token keyword">const</span> prevExecutionContext <span class="token operator">=</span> executionContext<span class="token punctuation">;</span>
  executionContext <span class="token operator">&amp;=</span> <span class="token operator">~</span>BatchedContext<span class="token punctuation">;</span>
  executionContext <span class="token operator">|=</span> LegacyUnbatchedContext<span class="token punctuation">;</span>
  <span class="token keyword">try</span> <span class="token punctuation">{</span>
    <span class="token keyword">return</span> <span class="token function">fn</span><span class="token punctuation">(</span>a<span class="token punctuation">)</span><span class="token punctuation">;</span>
  <span class="token punctuation">}</span> <span class="token keyword">finally</span> <span class="token punctuation">{</span>
    executionContext <span class="token operator">=</span> prevExecutionContext<span class="token punctuation">;</span>
    <span class="token keyword">if</span> <span class="token punctuation">(</span>executionContext <span class="token operator">===</span> NoContext<span class="token punctuation">)</span> <span class="token punctuation">{</span>
      <span class="token comment">// Flush the immediate callbacks that were scheduled during this batch</span>
      <span class="token function">flushSyncCallbackQueue</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
    <span class="token punctuation">}</span>
  <span class="token punctuation">}</span>
<span class="token punctuation">}</span>
</code></pre></div><p>我们可以回顾一下<code>setState</code>的执行流程</p><div class="language-"><pre><code>this.setState() 
this.updater.enqueueSetState

this.updater = classComponentUpdater
</code></pre></div><p>搜索<code>executionContext</code>，找到赋值为<code>BatchedContext</code>的地方</p><h3 id="小结" tabindex="-1">小结 <a class="header-anchor" href="#小结" aria-hidden="true">#</a></h3><p>在合成事件和钩子函数中，React会通过一个</p><ul><li><code>setState</code> 只在合成事件和钩子函数中是“异步”的，在原生事件和 <code>setTimeout</code> 等异步队列中中都是同步的。</li></ul><h2 id="react中的事件" tabindex="-1">React中的事件 <a class="header-anchor" href="#react中的事件" aria-hidden="true">#</a></h2><p>参考：</p><ul><li><a href="https://zh-hans.reactjs.org/docs/events.html" target="_blank" rel="noopener noreferrer">合成事件-React官方文档</a></li><li><a href="https://www.jianshu.com/p/c01756e520c7" target="_blank" rel="noopener noreferrer">React事件机制</a></li></ul><h3 id="事件注册" tabindex="-1">事件注册 <a class="header-anchor" href="#事件注册" aria-hidden="true">#</a></h3><p>在前面的整理中我们知道了DOM节点的初始化流程，主要经过下面步骤</p><ul><li>调用<code>renderRoot</code>方法渲染根节点，内部调用<code>performUnitOfWork</code>-&gt;<code>completeUnitOfWork</code>-&gt;<code>completeWork</code></li><li>在<code>completeWork</code>中，根据当前正在运行的<code>workInProgress.tag</code>来选择对应的运行逻辑，如果是<code>HostComponent</code><ul><li>调用<code>createInstance</code>来创建DOM对象，接着在<code>finalizeInitialChildren</code>方法中调用<code>setInitialProperties</code>来获取需要初始化的属性<code>nextProps</code>，实际上即为JSX在标签上解析的相关属性</li><li>然后调用在<code>setInitialDOMProperties</code>，并遍历<code>nextProps</code>上的字段，根据不同的字段类型做对应处理，如<code>dangerouslySetInnerHTML</code>、<code>children</code>和事件名等，这里我们暂时只需要关注事件属性的处理</li><li>如果节点上包含事件属性，则调用<code>ensureListeningTo(rootContainerElement, propKey)</code><ul><li>通过<code>listeningSet</code>集合，保证多个节点的相同事件名只会在document上注册一次</li><li>事件的注册是在<code>trapEventForPluginEventSystem</code>方法中完成的，内部会根据事件名确认事件优先级，然后实现对应的事件处理函数如<code> listener = dispatchEvent.bind(null, topLevelType, PLUGIN_EVENT_SYSTEM)</code></li></ul></li></ul></li><li>最后将对应事件名和事件处理函数注册在根节点<code>document</code>上，完成事件委托</li></ul><h3 id="事件分发" tabindex="-1">事件分发 <a class="header-anchor" href="#事件分发" aria-hidden="true">#</a></h3><p>前面我们知道了所有的事件类型都被注册在document上，现在来整理一下事件触发时的运行流程，以<code>click</code>为例，</p><ul><li>点击文档时，将触发事件处理函数，此时将获取原始的事件对象<code>nativeEvent</code>和事件类型，根据<code>nativeEvent.target</code>可以获取对应的<code>targetInst</code>，及该DOM节点对应的<code>Fiber Node</code></li><li>根据事件类型和原始事件，调用<code>possiblePlugin.extractEvents</code>初始化一个合成事件<code>event</code><ul><li>调用<code>EventConstructor.getPooled</code>获取事件对象 <ul><li>如果事件池有剩余的事件对象，则取出并根据原始事件修改属性</li><li>如果事件池无可用的事件对象，则初始化一个合成事件对象</li></ul></li><li>调用<code>accumulateTwoPhaseDispatchesSingle</code>获取事件处理函数 <ul><li>从<code>targetInst</code>开始，向上遍历父节点，填充事件传递的path，越靠后的节点越顶层</li><li>从后向前遍历节点，触发<code>captured</code>，然后获取节点props的<code>on...Capture</code>属性作为事件处理函数，如果存在，则将其保存在<code>event._dispatchListeners</code></li><li>从前向后遍历节点，触发<code>bubbled</code>，然后获取节点props的<code>on...</code>属性作为事件处理函数，如果存在，则同样将其保存在<code>event._dispatchListeners</code></li><li>注意当前<code>event._dispatchListeners</code>可能保存了多个节点的事件处理函数</li></ul></li></ul></li><li>然后在<code>executeDispatchesAndRelease</code>方法中执行事件处理函数 <ul><li>依次调用事件处理函数列表，先捕获后冒泡，并将合成事件<code>event</code>作为参数传递给事件处理函数</li><li>事件函数处理完毕，判断合成事件是否可回收，如果可回收，则将其放回事件池，留作下次使用</li></ul></li></ul><h2 id="react性能优化" tabindex="-1">React性能优化 <a class="header-anchor" href="#react性能优化" aria-hidden="true">#</a></h2><p>从源码中我们可以发现下面几个优化点</p><h3 id="代码分割" tabindex="-1">代码分割 <a class="header-anchor" href="#代码分割" aria-hidden="true">#</a></h3><p><code>React.lazy</code>函数能让你像渲染常规组件一样处理动态引入（的组件）,<code>Suspense</code>可以用于等待异步组件加载的展示</p><h3 id="合并渲染" tabindex="-1">合并渲染 <a class="header-anchor" href="#合并渲染" aria-hidden="true">#</a></h3><p>在UI变化中，不必立即触发每个更新，比如在极短的时间内页面状态<code>A-&gt;B-&gt;C</code>，那更新状态B就导致性能浪费。</p><p>可以说，setState是对单个组件的合并渲染，batchedUpdates是对多个组件的合并渲染。合并渲染是React最主要的优化手段。</p><h3 id="减少渲染次数" tabindex="-1">减少渲染次数 <a class="header-anchor" href="#减少渲染次数" aria-hidden="true">#</a></h3><h4 id="react-memo" tabindex="-1">React.memo <a class="header-anchor" href="#react-memo" aria-hidden="true">#</a></h4><p>如果函数组件在给定相同 props 的情况下渲染相同的结果，那么可以通过将其包装在 <a href="https://zh-hans.reactjs.org/docs/react-api.html#reactmemo" target="_blank" rel="noopener noreferrer">React.memo</a> 中调用</p><h4 id="shouldcomponentupdate-1" tabindex="-1">shouldComponentUpdate <a class="header-anchor" href="#shouldcomponentupdate-1" aria-hidden="true">#</a></h4><p>在 shouldComponentUpdate() 中根据当前 state 或 props 判断是否需要调用render方法来重新渲染子节点。</p><p><a href="https://zh-hans.reactjs.org/docs/react-component.html#shouldcomponentupdate" target="_blank" rel="noopener noreferrer">https://zh-hans.reactjs.org/docs/react-component.html#shouldcomponentupdate</a></p><h4 id="purecomponent" tabindex="-1">PureComponent <a class="header-anchor" href="#purecomponent" aria-hidden="true">#</a></h4><p>React.Component 并未实现 shouldComponentUpdate()，而 React.PureComponent 中以浅层对比 prop 和 state 的方式来实现了该函数。</p><p><code>PureComponent</code>并未实现 <code>shouldComponentUpdate</code>方法，只是对props和state进行浅比较，可以结合使用<code>Immutable.js</code>来创建不可变对象，通过它来简化对象比较，提高性能。</p><h2 id="hooks实现原理" tabindex="-1">Hooks实现原理 <a class="header-anchor" href="#hooks实现原理" aria-hidden="true">#</a></h2><p>在<code>updateFunctionComponent</code>中，调用的是<code>renderWithHooks</code>返回子节点</p><h2 id="全局context" tabindex="-1">全局Context <a class="header-anchor" href="#全局context" aria-hidden="true">#</a></h2></div></div><footer class="page-footer" data-v-8fcebc32 data-v-b65b4b36><div class="edit" data-v-b65b4b36><div class="edit-link" data-v-b65b4b36 data-v-55695e90><!----></div></div><div class="updated" data-v-b65b4b36><!----></div></footer><div class="next-and-prev-link" data-v-8fcebc32 data-v-e65a9748><div class="container" data-v-e65a9748><div class="prev" data-v-e65a9748><a class="link" href="/interview/源码分析/ReactFibler源码分析" data-v-e65a9748><svg xmlns="http://www.w3.org/2000/svg" viewbox="0 0 24 24" class="icon icon-prev" data-v-e65a9748><path d="M19,11H7.4l5.3-5.3c0.4-0.4,0.4-1,0-1.4s-1-0.4-1.4,0l-7,7c-0.1,0.1-0.2,0.2-0.2,0.3c-0.1,0.2-0.1,0.5,0,0.8c0.1,0.1,0.1,0.2,0.2,0.3l7,7c0.2,0.2,0.5,0.3,0.7,0.3s0.5-0.1,0.7-0.3c0.4-0.4,0.4-1,0-1.4L7.4,13H19c0.6,0,1-0.4,1-1S19.6,11,19,11z"></path></svg><span class="text" data-v-e65a9748>ReactFibler源码分析</span></a></div><div class="next" data-v-e65a9748><a class="link" href="/interview/源码分析/Redux源码分析" data-v-e65a9748><span class="text" data-v-e65a9748>Redux源码分析</span><svg xmlns="http://www.w3.org/2000/svg" viewbox="0 0 24 24" class="icon icon-next" data-v-e65a9748><path d="M19.9,12.4c0.1-0.2,0.1-0.5,0-0.8c-0.1-0.1-0.1-0.2-0.2-0.3l-7-7c-0.4-0.4-1-0.4-1.4,0s-0.4,1,0,1.4l5.3,5.3H5c-0.6,0-1,0.4-1,1s0.4,1,1,1h11.6l-5.3,5.3c-0.4,0.4-0.4,1,0,1.4c0.2,0.2,0.5,0.3,0.7,0.3s0.5-0.1,0.7-0.3l7-7C19.8,12.6,19.9,12.5,19.9,12.4z"></path></svg></a></div></div></div><!--[--><!--]--></div></main></div><!----><!--]--></div>
    <script>__VP_HASH_MAP__ = JSON.parse("{\"app_android.md\":\"a181c9ce\",\"app_flutter.md\":\"f515bb02\",\"app_ios.md\":\"1eba1583\",\"app_webview.md\":\"58fc22cc\",\"readme.md\":\"d8359e04\",\"index.md\":\"8c37c295\",\"前端_css_css3.md\":\"a8d69721\",\"前端_css_readme.md\":\"1a0c99cd\",\"前端_css_分辨率.md\":\"6debbf62\",\"前端_css_基础知识.md\":\"bb24a0e9\",\"前端_css_性能优化.md\":\"1d428186\",\"前端_css_核心知识.md\":\"5c8a18aa\",\"前端_css_编写样式表.md\":\"2393cab5\",\"前端_css_选择器.md\":\"8d2efe94\",\"前端_html_html.md\":\"6888f85e\",\"前端_html_seo优化.md\":\"18abd121\",\"前端_html_web components.md\":\"d2e2e387\",\"前端_html_webassembly.md\":\"f763b06c\",\"前端_html_浏览器解析与渲染流程.md\":\"feec3301\",\"前端_javascript_canvas.md\":\"fe71edfd\",\"前端_javascript_dom和bom.md\":\"e386373b\",\"前端_javascript_ecmascript.md\":\"306272b4\",\"前端_javascript_eventloop.md\":\"dad49dfb\",\"前端_javascript_nodejs.md\":\"41aad6fe\",\"前端_javascript_readme.md\":\"1014db19\",\"前端_javascript_typescript.md\":\"87b58e31\",\"前端_javascript_事件流.md\":\"927305b3\",\"前端_javascript_函数式编程.md\":\"8742c510\",\"前端_javascript_原型.md\":\"51e3fc3c\",\"前端_javascript_数据类型.md\":\"7998939f\",\"前端_javascript_正则.md\":\"8b37b015\",\"前端_javascript_运算符.md\":\"21cafa0e\",\"前端_readme.md\":\"ab123e3e\",\"前端_业务相关_ab测试.md\":\"e21b4e67\",\"前端_业务相关_babel.md\":\"223a9049\",\"前端_业务相关_ci.md\":\"843c3666\",\"前端_业务相关_docker.md\":\"9d9bfe23\",\"前端_业务相关_web直播.md\":\"ccfe19c8\",\"前端_业务相关_git.md\":\"ea8aaed1\",\"前端_业务相关_mock.md\":\"0ea359a0\",\"前端_业务相关_npm.md\":\"0320bd1f\",\"前端_业务相关_webpack.md\":\"231ea6bb\",\"前端_业务相关_web安全.md\":\"6f217686\",\"前端_业务相关_前端工程化.md\":\"59a55c3d\",\"前端_业务相关_单元测试.md\":\"105fb80d\",\"前端_业务相关_可视化页面工具.md\":\"a762b606\",\"前端_业务相关_微前端.md\":\"00a64404\",\"前端_业务相关_性能优化.md\":\"22c16637\",\"前端_业务相关_数据埋点.md\":\"4b392fcd\",\"前端_业务相关_模块化.md\":\"699e8fe0\",\"前端_业务相关_类前端业务.md\":\"1518c654\",\"前端_业务相关_调试.md\":\"b74224c3\",\"前端_业务相关_跨端.md\":\"3399295e\",\"前端_库与框架_chrome扩展程序.md\":\"164ec012\",\"前端_库与框架_electron.md\":\"7016de33\",\"前端_库与框架_immutable.md\":\"b3e9c89d\",\"前端_库与框架_readme.md\":\"c02fdd8d\",\"前端_库与框架_react.md\":\"5c2ba656\",\"前端_库与框架_rxjs.md\":\"ee62fdcc\",\"前端_库与框架_svelet.md\":\"0651e73d\",\"前端_库与框架_vue.md\":\"4ab66354\",\"前端_库与框架_vuex.md\":\"0562f61d\",\"前端_库与框架_diff算法.md\":\"421eb89a\",\"前端_库与框架_几种框架的对比.md\":\"6378b5a1\",\"前端_库与框架_单页面应用router.md\":\"c41c8084\",\"前端_库与框架_微信小程序.md\":\"0eabf379\",\"前端_库与框架_技术选型.md\":\"38e95d40\",\"后台_clickhouse.md\":\"078143d4\",\"后台_java.md\":\"d112d350\",\"后台_mongodb.md\":\"a3e4dffb\",\"后台_mysql.md\":\"c195dbea\",\"后台_php.md\":\"791fb60e\",\"后台_readme.md\":\"dcf7fe6d\",\"后台_restful.md\":\"561380b3\",\"导读.md\":\"fbc538c3\",\"数据结构和算法_readme.md\":\"7336ddb0\",\"数据结构和算法_动态规划.md\":\"2c12c37a\",\"数据结构和算法_基本数据结构.md\":\"409b57c2\",\"数据结构和算法_基本算法.md\":\"082e3f23\",\"数据结构和算法_栈.md\":\"498ae413\",\"游戏开发_readme.md\":\"2a2fa357\",\"游戏开发_tiledmap教程汇总.md\":\"9f943a6e\",\"游戏开发_技能系统.md\":\"94d049cb\",\"游戏开发_游戏开发之前的准备.md\":\"c8451bcf\",\"游戏开发_游戏类型.md\":\"2d673e90\",\"源码分析_readme.md\":\"3363b547\",\"源码分析_reactfibler源码分析.md\":\"f04a13c5\",\"源码分析_react源码分析.md\":\"71769f59\",\"源码分析_redux源码分析.md\":\"489f7654\",\"源码分析_axios源码分析.md\":\"b709d6ad\",\"源码分析_koa源码分析.md\":\"099f4a1f\",\"网络_dns.md\":\"da6f33ac\",\"网络_http.md\":\"9b2f2fd5\",\"网络_nginx.md\":\"757b21cb\",\"网络_readme.md\":\"2814b435\",\"网络_rpc.md\":\"651e6edc\",\"网络_前端网络请求.md\":\"dfd29831\",\"网络_抓包.md\":\"14cc2a9a\",\"计算机基础_readme.md\":\"c2582b09\",\"计算机基础_操作系统.md\":\"e8ebf08e\",\"计算机基础_编译原理.md\":\"78e59630\",\"计算机基础_计算机网络.md\":\"9612960b\",\"计算机基础_软件工程.md\":\"a23cd2bf\",\"读书笔记_readme.md\":\"02cec0b1\",\"读书笔记_如何阅读一本书.md\":\"90e7dc29\",\"面试_readme.md\":\"9f7d45aa\",\"面试_面试记录_2017_dae.md\":\"9ffa0cb7\",\"面试_面试记录_2017_te.md\":\"4af7fa04\",\"面试_面试记录_2018_ayldm.md\":\"78e553fb\",\"面试_面试记录_2018_hdjr.md\":\"a7957552\",\"面试_面试记录_2018_md.md\":\"3d273eb4\",\"面试_面试记录_2018_pakj.md\":\"721ccbcc\",\"面试_面试记录_2018_qkcj.md\":\"d74760cb\",\"面试_面试记录_2018_sfwy.md\":\"727f8ae3\",\"面试_面试记录_2018_tw.md\":\"3457798d\",\"面试_面试记录_2018_yhkj.md\":\"15faec21\",\"面试_面试记录_2018_yskj.md\":\"fb191150\",\"面试_面试记录_2018_z8.md\":\"f92e6e47\",\"面试_面试记录_2019_bcz.md\":\"6a50a51a\",\"面试_面试记录_2019_hkjt.md\":\"45565128\",\"面试_面试记录_2019_jrtt.md\":\"657c087c\",\"面试_面试记录_2019_lds.md\":\"5acb47b1\",\"面试_面试记录_2019_qexr.md\":\"cd2da172\",\"面试_面试记录_2019_wblz.md\":\"93a713cf\",\"面试_面试记录_2019_xflx.md\":\"0469f444\",\"面试_面试题_css.md\":\"de7ab8c1\",\"面试_面试题_dom.md\":\"e0bba38e\",\"面试_面试题_ecmascript.md\":\"ebc72eba\",\"面试_面试题_html.md\":\"6869b9ef\",\"面试_面试题_readme.md\":\"3ea870b6\",\"面试_面试题_react.md\":\"b6c9e1fe\",\"面试_面试题_vue.md\":\"33d60e01\",\"面试_面试题_代码实现.md\":\"b7685612\",\"面试_面试题_代码阅读.md\":\"0048adfd\",\"面试_面试题_其他问题.md\":\"4d3285e4\",\"面试_面试题_兼容及bug.md\":\"bdd9bcf3\",\"面试_面试题_常见需求.md\":\"ba5c5b1d\",\"面试_面试题_算法实现.md\":\"24d2121b\",\"面试_面试题_网络.md\":\"c94234b4\"}")</script>
    <script type="module" async src="/interview/assets/app.062798f6.js"></script>
    
  </body>
</html>