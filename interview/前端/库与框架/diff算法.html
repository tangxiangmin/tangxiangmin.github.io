<!DOCTYPE html>
<html lang="en-US">
  <head>
    <meta charset="utf-8">
    <meta name="viewport" content="width=device-width,initial-scale=1">
    <title>diff算法概述 | Shymean</title>
    <meta name="description" content="fe">
    <link rel="stylesheet" href="/assets/style.4eab0d57.css">
    <link rel="modulepreload" href="/assets/app.946f11db.js">
    <link rel="modulepreload" href="/assets/前端_库与框架_diff算法.md.c17466da.lean.js">
    
    <meta name="twitter:title" content="diff算法概述 | Shymean">
  <meta property="og:title" content="diff算法概述 | Shymean">
  </head>
  <body>
    <div id="app"><!--[--><div class="theme"><header class="nav-bar" data-v-40587210><div class="sidebar-button" data-v-40587210><svg class="icon" xmlns="http://www.w3.org/2000/svg" aria-hidden="true" role="img" viewBox="0 0 448 512"><path fill="currentColor" d="M436 124H12c-6.627 0-12-5.373-12-12V80c0-6.627 5.373-12 12-12h424c6.627 0 12 5.373 12 12v32c0 6.627-5.373 12-12 12zm0 160H12c-6.627 0-12-5.373-12-12v-32c0-6.627 5.373-12 12-12h424c6.627 0 12 5.373 12 12v32c0 6.627-5.373 12-12 12zm0 160H12c-6.627 0-12-5.373-12-12v-32c0-6.627 5.373-12 12-12h424c6.627 0 12 5.373 12 12v32c0 6.627-5.373 12-12 12z" class></path></svg></div><a class="nav-bar-title" href="/" aria-label="Shymean, back to home" data-v-40587210 data-v-016a8bd8><!----> Shymean</a><div class="flex-grow" data-v-40587210></div><div class="nav" data-v-40587210><nav class="nav-links" data-v-40587210 data-v-35b91e7e><!--[--><div class="item" data-v-35b91e7e><div class="nav-link" data-v-35b91e7e data-v-49fe041d><a class="item" href="/导读" data-v-49fe041d>导读 <!----></a></div></div><div class="item" data-v-35b91e7e><div class="nav-dropdown-link" data-v-35b91e7e data-v-18d75f62><button class="button" data-v-18d75f62><span class="button-text" data-v-18d75f62>前端</span><span class="right button-arrow" data-v-18d75f62></span></button><ul class="dialog" data-v-18d75f62><!--[--><li class="dialog-item" data-v-18d75f62><div class="nav-dropdown-link-item" data-v-18d75f62 data-v-07381bdb><a class="item" href="/前端/HTML/HTML" data-v-07381bdb><span class="arrow" data-v-07381bdb></span><span class="text" data-v-07381bdb>HTML</span><span class="icon" data-v-07381bdb><!----></span></a></div></li><li class="dialog-item" data-v-18d75f62><div class="nav-dropdown-link-item" data-v-18d75f62 data-v-07381bdb><a class="item" href="/前端/CSS/README" data-v-07381bdb><span class="arrow" data-v-07381bdb></span><span class="text" data-v-07381bdb>CSS</span><span class="icon" data-v-07381bdb><!----></span></a></div></li><li class="dialog-item" data-v-18d75f62><div class="nav-dropdown-link-item" data-v-18d75f62 data-v-07381bdb><a class="item" href="/前端/JavaScript/README" data-v-07381bdb><span class="arrow" data-v-07381bdb></span><span class="text" data-v-07381bdb>JavaScript</span><span class="icon" data-v-07381bdb><!----></span></a></div></li><li class="dialog-item" data-v-18d75f62><div class="nav-dropdown-link-item" data-v-18d75f62 data-v-07381bdb><a class="item" href="/前端/库与框架/README" data-v-07381bdb><span class="arrow" data-v-07381bdb></span><span class="text" data-v-07381bdb>库与框架</span><span class="icon" data-v-07381bdb><!----></span></a></div></li><li class="dialog-item" data-v-18d75f62><div class="nav-dropdown-link-item" data-v-18d75f62 data-v-07381bdb><a class="item" href="/前端/业务相关/前端工程化" data-v-07381bdb><span class="arrow" data-v-07381bdb></span><span class="text" data-v-07381bdb>业务相关</span><span class="icon" data-v-07381bdb><!----></span></a></div></li><li class="dialog-item" data-v-18d75f62><div class="nav-dropdown-link-item" data-v-18d75f62 data-v-07381bdb><a class="item" href="/源码分析/README" data-v-07381bdb><span class="arrow" data-v-07381bdb></span><span class="text" data-v-07381bdb>源码分析</span><span class="icon" data-v-07381bdb><!----></span></a></div></li><!--]--></ul></div></div><div class="item" data-v-35b91e7e><div class="nav-link" data-v-35b91e7e data-v-49fe041d><a class="item" href="/App/Android" data-v-49fe041d>App <!----></a></div></div><div class="item" data-v-35b91e7e><div class="nav-link" data-v-35b91e7e data-v-49fe041d><a class="item" href="/后台/README" data-v-49fe041d>后台 <!----></a></div></div><div class="item" data-v-35b91e7e><div class="nav-dropdown-link" data-v-35b91e7e data-v-18d75f62><button class="button" data-v-18d75f62><span class="button-text" data-v-18d75f62>计算机基础</span><span class="right button-arrow" data-v-18d75f62></span></button><ul class="dialog" data-v-18d75f62><!--[--><li class="dialog-item" data-v-18d75f62><div class="nav-dropdown-link-item" data-v-18d75f62 data-v-07381bdb><a class="item" href="/计算机基础/README" data-v-07381bdb><span class="arrow" data-v-07381bdb></span><span class="text" data-v-07381bdb>计算机基础</span><span class="icon" data-v-07381bdb><!----></span></a></div></li><li class="dialog-item" data-v-18d75f62><div class="nav-dropdown-link-item" data-v-18d75f62 data-v-07381bdb><a class="item" href="/数据结构和算法/README" data-v-07381bdb><span class="arrow" data-v-07381bdb></span><span class="text" data-v-07381bdb>数据结构和算法</span><span class="icon" data-v-07381bdb><!----></span></a></div></li><li class="dialog-item" data-v-18d75f62><div class="nav-dropdown-link-item" data-v-18d75f62 data-v-07381bdb><a class="item" href="/网络/README" data-v-07381bdb><span class="arrow" data-v-07381bdb></span><span class="text" data-v-07381bdb>网络</span><span class="icon" data-v-07381bdb><!----></span></a></div></li><!--]--></ul></div></div><div class="item" data-v-35b91e7e><div class="nav-link" data-v-35b91e7e data-v-49fe041d><a class="item" href="/面试/README" data-v-49fe041d>面试 <!----></a></div></div><div class="item" data-v-35b91e7e><div class="nav-link" data-v-35b91e7e data-v-49fe041d><a class="item" href="/游戏开发/README" data-v-49fe041d>游戏开发 <!----></a></div></div><div class="item" data-v-35b91e7e><div class="nav-link" data-v-35b91e7e data-v-49fe041d><a class="item" href="/读书笔记/README" data-v-49fe041d>读书笔记 <!----></a></div></div><div class="item" data-v-35b91e7e><div class="nav-link" data-v-35b91e7e data-v-49fe041d><a class="item isExternal" href="https://github.com/tangxiangmin/interview" target="_blank" rel="noopener noreferrer" data-v-49fe041d>github <svg class="icon outbound" xmlns="http://www.w3.org/2000/svg" aria-hidden="true" x="0px" y="0px" viewbox="0 0 100 100" width="15" height="15" data-v-49fe041d><path fill="currentColor" d="M18.8,85.1h56l0,0c2.2,0,4-1.8,4-4v-32h-8v28h-48v-48h28v-8h-32l0,0c-2.2,0-4,1.8-4,4v56C14.8,83.3,16.6,85.1,18.8,85.1z"></path><polygon fill="currentColor" points="45.7,48.7 51.3,54.3 77.2,28.5 77.2,37.2 85.2,37.2 85.2,14.9 62.8,14.9 62.8,22.9 71.5,22.9"></polygon></svg></a></div></div><div class="item" data-v-35b91e7e><div class="nav-link" data-v-35b91e7e data-v-49fe041d><a class="item isExternal" href="https://shymean.com" target="_blank" rel="noopener noreferrer" data-v-49fe041d>shymean <svg class="icon outbound" xmlns="http://www.w3.org/2000/svg" aria-hidden="true" x="0px" y="0px" viewbox="0 0 100 100" width="15" height="15" data-v-49fe041d><path fill="currentColor" d="M18.8,85.1h56l0,0c2.2,0,4-1.8,4-4v-32h-8v28h-48v-48h28v-8h-32l0,0c-2.2,0-4,1.8-4,4v56C14.8,83.3,16.6,85.1,18.8,85.1z"></path><polygon fill="currentColor" points="45.7,48.7 51.3,54.3 77.2,28.5 77.2,37.2 85.2,37.2 85.2,14.9 62.8,14.9 62.8,22.9 71.5,22.9"></polygon></svg></a></div></div><!--]--><!----><!----></nav></div><!--[--><!--]--></header><aside class="sidebar" data-v-17c48e2f><nav class="nav-links nav" data-v-17c48e2f data-v-35b91e7e><!--[--><div class="item" data-v-35b91e7e><div class="nav-link" data-v-35b91e7e data-v-49fe041d><a class="item" href="/导读" data-v-49fe041d>导读 <!----></a></div></div><div class="item" data-v-35b91e7e><div class="nav-dropdown-link" data-v-35b91e7e data-v-18d75f62><button class="button" data-v-18d75f62><span class="button-text" data-v-18d75f62>前端</span><span class="right button-arrow" data-v-18d75f62></span></button><ul class="dialog" data-v-18d75f62><!--[--><li class="dialog-item" data-v-18d75f62><div class="nav-dropdown-link-item" data-v-18d75f62 data-v-07381bdb><a class="item" href="/前端/HTML/HTML" data-v-07381bdb><span class="arrow" data-v-07381bdb></span><span class="text" data-v-07381bdb>HTML</span><span class="icon" data-v-07381bdb><!----></span></a></div></li><li class="dialog-item" data-v-18d75f62><div class="nav-dropdown-link-item" data-v-18d75f62 data-v-07381bdb><a class="item" href="/前端/CSS/README" data-v-07381bdb><span class="arrow" data-v-07381bdb></span><span class="text" data-v-07381bdb>CSS</span><span class="icon" data-v-07381bdb><!----></span></a></div></li><li class="dialog-item" data-v-18d75f62><div class="nav-dropdown-link-item" data-v-18d75f62 data-v-07381bdb><a class="item" href="/前端/JavaScript/README" data-v-07381bdb><span class="arrow" data-v-07381bdb></span><span class="text" data-v-07381bdb>JavaScript</span><span class="icon" data-v-07381bdb><!----></span></a></div></li><li class="dialog-item" data-v-18d75f62><div class="nav-dropdown-link-item" data-v-18d75f62 data-v-07381bdb><a class="item" href="/前端/库与框架/README" data-v-07381bdb><span class="arrow" data-v-07381bdb></span><span class="text" data-v-07381bdb>库与框架</span><span class="icon" data-v-07381bdb><!----></span></a></div></li><li class="dialog-item" data-v-18d75f62><div class="nav-dropdown-link-item" data-v-18d75f62 data-v-07381bdb><a class="item" href="/前端/业务相关/前端工程化" data-v-07381bdb><span class="arrow" data-v-07381bdb></span><span class="text" data-v-07381bdb>业务相关</span><span class="icon" data-v-07381bdb><!----></span></a></div></li><li class="dialog-item" data-v-18d75f62><div class="nav-dropdown-link-item" data-v-18d75f62 data-v-07381bdb><a class="item" href="/源码分析/README" data-v-07381bdb><span class="arrow" data-v-07381bdb></span><span class="text" data-v-07381bdb>源码分析</span><span class="icon" data-v-07381bdb><!----></span></a></div></li><!--]--></ul></div></div><div class="item" data-v-35b91e7e><div class="nav-link" data-v-35b91e7e data-v-49fe041d><a class="item" href="/App/Android" data-v-49fe041d>App <!----></a></div></div><div class="item" data-v-35b91e7e><div class="nav-link" data-v-35b91e7e data-v-49fe041d><a class="item" href="/后台/README" data-v-49fe041d>后台 <!----></a></div></div><div class="item" data-v-35b91e7e><div class="nav-dropdown-link" data-v-35b91e7e data-v-18d75f62><button class="button" data-v-18d75f62><span class="button-text" data-v-18d75f62>计算机基础</span><span class="right button-arrow" data-v-18d75f62></span></button><ul class="dialog" data-v-18d75f62><!--[--><li class="dialog-item" data-v-18d75f62><div class="nav-dropdown-link-item" data-v-18d75f62 data-v-07381bdb><a class="item" href="/计算机基础/README" data-v-07381bdb><span class="arrow" data-v-07381bdb></span><span class="text" data-v-07381bdb>计算机基础</span><span class="icon" data-v-07381bdb><!----></span></a></div></li><li class="dialog-item" data-v-18d75f62><div class="nav-dropdown-link-item" data-v-18d75f62 data-v-07381bdb><a class="item" href="/数据结构和算法/README" data-v-07381bdb><span class="arrow" data-v-07381bdb></span><span class="text" data-v-07381bdb>数据结构和算法</span><span class="icon" data-v-07381bdb><!----></span></a></div></li><li class="dialog-item" data-v-18d75f62><div class="nav-dropdown-link-item" data-v-18d75f62 data-v-07381bdb><a class="item" href="/网络/README" data-v-07381bdb><span class="arrow" data-v-07381bdb></span><span class="text" data-v-07381bdb>网络</span><span class="icon" data-v-07381bdb><!----></span></a></div></li><!--]--></ul></div></div><div class="item" data-v-35b91e7e><div class="nav-link" data-v-35b91e7e data-v-49fe041d><a class="item" href="/面试/README" data-v-49fe041d>面试 <!----></a></div></div><div class="item" data-v-35b91e7e><div class="nav-link" data-v-35b91e7e data-v-49fe041d><a class="item" href="/游戏开发/README" data-v-49fe041d>游戏开发 <!----></a></div></div><div class="item" data-v-35b91e7e><div class="nav-link" data-v-35b91e7e data-v-49fe041d><a class="item" href="/读书笔记/README" data-v-49fe041d>读书笔记 <!----></a></div></div><div class="item" data-v-35b91e7e><div class="nav-link" data-v-35b91e7e data-v-49fe041d><a class="item isExternal" href="https://github.com/tangxiangmin/interview" target="_blank" rel="noopener noreferrer" data-v-49fe041d>github <svg class="icon outbound" xmlns="http://www.w3.org/2000/svg" aria-hidden="true" x="0px" y="0px" viewbox="0 0 100 100" width="15" height="15" data-v-49fe041d><path fill="currentColor" d="M18.8,85.1h56l0,0c2.2,0,4-1.8,4-4v-32h-8v28h-48v-48h28v-8h-32l0,0c-2.2,0-4,1.8-4,4v56C14.8,83.3,16.6,85.1,18.8,85.1z"></path><polygon fill="currentColor" points="45.7,48.7 51.3,54.3 77.2,28.5 77.2,37.2 85.2,37.2 85.2,14.9 62.8,14.9 62.8,22.9 71.5,22.9"></polygon></svg></a></div></div><div class="item" data-v-35b91e7e><div class="nav-link" data-v-35b91e7e data-v-49fe041d><a class="item isExternal" href="https://shymean.com" target="_blank" rel="noopener noreferrer" data-v-49fe041d>shymean <svg class="icon outbound" xmlns="http://www.w3.org/2000/svg" aria-hidden="true" x="0px" y="0px" viewbox="0 0 100 100" width="15" height="15" data-v-49fe041d><path fill="currentColor" d="M18.8,85.1h56l0,0c2.2,0,4-1.8,4-4v-32h-8v28h-48v-48h28v-8h-32l0,0c-2.2,0-4,1.8-4,4v56C14.8,83.3,16.6,85.1,18.8,85.1z"></path><polygon fill="currentColor" points="45.7,48.7 51.3,54.3 77.2,28.5 77.2,37.2 85.2,37.2 85.2,14.9 62.8,14.9 62.8,22.9 71.5,22.9"></polygon></svg></a></div></div><!--]--><!----><!----></nav><!--[--><!--]--><ul class="sidebar-links" data-v-17c48e2f><!--[--><li class="sidebar-link"><a class="sidebar-link-item" href="/前端/库与框架/Chrome扩展程序">Chrome扩展程序</a><!----></li><li class="sidebar-link"><a class="sidebar-link-item" href="/前端/库与框架/Electron">Electron</a><!----></li><li class="sidebar-link"><a class="sidebar-link-item" href="/前端/库与框架/Immutable">Immutable</a><!----></li><li class="sidebar-link"><a class="sidebar-link-item" href="/前端/库与框架/React">React</a><!----></li><li class="sidebar-link"><a class="sidebar-link-item" href="/前端/库与框架/RxJS">RxJS</a><!----></li><li class="sidebar-link"><a class="sidebar-link-item" href="/前端/库与框架/Svelet">Svelet</a><!----></li><li class="sidebar-link"><a class="sidebar-link-item" href="/前端/库与框架/Vue">Vue</a><!----></li><li class="sidebar-link"><a class="sidebar-link-item" href="/前端/库与框架/Vuex">Vuex</a><!----></li><li class="sidebar-link"><a class="sidebar-link-item active" href="/前端/库与框架/diff算法">diff算法</a><ul class="sidebar-links"><li class="sidebar-link"><a class="sidebar-link-item" href="#diff算法概述">diff算法概述</a><!----></li><li class="sidebar-link"><a class="sidebar-link-item" href="#递归实现diff">递归实现diff</a><ul class="sidebar-links"><li class="sidebar-link"><a class="sidebar-link-item" href="#vue-diff">Vue diff</a><!----></li><li class="sidebar-link"><a class="sidebar-link-item" href="#简单实现">简单实现</a><!----></li></ul></li><li class="sidebar-link"><a class="sidebar-link-item" href="#循环实现diff">循环实现diff</a><ul class="sidebar-links"><li class="sidebar-link"><a class="sidebar-link-item" href="#react-fiber-reconciler">React Fiber Reconciler</a><!----></li><li class="sidebar-link"><a class="sidebar-link-item" href="#简单实现-1">简单实现</a><!----></li></ul></li><li class="sidebar-link"><a class="sidebar-link-item" href="#key在diff中的作用">key在diff中的作用</a><ul class="sidebar-links"><li class="sidebar-link"><a class="sidebar-link-item" href="#无key与有key的区别">无key与有key的区别</a><!----></li><li class="sidebar-link"><a class="sidebar-link-item" href="#实现key">实现key</a><!----></li></ul></li><li class="sidebar-link"><a class="sidebar-link-item" href="#小结">小结</a><!----></li></ul></li><li class="sidebar-link"><a class="sidebar-link-item" href="/前端/库与框架/几种框架的对比">几种框架的对比</a><!----></li><li class="sidebar-link"><a class="sidebar-link-item" href="/前端/库与框架/单页面应用Router">单页面应用Router</a><!----></li><li class="sidebar-link"><a class="sidebar-link-item" href="/前端/库与框架/微信小程序">微信小程序</a><!----></li><li class="sidebar-link"><a class="sidebar-link-item" href="/前端/库与框架/技术选型">技术选型</a><!----></li><!--]--></ul><!--[--><!--]--></aside><div class="sidebar-mask"></div><main class="page" data-v-8fcebc32><div class="container" data-v-8fcebc32><!--[--><!--]--><div style="position:relative;" class="content" data-v-8fcebc32><div><h1 id="理解diff算法" tabindex="-1">理解diff算法 <a class="header-anchor" href="#理解diff算法" aria-hidden="true">#</a></h1><p>本文将从React和Vue源码中，理解diff算法的工作原理和实现方式。</p><p>参考:</p><ul><li><a href="https://juejin.im/post/5c8e5e4951882545c109ae9c" target="_blank" rel="noopener noreferrer">让虚拟DOM和DOM-diff不再成为你的绊脚石</a></li><li><a href="https://segmentfault.com/a/1190000017039293" target="_blank" rel="noopener noreferrer">React 源码深度解读（十）：Diff 算法详解</a></li><li><a href="https://zhuanlan.zhihu.com/p/20346379" target="_blank" rel="noopener noreferrer">React 源码剖析系列 － 不可思议的 react diff</a></li><li><a href="https://blog.csdn.net/baiyu753159/article/details/71545762" target="_blank" rel="noopener noreferrer">彻底理解React如何重新处理DOM(Diffing算法)</a></li></ul><h2 id="diff算法概述" tabindex="-1">diff算法概述 <a class="header-anchor" href="#diff算法概述" aria-hidden="true">#</a></h2><p>开门见山，定义diff算法：</p><blockquote><p>在初始化或更新时，组件树从旧状态更新为新状态，使用<strong>先序遍历</strong>，找到将旧树转换为新树所需的最少的转换步骤</p></blockquote><p>diff的任务就是收集新组件树中每个节点的变动，在diff完成后将整个改动更新到页面真实DOM上。为了性能考虑，实现的diff算法需要满足下面条件</p><ul><li>尽量复用DOM节点，减少创建或删除DOM的次数</li><li>时间复杂度要低，diff操作要足够快</li></ul><p>将新组件树和旧组件树上同一个位置的节点进行对比，可能存在以下几种情况</p><ul><li>旧节点存在，新节点为null，表示旧节点被移除</li><li>新节点存在，旧节点为null，表示新节点为新插入</li><li>新旧节点都存在 <ul><li>类型不同，表示旧节点被移除，同时将新节点插入该位置占位</li><li>类型相同，表示新节点<strong>可复用</strong>旧节点的实例，检测新旧节点属性是否变化 <ul><li>属性未变化，新旧节点完全相同，无需改动</li><li>属性变化，需使用新节点相关属性替换旧节点属性</li></ul></li></ul></li></ul><p>如果仅仅是满足diff算法条件一，考虑下面节点变化</p><p><img src="http://ww3.sinaimg.cn/large/006tNc79gy1g609096qeoj30es08lweh.jpg" alt=""></p><p>理想q情况下最优的处理方式是：将A移动到D节点下方，完全复用节点。但是这样处理会导致时间复杂度陡升，因为我们在遍历新组件树，遇见D节点时</p><ul><li>首先需要知道其子树A是一个新插入的子树</li><li>然后需要遍历旧组件树，找到一颗与A相同的子树，且其状态为删除，</li><li>最后我们将旧组件树的A子树移动到新组件的的D节点下，继续比那里其余节点并进行diff操作</li></ul><p>整个算法实现的时间复杂度非常高<code>O(n^3)</code> ，无法满足第二个条件。因此React在DOM性能和算法效率之间进行了取舍，使用下述策略进行新旧组件树的diff操作</p><p>React 通过制定大胆的策略，将 O(n^3) 复杂度的问题转换成 O(n) 复杂度的问题。</p><ul><li>Web UI 中 DOM 节点跨层级的移动操作特别少，可以忽略不计。 <ul><li>当跨级移动时，对应的处理时删除之前的节点，然后在移动位置新建节点</li><li>在上述提到的问题中，React首先会删除掉A节点，然后在D节点下重新创建A节点及其子节点，重新插入，因此建议不要做这种跨级的移动操作，对DOM性能消耗是比较明显的。</li></ul></li><li>拥有相同类的两个组件将会生成相似的树形结构，拥有不同类的两个组件将会生成不同的树形结构。 <ul><li>如果是同一类型的组件，按照原策略继续比较 <code>virtual DOM tree</code></li><li>如果不是，则将该组件判断为 dirty component，从而直接替换整个组件下的所有子节点。</li></ul></li><li>对于同一层级的一组子节点， <ul><li>对于相同位置（索引值）的节点，会产生上面提到的几种情况：删除、插入、替换、更新</li><li>可以根据唯一id快速找到旧节点中的某个节点，此时只需要移动节点即可，无需重新创建后面的节点</li></ul></li></ul><p>通过上述策略 ，整个diff操作的复杂度从 <code>O(n^3)</code>转换成了<code>O(n) </code>。此外React还提供了<code>shouldComponentUpdate</code>、<code>PureComponent</code>等方案减少diff操作，进一步节省性能。了解了diff算法的基本任务和策略之后，我们来尝试实现diff算法。</p><h2 id="递归实现diff" tabindex="-1">递归实现diff <a class="header-anchor" href="#递归实现diff" aria-hidden="true">#</a></h2><p>遍历树最常用的操作就是递归，这Vue和React16前版本使用的<code>Statck Reconciler</code>所采用的方案。</p><h3 id="vue-diff" tabindex="-1">Vue diff <a class="header-anchor" href="#vue-diff" aria-hidden="true">#</a></h3><p>Preact与vue实现基本相同</p><p>参考：<a href="https://github.com/aooy/blog/issues/2" target="_blank" rel="noopener noreferrer">解析vue2.0的diff算法</a></p><h3 id="简单实现" tabindex="-1">简单实现 <a class="header-anchor" href="#简单实现" aria-hidden="true">#</a></h3><p>具体思路为，从组件树根节点开始，对比新旧组件树的两个节点，然后收集更新，递归对比子节点列表中的每一个节点，直至遍历完成</p><div class="language-js"><pre><code><span class="token comment">// 定义节点可能发生的变化</span>
<span class="token keyword">const</span> <span class="token punctuation">[</span><span class="token constant">REMOVE</span><span class="token punctuation">,</span> <span class="token constant">REPLACE</span><span class="token punctuation">,</span> <span class="token constant">INSERT</span><span class="token punctuation">,</span> <span class="token constant">UPDATE</span><span class="token punctuation">]</span> <span class="token operator">=</span> <span class="token punctuation">[</span><span class="token number">0</span><span class="token punctuation">,</span> <span class="token number">1</span><span class="token punctuation">,</span> <span class="token number">2</span><span class="token punctuation">,</span> <span class="token number">3</span><span class="token punctuation">]</span><span class="token punctuation">;</span>

<span class="token keyword">function</span> <span class="token function">diff</span><span class="token punctuation">(</span><span class="token parameter">oldNode<span class="token punctuation">,</span> newNode</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>
    <span class="token keyword">let</span> patch<span class="token punctuation">;</span>
    <span class="token keyword">if</span> <span class="token punctuation">(</span><span class="token operator">!</span>newNode<span class="token punctuation">)</span> <span class="token punctuation">{</span>
        <span class="token comment">// 旧节点及其子节点都将移除</span>
        patch <span class="token operator">=</span> <span class="token punctuation">{</span> <span class="token literal-property property">type</span><span class="token operator">:</span> <span class="token constant">REMOVE</span><span class="token punctuation">,</span> oldNode <span class="token punctuation">}</span><span class="token punctuation">;</span>
    <span class="token punctuation">}</span> <span class="token keyword">else</span> <span class="token keyword">if</span> <span class="token punctuation">(</span><span class="token operator">!</span>oldNode<span class="token punctuation">)</span> <span class="token punctuation">{</span>
        <span class="token comment">// 当前节点与其子节点都将插入</span>
        patch <span class="token operator">=</span> <span class="token punctuation">{</span> <span class="token literal-property property">type</span><span class="token operator">:</span> <span class="token constant">INSERT</span><span class="token punctuation">,</span> newNode <span class="token punctuation">}</span><span class="token punctuation">;</span>
        <span class="token comment">// 将所有子节点也标记为INSERT，这一步可以进行优化，</span>
      	<span class="token comment">// 即当父节点为INSERT时，所有子节点均自动标记为INSERT，此处为了便于理解，暂不处理</span>
        <span class="token function">diffChildren</span><span class="token punctuation">(</span><span class="token keyword">null</span><span class="token punctuation">,</span> newNode<span class="token punctuation">.</span>children<span class="token punctuation">)</span><span class="token punctuation">;</span>
    <span class="token punctuation">}</span> <span class="token keyword">else</span> <span class="token keyword">if</span> <span class="token punctuation">(</span>oldNode<span class="token punctuation">.</span>type <span class="token operator">!==</span> newNode<span class="token punctuation">.</span>type<span class="token punctuation">)</span> <span class="token punctuation">{</span>
        <span class="token comment">// 使用新节点替换旧节点</span>
        patch <span class="token operator">=</span> <span class="token punctuation">{</span> <span class="token literal-property property">type</span><span class="token operator">:</span> <span class="token constant">REPLACE</span><span class="token punctuation">,</span> oldNode<span class="token punctuation">,</span> newNode <span class="token punctuation">}</span><span class="token punctuation">;</span>
    <span class="token punctuation">}</span> <span class="token keyword">else</span> <span class="token punctuation">{</span>
        <span class="token comment">// 检测如果存在有变化的属性，则需要将新节点的属性更新到旧节点</span>
        <span class="token keyword">if</span> <span class="token punctuation">(</span><span class="token function">diffAttr</span><span class="token punctuation">(</span>oldNode<span class="token punctuation">.</span>props<span class="token punctuation">,</span> newNode<span class="token punctuation">.</span>props<span class="token punctuation">)</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>
            patch <span class="token operator">=</span> <span class="token punctuation">{</span> <span class="token literal-property property">type</span><span class="token operator">:</span> <span class="token constant">UPDATE</span><span class="token punctuation">,</span> oldNode<span class="token punctuation">,</span> newNode <span class="token punctuation">}</span><span class="token punctuation">;</span>
        <span class="token punctuation">}</span>
        <span class="token comment">// 继续比较子节点</span>
        <span class="token function">diffChildren</span><span class="token punctuation">(</span>oldNode<span class="token punctuation">.</span>children<span class="token punctuation">,</span> newNode<span class="token punctuation">.</span>children<span class="token punctuation">)</span><span class="token punctuation">;</span>
    <span class="token punctuation">}</span>
    <span class="token comment">// 将更新保存在节点的patches属性上，旧节点的删除需要保存在新旧节点公共父节点上</span>
    <span class="token keyword">let</span> node <span class="token operator">=</span> newNode <span class="token operator">||</span> oldNode<span class="token punctuation">.</span>parent<span class="token punctuation">;</span>
    <span class="token keyword">if</span> <span class="token punctuation">(</span><span class="token operator">!</span>node<span class="token punctuation">.</span>patches<span class="token punctuation">)</span> <span class="token punctuation">{</span>
        node<span class="token punctuation">.</span>patches <span class="token operator">=</span> <span class="token punctuation">[</span><span class="token punctuation">]</span><span class="token punctuation">;</span>
    <span class="token punctuation">}</span>
    patch <span class="token operator">&amp;&amp;</span> node<span class="token punctuation">.</span>patches<span class="token punctuation">.</span><span class="token function">push</span><span class="token punctuation">(</span>patch<span class="token punctuation">)</span><span class="token punctuation">;</span>
<span class="token punctuation">}</span>

<span class="token keyword">function</span> <span class="token function">diffChildren</span><span class="token punctuation">(</span><span class="token parameter">oldChildren<span class="token punctuation">,</span> newChildren</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>
    <span class="token keyword">let</span> count<span class="token punctuation">;</span>
    <span class="token comment">// 依次比较旧的子节点列表和新的子节点列表</span>
    <span class="token keyword">if</span> <span class="token punctuation">(</span>oldChildren <span class="token operator">&amp;&amp;</span> oldChildren<span class="token punctuation">.</span>length<span class="token punctuation">)</span> <span class="token punctuation">{</span>
        oldChildren<span class="token punctuation">.</span><span class="token function">forEach</span><span class="token punctuation">(</span><span class="token punctuation">(</span><span class="token parameter">child<span class="token punctuation">,</span> index</span><span class="token punctuation">)</span> <span class="token operator">=&gt;</span> <span class="token punctuation">{</span>
            count<span class="token operator">++</span><span class="token punctuation">;</span>
            <span class="token function">diff</span><span class="token punctuation">(</span>child<span class="token punctuation">,</span> <span class="token punctuation">(</span>newChildren <span class="token operator">&amp;&amp;</span> newChildren<span class="token punctuation">[</span>index<span class="token punctuation">]</span><span class="token punctuation">)</span> <span class="token operator">||</span> <span class="token keyword">null</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
        <span class="token punctuation">}</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
    <span class="token punctuation">}</span>
    <span class="token comment">// 如果还有未比较的新节点，继续进行diff将其标记为INSERT</span>
    <span class="token keyword">if</span> <span class="token punctuation">(</span>newChildren <span class="token operator">&amp;&amp;</span> newChildren<span class="token punctuation">.</span>length<span class="token punctuation">)</span> <span class="token punctuation">{</span>
        <span class="token keyword">for</span> <span class="token punctuation">(</span><span class="token punctuation">;</span> count <span class="token operator">&lt;</span> newChildren<span class="token punctuation">;</span> count<span class="token operator">++</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>
            <span class="token function">diff</span><span class="token punctuation">(</span><span class="token keyword">null</span><span class="token punctuation">,</span> newChildren<span class="token punctuation">[</span>index<span class="token punctuation">]</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
        <span class="token punctuation">}</span>
    <span class="token punctuation">}</span>
<span class="token punctuation">}</span>
</code></pre></div><p>这样，就可以完成新旧组件树的diff操作，并将需要处理的更新挂载到<code>node.patches</code>属性上，在后续的patch阶段，会根据diff时收集的<code>type</code>做对应的处理。</p><p>为了进一步理解diff的作用，下面实现了一个简单的<code>patch</code>方法，用于查看diff过程中收集到的变化是如何更新到页面上的。</p><div class="language-js"><pre><code><span class="token keyword">function</span> <span class="token function">patch</span><span class="token punctuation">(</span><span class="token parameter">node</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>
    <span class="token keyword">if</span> <span class="token punctuation">(</span><span class="token operator">!</span>node<span class="token punctuation">)</span> <span class="token keyword">return</span><span class="token punctuation">;</span>
		<span class="token comment">// 从根节点开始执行patch操作</span>
    <span class="token function">doPatch</span><span class="token punctuation">(</span>node<span class="token punctuation">)</span><span class="token punctuation">;</span>

    node<span class="token punctuation">.</span>children<span class="token punctuation">.</span><span class="token function">forEach</span><span class="token punctuation">(</span><span class="token parameter">child</span> <span class="token operator">=&gt;</span> <span class="token punctuation">{</span>
        <span class="token function">patch</span><span class="token punctuation">(</span>child<span class="token punctuation">)</span><span class="token punctuation">;</span>
    <span class="token punctuation">}</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
<span class="token punctuation">}</span>
<span class="token keyword">function</span> <span class="token function">doPatch</span><span class="token punctuation">(</span><span class="token parameter">node</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>
    <span class="token keyword">let</span> patches <span class="token operator">=</span> node<span class="token punctuation">.</span>patches<span class="token punctuation">;</span>
    <span class="token keyword">if</span> <span class="token punctuation">(</span><span class="token operator">!</span>patches <span class="token operator">||</span> <span class="token operator">!</span>patches<span class="token punctuation">.</span>length<span class="token punctuation">)</span> <span class="token keyword">return</span><span class="token punctuation">;</span>

    <span class="token keyword">const</span> handlers <span class="token operator">=</span> <span class="token punctuation">{</span>
        <span class="token punctuation">[</span><span class="token constant">REMOVE</span><span class="token punctuation">]</span><span class="token operator">:</span> <span class="token keyword">function</span> <span class="token function">removeChild</span><span class="token punctuation">(</span><span class="token parameter">parent<span class="token punctuation">,</span> oldNode<span class="token punctuation">,</span> newNode</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>
            parent<span class="token punctuation">.</span>$el<span class="token punctuation">.</span><span class="token function">removeChild</span><span class="token punctuation">(</span>oldNode<span class="token punctuation">.</span>$el<span class="token punctuation">)</span><span class="token punctuation">;</span>
        <span class="token punctuation">}</span><span class="token punctuation">,</span>
        <span class="token punctuation">[</span><span class="token constant">REPLACE</span><span class="token punctuation">]</span><span class="token operator">:</span> <span class="token keyword">function</span> <span class="token function">replaceChild</span><span class="token punctuation">(</span><span class="token parameter">parent<span class="token punctuation">,</span> oldNode<span class="token punctuation">,</span> newNode</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>
            <span class="token keyword">let</span> parent <span class="token operator">=</span> oldNode<span class="token punctuation">.</span>parent<span class="token punctuation">.</span>$el<span class="token punctuation">;</span>
            <span class="token keyword">let</span> target <span class="token operator">=</span> oldNode<span class="token punctuation">.</span>$el<span class="token punctuation">;</span>

            newNode<span class="token punctuation">.</span>$el <span class="token operator">=</span> <span class="token function">createDOM</span><span class="token punctuation">(</span>node<span class="token punctuation">)</span><span class="token punctuation">;</span>

            parent<span class="token punctuation">.</span><span class="token function">insertBefore</span><span class="token punctuation">(</span>newNode<span class="token punctuation">.</span>$el<span class="token punctuation">,</span> target<span class="token punctuation">)</span><span class="token punctuation">;</span>
            parent<span class="token punctuation">.</span><span class="token function">removeChild</span><span class="token punctuation">(</span>target<span class="token punctuation">)</span><span class="token punctuation">;</span>
        <span class="token punctuation">}</span><span class="token punctuation">,</span>
        <span class="token punctuation">[</span><span class="token constant">UPDATE</span><span class="token punctuation">]</span><span class="token operator">:</span> <span class="token keyword">function</span> <span class="token function">updateNode</span><span class="token punctuation">(</span><span class="token parameter">parent<span class="token punctuation">,</span> oldNode<span class="token punctuation">,</span> newNode</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>
            <span class="token keyword">const</span> props <span class="token operator">=</span> newNode<span class="token punctuation">.</span>props<span class="token punctuation">;</span>
            <span class="token comment">// todo 这里应该只处理需要更新的属性</span>
            Object<span class="token punctuation">.</span><span class="token function">keys</span><span class="token punctuation">(</span>props<span class="token punctuation">)</span><span class="token punctuation">.</span><span class="token function">forEach</span><span class="token punctuation">(</span><span class="token parameter">key</span> <span class="token operator">=&gt;</span> <span class="token punctuation">{</span>
                newNode<span class="token punctuation">.</span>$el<span class="token punctuation">.</span><span class="token function">setAttribute</span><span class="token punctuation">(</span>key<span class="token punctuation">,</span> props<span class="token punctuation">[</span>key<span class="token punctuation">]</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
            <span class="token punctuation">}</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
        <span class="token punctuation">}</span><span class="token punctuation">,</span>
        <span class="token punctuation">[</span><span class="token constant">INSERT</span><span class="token punctuation">]</span><span class="token operator">:</span> <span class="token keyword">function</span> <span class="token function">insertNode</span><span class="token punctuation">(</span><span class="token parameter">parent<span class="token punctuation">,</span> oldNode<span class="token punctuation">,</span> newNode</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>
            newNode<span class="token punctuation">.</span>$el <span class="token operator">=</span> <span class="token function">createDOM</span><span class="token punctuation">(</span>newNode<span class="token punctuation">)</span><span class="token punctuation">;</span>

            newNode<span class="token punctuation">.</span>parent<span class="token punctuation">.</span>$el<span class="token punctuation">.</span><span class="token function">appendChild</span><span class="token punctuation">(</span>newNode<span class="token punctuation">.</span>$el<span class="token punctuation">)</span><span class="token punctuation">;</span>
        <span class="token punctuation">}</span>
    <span class="token punctuation">}</span><span class="token punctuation">;</span>
    patches<span class="token punctuation">.</span><span class="token function">forEach</span><span class="token punctuation">(</span><span class="token parameter">patch</span> <span class="token operator">=&gt;</span> <span class="token punctuation">{</span>
        <span class="token keyword">const</span> <span class="token punctuation">{</span>type<span class="token punctuation">,</span> oldNode<span class="token punctuation">,</span> newNode<span class="token punctuation">}</span> <span class="token operator">=</span> patch
        <span class="token keyword">let</span> handler <span class="token operator">=</span> handlers<span class="token punctuation">[</span>type<span class="token punctuation">]</span><span class="token punctuation">;</span>
        <span class="token comment">// 根节点的父节点其$el就是页面挂载容器</span>
        handler <span class="token operator">&amp;&amp;</span> <span class="token function">handler</span><span class="token punctuation">(</span>newNode<span class="token punctuation">.</span>parent<span class="token punctuation">,</span> oldNode<span class="token punctuation">,</span> newNode<span class="token punctuation">)</span><span class="token punctuation">;</span>
    <span class="token punctuation">}</span><span class="token punctuation">)</span><span class="token punctuation">;</span>

    <span class="token keyword">function</span> <span class="token function">createDOM</span><span class="token punctuation">(</span><span class="token parameter">node</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>
        <span class="token keyword">return</span> document<span class="token punctuation">.</span><span class="token function">createElement</span><span class="token punctuation">(</span>node<span class="token punctuation">.</span>type<span class="token punctuation">)</span><span class="token punctuation">;</span>
    <span class="token punctuation">}</span>
<span class="token punctuation">}</span>
</code></pre></div><p>通过<code>patch</code>方法的实现，我们可以进一步了解diff的作用：对比新旧节点，收集节点变化的类型是删除、插入、替换、更新中的某一种，然后调用DOM方法完成页面视图的更新。</p><p>上面的diff和patch中，并没有展示变化类型为<strong>移动</strong>的节点，我将其放在了后文的&quot;key在diff中的作用&quot;这一小节了。</p><h2 id="循环实现diff" tabindex="-1">循环实现diff <a class="header-anchor" href="#循环实现diff" aria-hidden="true">#</a></h2><h3 id="react-fiber-reconciler" tabindex="-1">React Fiber Reconciler <a class="header-anchor" href="#react-fiber-reconciler" aria-hidden="true">#</a></h3><p>递归实现diff的一个问题是：递归很难被临时中断，在某个时刻又恢复至原来调用的地方。因此，递归diff必然是同步进行的，如果组件树十分庞大，需要进行的diff操作太多，就会导致浏览器处于卡死的状态。</p><p>基于这个问题，React将整个diff过程重构为<code>Fiber Reconciler</code>，通过fiber将组件树从树的结构调整为链表结构，利用链表的循环和<code>workInProgress</code>游标实现异步的diff操作。</p><h3 id="简单实现-1" tabindex="-1">简单实现 <a class="header-anchor" href="#简单实现-1" aria-hidden="true">#</a></h3><p><code>Fiber Reconciler</code>引入了<code>Fiber</code>数据结构，用于将整个应用从树结构修改为链表结构，对于单个fiber节点而言，有下面几个比较重要的属性</p><ul><li><code>return</code>父节点</li><li><code>child</code>第一个子节点</li><li><code>sibling</code>下一个兄弟节点</li></ul><p>根据上面这三个属性，就可以从根节点通过循环的方式完成整个组件树的遍历。下面的代码大致展示了如何通过循环链表实现diff算法</p><div class="language-js"><pre><code><span class="token keyword">let</span> workInProgress<span class="token punctuation">,</span> currentWorkRoot
<span class="token keyword">function</span> <span class="token function">scheduleWork</span><span class="token punctuation">(</span><span class="token parameter">fiberRoot</span><span class="token punctuation">)</span><span class="token punctuation">{</span>
    workInProgress <span class="token operator">=</span> fiberRoot<span class="token punctuation">;</span>
    currentWorkRoot <span class="token operator">=</span> fiberRoot<span class="token punctuation">;</span>

    <span class="token comment">// 浏览器在空闲期间会持续调用workLoop，从workInProgress开始继续diff</span>
    <span class="token function">requestHostCallback</span><span class="token punctuation">(</span>workLoop<span class="token punctuation">)</span><span class="token punctuation">;</span>
<span class="token punctuation">}</span>

<span class="token keyword">function</span> <span class="token function">workLoop</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">{</span>
    <span class="token keyword">while</span> <span class="token punctuation">(</span>workInProgress<span class="token punctuation">)</span> <span class="token punctuation">{</span>
        <span class="token comment">// 判断当前帧是否完成，每完成一个节点的diff，就将控制权交给浏览器，检测</span>
        <span class="token keyword">if</span> <span class="token punctuation">(</span><span class="token function">shouldYield</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>
             <span class="token comment">// 当前时间切片已用光，但diff流程未结束，浏览器会在合适的实际继续调用workInProgress</span>
            <span class="token keyword">return</span> <span class="token boolean">true</span><span class="token punctuation">;</span>
        <span class="token punctuation">}</span> <span class="token keyword">else</span> <span class="token punctuation">{</span>
            <span class="token comment">// 可以继续进行下一个节点的diff</span>
            workInProgress <span class="token operator">=</span> <span class="token function">performUnitWork</span><span class="token punctuation">(</span>workInProgress<span class="token punctuation">)</span><span class="token punctuation">;</span>
        <span class="token punctuation">}</span>
    <span class="token punctuation">}</span>
<span class="token punctuation">}</span>

<span class="token keyword">function</span> <span class="token function">performUnitWork</span><span class="token punctuation">(</span><span class="token parameter">fiber</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>
    <span class="token keyword">let</span> newChildren <span class="token operator">=</span> <span class="token function">getFiberNewChildren</span><span class="token punctuation">(</span>fiber<span class="token punctuation">)</span><span class="token punctuation">;</span>   <span class="token comment">// 获得更新后的newChildren</span>
    <span class="token function">diff</span><span class="token punctuation">(</span>fiber<span class="token punctuation">,</span> newChildren<span class="token punctuation">,</span> oldChildren<span class="token punctuation">)</span><span class="token punctuation">;</span>  <span class="token comment">// 如果存在子节点，则更新workInProgress</span>
   
  	<span class="token comment">// 返回workLoop，继续遍历</span>
    <span class="token keyword">if</span><span class="token punctuation">(</span>fiber<span class="token punctuation">.</span>child<span class="token punctuation">)</span><span class="token punctuation">{</span>
        <span class="token keyword">return</span> fiber<span class="token punctuation">.</span>child
    <span class="token punctuation">}</span>
    <span class="token keyword">while</span> <span class="token punctuation">(</span>fiber<span class="token punctuation">)</span> <span class="token punctuation">{</span>
        <span class="token comment">// 然后遍历兄弟节点，完成兄弟节点的diff操作</span>
        <span class="token keyword">if</span> <span class="token punctuation">(</span>fiber<span class="token punctuation">.</span>sibling<span class="token punctuation">)</span> <span class="token punctuation">{</span>
            <span class="token keyword">return</span> fiber<span class="token punctuation">.</span>sibling<span class="token punctuation">;</span>
        <span class="token punctuation">}</span>
        <span class="token comment">// 回到父节点</span>
        fiber <span class="token operator">=</span> fiber<span class="token punctuation">.</span>return<span class="token punctuation">;</span>
        <span class="token keyword">if</span> <span class="token punctuation">(</span>currentWorkRoot <span class="token operator">===</span> fiber<span class="token punctuation">)</span> <span class="token punctuation">{</span>
            <span class="token keyword">return</span> <span class="token keyword">null</span><span class="token punctuation">;</span>
        <span class="token punctuation">}</span>
    <span class="token punctuation">}</span>
<span class="token punctuation">}</span>
<span class="token comment">// 找到旧节点</span>
<span class="token keyword">function</span> <span class="token function">getFiberChildren</span><span class="token punctuation">(</span><span class="token parameter">fiber</span><span class="token punctuation">)</span><span class="token punctuation">{</span>
    <span class="token keyword">let</span> child <span class="token operator">=</span> fiber<span class="token punctuation">.</span>child
    <span class="token keyword">let</span> children <span class="token operator">=</span> <span class="token punctuation">[</span><span class="token punctuation">]</span>
    <span class="token keyword">while</span> <span class="token punctuation">(</span>child<span class="token punctuation">)</span> <span class="token punctuation">{</span>
        children<span class="token punctuation">.</span><span class="token function">push</span><span class="token punctuation">(</span>child<span class="token punctuation">)</span>
        child <span class="token operator">=</span> child<span class="token punctuation">.</span>sibling
    <span class="token punctuation">}</span>
    <span class="token keyword">return</span> children
<span class="token punctuation">}</span>
<span class="token keyword">function</span> <span class="token function">diff</span><span class="token punctuation">(</span><span class="token parameter">parentFiber<span class="token punctuation">,</span> newChildren</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>
    <span class="token keyword">let</span> prevFiber <span class="token operator">=</span> <span class="token keyword">null</span><span class="token punctuation">;</span>
	  <span class="token keyword">let</span> oldChildren <span class="token operator">=</span> <span class="token function">getFiberChildren</span><span class="token punctuation">(</span>fiber<span class="token punctuation">)</span><span class="token punctuation">;</span> <span class="token comment">// 获取旧的子节点列表</span>
    <span class="token keyword">let</span> i<span class="token punctuation">;</span>
    <span class="token comment">// 新节点与旧节点对比</span>
    <span class="token keyword">for</span> <span class="token punctuation">(</span>i <span class="token operator">=</span> <span class="token number">0</span><span class="token punctuation">;</span> i <span class="token operator">&lt;</span> newChildren<span class="token punctuation">.</span>length<span class="token punctuation">;</span> <span class="token operator">++</span>i<span class="token punctuation">)</span> <span class="token punctuation">{</span>
        <span class="token keyword">let</span> newNode <span class="token operator">=</span> newChildren<span class="token punctuation">[</span>i<span class="token punctuation">]</span><span class="token punctuation">;</span>
        <span class="token keyword">let</span> oldFiber <span class="token operator">=</span> oldChildren<span class="token punctuation">[</span>i<span class="token punctuation">]</span><span class="token punctuation">;</span>
        <span class="token keyword">let</span> newFiber<span class="token punctuation">;</span>
      	<span class="token comment">// 此处与前面递归实现的比较逻辑基本相同</span>
        <span class="token keyword">if</span> <span class="token punctuation">(</span>oldFiber<span class="token punctuation">)</span> <span class="token punctuation">{</span>
            <span class="token comment">// 类型相同，表示节点实例可复用</span>
            <span class="token keyword">if</span> <span class="token punctuation">(</span><span class="token function">isSameVnode</span><span class="token punctuation">(</span>newNode<span class="token punctuation">,</span> oldFiber<span class="token punctuation">)</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>
                <span class="token keyword">if</span><span class="token punctuation">(</span><span class="token function">diffAttr</span><span class="token punctuation">(</span>newNode<span class="token punctuation">,</span> oldFiber<span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">{</span>
                    <span class="token comment">// 属性不同，标记为更新</span>
                    newFiber <span class="token operator">=</span> <span class="token function">createFiber</span><span class="token punctuation">(</span>newNode<span class="token punctuation">,</span> <span class="token constant">UPDATE</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
                    newFiber<span class="token punctuation">.</span>alternate <span class="token operator">=</span> oldFiber<span class="token punctuation">;</span>
                <span class="token punctuation">}</span><span class="token keyword">else</span> <span class="token punctuation">{</span>
                    <span class="token comment">// 属性相同，可以完全复用</span>
                    newFiber <span class="token operator">=</span> oldFiber
                <span class="token punctuation">}</span>
            <span class="token punctuation">}</span> <span class="token keyword">else</span> <span class="token punctuation">{</span>
                <span class="token comment">// 类型不同，标记为替换</span>
                newFiber <span class="token operator">=</span> <span class="token function">createFiber</span><span class="token punctuation">(</span>newNode<span class="token punctuation">,</span> <span class="token constant">REPLACE</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
            <span class="token punctuation">}</span>
            newFiber<span class="token punctuation">.</span>alternate <span class="token operator">=</span> oldFiber<span class="token punctuation">;</span>
        <span class="token punctuation">}</span> <span class="token keyword">else</span> <span class="token punctuation">{</span>
            <span class="token comment">// 当前位置不存在旧节点，表示新增</span>
            newFiber <span class="token operator">=</span> <span class="token function">createFiber</span><span class="token punctuation">(</span>newNode<span class="token punctuation">,</span> <span class="token constant">INSERT</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
        <span class="token punctuation">}</span>

        <span class="token comment">// 调整fiber之间的引用，构建新的fiber树</span>
        newFiber<span class="token punctuation">.</span>return <span class="token operator">=</span> parentFiber<span class="token punctuation">;</span>
        <span class="token keyword">if</span> <span class="token punctuation">(</span>prevFiber<span class="token punctuation">)</span> <span class="token punctuation">{</span>
            prevFiber<span class="token punctuation">.</span>sibling <span class="token operator">=</span> newFiber<span class="token punctuation">;</span>
        <span class="token punctuation">}</span> <span class="token keyword">else</span> <span class="token punctuation">{</span>
            <span class="token comment">// 更新父元素的子节点</span>
            parentFiber<span class="token punctuation">.</span>child <span class="token operator">=</span> newFiber<span class="token punctuation">;</span>
        <span class="token punctuation">}</span>
        prevFiber <span class="token operator">=</span> newFiber<span class="token punctuation">;</span>
    <span class="token punctuation">}</span>

    <span class="token comment">// 移除剩余未被比较的旧节点</span>
    <span class="token keyword">for</span> <span class="token punctuation">(</span><span class="token punctuation">;</span> i <span class="token operator">&lt;</span> oldChildren<span class="token punctuation">.</span>length<span class="token punctuation">;</span> <span class="token operator">++</span>i<span class="token punctuation">)</span> <span class="token punctuation">{</span>
        <span class="token keyword">let</span> oldFiber <span class="token operator">=</span> oldChildren<span class="token punctuation">[</span>i<span class="token punctuation">]</span><span class="token punctuation">;</span>
        oldFiber<span class="token punctuation">.</span>patchTag <span class="token operator">=</span> <span class="token constant">REMOVE</span><span class="token punctuation">;</span>
        <span class="token function">enqueueUpdate</span><span class="token punctuation">(</span>parentFiber<span class="token punctuation">,</span> oldFiber<span class="token punctuation">)</span><span class="token punctuation">;</span> <span class="token comment">// 由于被删除的节点不存在fiber树中，因此交给父节点托管</span>
    <span class="token punctuation">}</span>
<span class="token punctuation">}</span>
</code></pre></div><p>同样地，这里将节点的变化收集在<code>patchTag</code>上，在diff流程结束以后，会统一提交变化，完成视图的更新。</p><h2 id="key在diff中的作用" tabindex="-1">key在diff中的作用 <a class="header-anchor" href="#key在diff中的作用" aria-hidden="true">#</a></h2><blockquote><p>在渲染列表节点中， 通过key可以在后续diff时移动节点，而不是更新节点，</p></blockquote><p>参考</p><ul><li><a href="https://juejin.im/post/5aae19aa6fb9a028d4445d1a" target="_blank" rel="noopener noreferrer">为什么使用v-for时必须添加唯一的key?</a></li><li><a href="https://github.com/Advanced-Frontend/Daily-Interview-Question/issues/1" target="_blank" rel="noopener noreferrer">写 React / Vue 项目时为什么要在列表组件中写 key，其作用是什么</a></li></ul><h3 id="无key与有key的区别" tabindex="-1">无key与有key的区别 <a class="header-anchor" href="#无key与有key的区别" aria-hidden="true">#</a></h3><p>当旧组件的渲染列表为<code>[1,2,3]</code>时，考虑以下场景</p><p>列表元素顺序发生变化，更新后列表为<code>[2,1,3]</code></p><ul><li>不带key,新旧节点对比 2-&gt;1 , 1-&gt;2 ，3-&gt;3，需要更新两个节点，不需要调换位置</li><li>带key，key值为item，新旧节点对比,1-&gt;1，2-&gt;2，3-&gt;3 不需要更新DOM节点，需要调换位置1和2节点的位置</li></ul><p>列表进行增加操作，更新后列表为<code>[1,4,2,3]</code></p><ul><li>不带key，1-&gt;1,2-&gt;4,3-&gt;2，null-&gt;3，第二、三个节点需要更新，第四个节点需要插入</li><li>带key，1-&gt;1，2-&gt;2，3-&gt;3,null-&gt;4，只需要将节点插入到第二个节点的前方</li></ul><p>列表进行删除操作，更新后列表为<code>[1,3]</code></p><ul><li>不带key，1-&gt;1,2-&gt;3,3-&gt;null，需要更新第二个节点，同时将第三个节点删除</li><li>带key，1-&gt;1,2-&gt;null,3-&gt;3，需要将第二个节点移除</li></ul><p>因此在渲染列表时，利用key可以diff过程中快速找到同key的旧节点，尽可能地复用之前的DOM节点，而不是”就地复用“去更新旧节点的内容。</p><p>需要注意的是，使用key并不一定能带来DOM性能上的优化，比如列表渲染简单的文本节点，直接更新文本节点的内容，比交换DOM位置的性能应该更优。</p><p>综上理解，key的作用在于：<strong>在数据变化时强制更新组件，避免就地复用带来的副作用</strong>。</p><h3 id="实现key" tabindex="-1">实现key <a class="header-anchor" href="#实现key" aria-hidden="true">#</a></h3><p>在前面未带key的diff实现里面，按照数组索引值查找旧节点，然后进行对比；再添加了key之后，则应该按照key查找旧节点，然后进行对比。因此我们需要修改<code>getFiberChildren</code>方法的实现</p><div class="language-js"><pre><code><span class="token comment">// 找到之前的旧节点，以 key=&gt;fiber 形式返回</span>
<span class="token keyword">export</span> <span class="token keyword">function</span> <span class="token function">getExistingChildren</span><span class="token punctuation">(</span><span class="token parameter">fiber</span><span class="token punctuation">)</span><span class="token operator">:</span> Map<span class="token operator">&lt;</span>string <span class="token operator">|</span> number<span class="token punctuation">,</span> Fiber<span class="token operator">&gt;</span> <span class="token punctuation">{</span>
    <span class="token keyword">const</span> <span class="token literal-property property">existingChildren</span><span class="token operator">:</span> Map<span class="token operator">&lt;</span>string <span class="token operator">|</span> number<span class="token punctuation">,</span> Fiber<span class="token operator">&gt;</span> <span class="token operator">=</span> <span class="token keyword">new</span> <span class="token class-name">Map</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
    <span class="token keyword">let</span> <span class="token literal-property property">child</span><span class="token operator">:</span> Fiber <span class="token operator">=</span> fiber<span class="token punctuation">.</span>child
    <span class="token keyword">let</span> <span class="token literal-property property">count</span><span class="token operator">:</span> number <span class="token operator">=</span> <span class="token number">0</span>
    <span class="token keyword">while</span> <span class="token punctuation">(</span>child<span class="token punctuation">)</span> <span class="token punctuation">{</span>
        <span class="token keyword">let</span> vnode <span class="token operator">=</span> child<span class="token punctuation">.</span>vnode
        <span class="token keyword">let</span> key <span class="token operator">=</span> vnode<span class="token punctuation">.</span>key <span class="token operator">===</span> <span class="token keyword">undefined</span> <span class="token operator">?</span> count <span class="token operator">:</span> vnode<span class="token punctuation">.</span>key
        <span class="token keyword">if</span> <span class="token punctuation">(</span><span class="token operator">!</span>existingChildren<span class="token punctuation">.</span><span class="token function">has</span><span class="token punctuation">(</span>key<span class="token punctuation">)</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>
            existingChildren<span class="token punctuation">.</span><span class="token function">set</span><span class="token punctuation">(</span>key<span class="token punctuation">,</span> child<span class="token punctuation">)</span>
        <span class="token punctuation">}</span> <span class="token keyword">else</span> <span class="token punctuation">{</span>
            console<span class="token punctuation">.</span><span class="token function">error</span><span class="token punctuation">(</span><span class="token template-string"><span class="token template-punctuation string">`</span><span class="token string">列表节点中key必须是唯一的</span><span class="token template-punctuation string">`</span></span><span class="token punctuation">)</span>
        <span class="token punctuation">}</span>
        child <span class="token operator">=</span> child<span class="token punctuation">.</span>sibling
        count<span class="token operator">++</span>
    <span class="token punctuation">}</span>
    <span class="token keyword">return</span> existingChildren
<span class="token punctuation">}</span>
<span class="token comment">// 比较新旧fiber的子节点，并将可用的fiber节点转换为fiber</span>
<span class="token keyword">export</span> <span class="token keyword">function</span> <span class="token function">diff</span><span class="token punctuation">(</span><span class="token parameter"><span class="token literal-property property">parentFiber</span><span class="token operator">:</span> Fiber<span class="token punctuation">,</span> <span class="token literal-property property">newChildren</span><span class="token operator">:</span> Array<span class="token operator">&lt;</span>VNode<span class="token operator">&gt;</span></span><span class="token punctuation">)</span> <span class="token punctuation">{</span>
    <span class="token keyword">let</span> prevFiber <span class="token operator">=</span> <span class="token keyword">null</span>
    <span class="token keyword">let</span> i <span class="token operator">=</span> <span class="token number">0</span>
    <span class="token keyword">let</span> current <span class="token operator">=</span> parentFiber<span class="token punctuation">.</span>alternate
    <span class="token comment">// 由key属性组成的节点映射，通过移动直接复用</span>
    <span class="token keyword">const</span> existingChildren <span class="token operator">=</span> <span class="token function">getExistingChildren</span><span class="token punctuation">(</span>current<span class="token punctuation">)</span>
    <span class="token keyword">let</span> insertCount <span class="token operator">=</span> <span class="token number">0</span>
    <span class="token comment">// 新旧节点逐个diff</span>
    <span class="token keyword">for</span> <span class="token punctuation">(</span><span class="token punctuation">;</span> i <span class="token operator">&lt;</span> newChildren<span class="token punctuation">.</span>length<span class="token punctuation">;</span> <span class="token operator">++</span>i<span class="token punctuation">)</span> <span class="token punctuation">{</span>
        <span class="token keyword">let</span> newNode <span class="token operator">=</span> newChildren<span class="token punctuation">[</span>i<span class="token punctuation">]</span>
        <span class="token keyword">let</span> <span class="token literal-property property">newFiber</span><span class="token operator">:</span> Fiber
        <span class="token keyword">let</span> <span class="token literal-property property">oldFiber</span><span class="token operator">:</span> Fiber
        
        <span class="token comment">// 根据key找到旧节点</span>
        <span class="token keyword">let</span> key <span class="token operator">=</span> newNode<span class="token punctuation">.</span>key <span class="token operator">===</span> <span class="token keyword">undefined</span> <span class="token operator">?</span> i <span class="token operator">:</span> newNode<span class="token punctuation">.</span>key
        oldFiber <span class="token operator">=</span> existingChildren<span class="token punctuation">.</span><span class="token function">get</span><span class="token punctuation">(</span>key<span class="token punctuation">)</span>

        <span class="token keyword">if</span> <span class="token punctuation">(</span>oldFiber<span class="token punctuation">)</span> <span class="token punctuation">{</span>
            <span class="token keyword">if</span> <span class="token punctuation">(</span><span class="token function">isSameVnode</span><span class="token punctuation">(</span>newNode<span class="token punctuation">,</span> oldFiber<span class="token punctuation">)</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>
                <span class="token comment">// 判断位置是否相同，需要排除新插入的节点</span>
                <span class="token keyword">if</span> <span class="token punctuation">(</span>oldFiber<span class="token punctuation">.</span>index <span class="token operator">===</span> <span class="token punctuation">(</span>i <span class="token operator">-</span> insertCount<span class="token punctuation">)</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>
                  	<span class="token comment">// 判断props属性是否变化决定是否标记为UPDATE</span>
                <span class="token punctuation">}</span> <span class="token keyword">else</span> <span class="token punctuation">{</span>
                  	<span class="token comment">// 与之前的索引值不一致，标记为MOVE</span>
                <span class="token punctuation">}</span>
            <span class="token punctuation">}</span> <span class="token keyword">else</span> <span class="token punctuation">{</span>
                <span class="token comment">// 如果类型不同，则需要删除对应位置的旧节点，然后插入新的节点，标记为REPLACE</span>
            <span class="token punctuation">}</span>
            existingChildren<span class="token punctuation">.</span><span class="token function">delete</span><span class="token punctuation">(</span>key<span class="token punctuation">)</span>
        <span class="token punctuation">}</span> <span class="token keyword">else</span> <span class="token punctuation">{</span>
            insertCount<span class="token operator">++</span>
            <span class="token comment">// 当前位置不存在旧节点，表示新增ADD</span>
            newFiber <span class="token operator">=</span> <span class="token function">createFiber</span><span class="token punctuation">(</span>newNode<span class="token punctuation">,</span> PatchTag<span class="token punctuation">.</span><span class="token constant">ADD</span><span class="token punctuation">)</span>
        <span class="token punctuation">}</span>

        newFiber<span class="token punctuation">.</span>index <span class="token operator">=</span> i
      	<span class="token comment">// 省略:调整newFiber.return 、 prevFiber.sibling 、 parentFiber.child的更新</span>
    <span class="token punctuation">}</span>
    <span class="token comment">// 省略:移除剩余未被比较的旧节点</span>
<span class="token punctuation">}</span>
</code></pre></div><p>然后在patch的时候，检测到<code>PatchTag.MOVE</code>的变动，就会将旧节点移动到新节点的指定位置。</p><p>从上面的实现可以看出，如果在渲染列表时用index作为key值，实际上并不是一个很好的选择，因为index作为key值与前面无key值查找旧节点的方式就是一样的了，无法避免就地复用的问题。</p><p>此外，<code>key</code>属性应该是稳定，可预测和唯一的。 不稳定的key(如使用<code>Math.random()</code>生的<code>key</code>)将导致许多组件实例和DOM节点进行不必要地重复创建，这可能导致子组件中的性能降低和<code>state</code>丢失</p><h2 id="小结" tabindex="-1">小结 <a class="header-anchor" href="#小结" aria-hidden="true">#</a></h2><p>本文整理了下面几个方面的内容</p><ul><li>首先从diff算法的概念入手，整理了diff算法原理：即依次对比新旧节点，并收集节点的变化。</li><li>然后给出了递归和循环两种diff算法的实现。</li><li>最后讨论了key在diff算法中的作用：将按照索引值查找旧节点的方式，修改为按照key查找旧节点</li></ul><p>通过手动编写代码，可以进一步了解diff算法的原理和使用。</p></div></div><footer class="page-footer" data-v-8fcebc32 data-v-b65b4b36><div class="edit" data-v-b65b4b36><div class="edit-link" data-v-b65b4b36 data-v-55695e90><!----></div></div><div class="updated" data-v-b65b4b36><!----></div></footer><div class="next-and-prev-link" data-v-8fcebc32 data-v-e65a9748><div class="container" data-v-e65a9748><div class="prev" data-v-e65a9748><a class="link" href="/前端/库与框架/Vuex" data-v-e65a9748><svg xmlns="http://www.w3.org/2000/svg" viewbox="0 0 24 24" class="icon icon-prev" data-v-e65a9748><path d="M19,11H7.4l5.3-5.3c0.4-0.4,0.4-1,0-1.4s-1-0.4-1.4,0l-7,7c-0.1,0.1-0.2,0.2-0.2,0.3c-0.1,0.2-0.1,0.5,0,0.8c0.1,0.1,0.1,0.2,0.2,0.3l7,7c0.2,0.2,0.5,0.3,0.7,0.3s0.5-0.1,0.7-0.3c0.4-0.4,0.4-1,0-1.4L7.4,13H19c0.6,0,1-0.4,1-1S19.6,11,19,11z"></path></svg><span class="text" data-v-e65a9748>Vuex</span></a></div><div class="next" data-v-e65a9748><a class="link" href="/前端/库与框架/几种框架的对比" data-v-e65a9748><span class="text" data-v-e65a9748>几种框架的对比</span><svg xmlns="http://www.w3.org/2000/svg" viewbox="0 0 24 24" class="icon icon-next" data-v-e65a9748><path d="M19.9,12.4c0.1-0.2,0.1-0.5,0-0.8c-0.1-0.1-0.1-0.2-0.2-0.3l-7-7c-0.4-0.4-1-0.4-1.4,0s-0.4,1,0,1.4l5.3,5.3H5c-0.6,0-1,0.4-1,1s0.4,1,1,1h11.6l-5.3,5.3c-0.4,0.4-0.4,1,0,1.4c0.2,0.2,0.5,0.3,0.7,0.3s0.5-0.1,0.7-0.3l7-7C19.8,12.6,19.9,12.5,19.9,12.4z"></path></svg></a></div></div></div><!--[--><!--]--></div></main></div><!----><!--]--></div>
    <script>__VP_HASH_MAP__ = JSON.parse("{\"app_android.md\":\"88eacd24\",\"app_flutter.md\":\"7f564ecd\",\"app_ios.md\":\"4c18063d\",\"app_webview.md\":\"86f7ba86\",\"readme.md\":\"49adce16\",\"index.md\":\"aadab414\",\"前端_css_css3.md\":\"9d989739\",\"前端_css_readme.md\":\"e9d0f855\",\"前端_css_分辨率.md\":\"d1a81e33\",\"前端_css_基础知识.md\":\"bcc288d6\",\"前端_css_性能优化.md\":\"6037e0d5\",\"前端_css_核心知识.md\":\"82830b61\",\"前端_css_编写样式表.md\":\"80820bb7\",\"前端_css_选择器.md\":\"4fe18340\",\"前端_html_html.md\":\"eea121b8\",\"前端_html_seo优化.md\":\"ee33fb47\",\"前端_html_web components.md\":\"c4bcf8d8\",\"前端_html_webassembly.md\":\"777cea40\",\"前端_html_浏览器解析与渲染流程.md\":\"a8a93eda\",\"前端_javascript_canvas.md\":\"46aae565\",\"前端_javascript_dom和bom.md\":\"3638de69\",\"前端_javascript_ecmascript.md\":\"d60fd8be\",\"前端_javascript_eventloop.md\":\"924decd2\",\"前端_javascript_nodejs.md\":\"b7821438\",\"前端_javascript_readme.md\":\"029607f3\",\"前端_javascript_typescript.md\":\"b34ec077\",\"前端_javascript_事件流.md\":\"ebad3727\",\"前端_javascript_函数式编程.md\":\"e97f06af\",\"前端_javascript_原型.md\":\"23b08ebb\",\"前端_javascript_数据类型.md\":\"142d4642\",\"前端_javascript_正则.md\":\"aa4251f4\",\"前端_javascript_运算符.md\":\"e1a8dc1c\",\"前端_readme.md\":\"f1b76e6f\",\"前端_业务相关_ab测试.md\":\"06f39520\",\"前端_业务相关_babel.md\":\"1be9a29d\",\"前端_业务相关_ci.md\":\"a23b9446\",\"前端_业务相关_docker.md\":\"dc0bc011\",\"前端_业务相关_web直播.md\":\"bc4475ce\",\"前端_业务相关_git.md\":\"23566562\",\"前端_业务相关_mock.md\":\"5a8ad29a\",\"前端_业务相关_npm.md\":\"82b6d7be\",\"前端_业务相关_webpack.md\":\"8c8f7832\",\"前端_业务相关_web安全.md\":\"2f72bede\",\"前端_业务相关_前端工程化.md\":\"a5fb99c3\",\"前端_业务相关_单元测试.md\":\"891b3501\",\"前端_业务相关_可视化页面工具.md\":\"67dc2a49\",\"前端_业务相关_微前端.md\":\"5bad2d6c\",\"前端_业务相关_性能优化.md\":\"54e2e6f2\",\"前端_业务相关_数据埋点.md\":\"e341e9d8\",\"前端_业务相关_模块化.md\":\"ab800ad9\",\"前端_业务相关_类前端业务.md\":\"23a0f9a3\",\"前端_业务相关_调试.md\":\"87d0349d\",\"前端_业务相关_跨端.md\":\"664bbb37\",\"前端_库与框架_chrome扩展程序.md\":\"4e4e43f7\",\"前端_库与框架_electron.md\":\"ecac288b\",\"前端_库与框架_immutable.md\":\"d6a033f2\",\"前端_库与框架_readme.md\":\"9a25cc50\",\"前端_库与框架_react.md\":\"7a4befbb\",\"前端_库与框架_rxjs.md\":\"318f2e4a\",\"前端_库与框架_svelet.md\":\"ce72c922\",\"前端_库与框架_vue.md\":\"fbbda928\",\"前端_库与框架_vuex.md\":\"f142f41b\",\"前端_库与框架_diff算法.md\":\"c17466da\",\"前端_库与框架_几种框架的对比.md\":\"4b7ff044\",\"前端_库与框架_单页面应用router.md\":\"699f9a23\",\"前端_库与框架_微信小程序.md\":\"d382cf0b\",\"前端_库与框架_技术选型.md\":\"aea8d481\",\"后台_clickhouse.md\":\"8bf72810\",\"后台_java.md\":\"5d578169\",\"后台_mongodb.md\":\"f20bee13\",\"后台_mysql.md\":\"5579460e\",\"后台_php.md\":\"bb2f3dfc\",\"后台_readme.md\":\"a7fe6628\",\"后台_restful.md\":\"a6d17b21\",\"导读.md\":\"b62bd81e\",\"数据结构和算法_readme.md\":\"9b72aee6\",\"数据结构和算法_动态规划.md\":\"08ad7e65\",\"数据结构和算法_基本数据结构.md\":\"7d240f09\",\"数据结构和算法_基本算法.md\":\"0f1efe93\",\"数据结构和算法_栈.md\":\"5a141448\",\"游戏开发_readme.md\":\"1bd1e015\",\"游戏开发_tiledmap教程汇总.md\":\"a78eb64e\",\"游戏开发_技能系统.md\":\"ee5a565f\",\"游戏开发_游戏开发之前的准备.md\":\"beef52cc\",\"游戏开发_游戏类型.md\":\"5122a88e\",\"源码分析_readme.md\":\"1261ca68\",\"源码分析_reactfibler源码分析.md\":\"cb3a8df5\",\"源码分析_react源码分析.md\":\"973fb801\",\"源码分析_redux源码分析.md\":\"e569c73b\",\"源码分析_axios源码分析.md\":\"b45075a0\",\"源码分析_koa源码分析.md\":\"7e867057\",\"网络_dns.md\":\"21607a28\",\"网络_http.md\":\"29763526\",\"网络_nginx.md\":\"0f55e3eb\",\"网络_readme.md\":\"4f1359e7\",\"网络_rpc.md\":\"769592fb\",\"网络_前端网络请求.md\":\"e7650483\",\"网络_抓包.md\":\"f4ff7da3\",\"计算机基础_readme.md\":\"2ce2bef9\",\"计算机基础_操作系统.md\":\"d47ce3bd\",\"计算机基础_编译原理.md\":\"83723f03\",\"计算机基础_计算机网络.md\":\"51deb230\",\"计算机基础_软件工程.md\":\"8552319d\",\"读书笔记_readme.md\":\"c56c8a78\",\"读书笔记_如何阅读一本书.md\":\"95acaa0e\",\"面试_readme.md\":\"3fdb19fd\",\"面试_面试记录_2017_dae.md\":\"3ee342dc\",\"面试_面试记录_2017_te.md\":\"bc8cba12\",\"面试_面试记录_2018_ayldm.md\":\"09fd23e2\",\"面试_面试记录_2018_hdjr.md\":\"e4b7b8cd\",\"面试_面试记录_2018_md.md\":\"4e3693ef\",\"面试_面试记录_2018_pakj.md\":\"c3deb803\",\"面试_面试记录_2018_qkcj.md\":\"5236db39\",\"面试_面试记录_2018_sfwy.md\":\"dfec2361\",\"面试_面试记录_2018_tw.md\":\"2e712294\",\"面试_面试记录_2018_yhkj.md\":\"0a93cc3b\",\"面试_面试记录_2018_yskj.md\":\"bdfd1d0c\",\"面试_面试记录_2018_z8.md\":\"520cdfeb\",\"面试_面试记录_2019_bcz.md\":\"9b4ca3e6\",\"面试_面试记录_2019_hkjt.md\":\"08ed2c29\",\"面试_面试记录_2019_jrtt.md\":\"64387aac\",\"面试_面试记录_2019_lds.md\":\"0814bbac\",\"面试_面试记录_2019_qexr.md\":\"c7330531\",\"面试_面试记录_2019_wblz.md\":\"c4a597d8\",\"面试_面试记录_2019_xflx.md\":\"ccc21ace\",\"面试_面试题_css.md\":\"2f456c7e\",\"面试_面试题_dom.md\":\"6441fea4\",\"面试_面试题_ecmascript.md\":\"3c852470\",\"面试_面试题_html.md\":\"3d8879c0\",\"面试_面试题_readme.md\":\"68edd278\",\"面试_面试题_react.md\":\"290ae939\",\"面试_面试题_vue.md\":\"9076be2f\",\"面试_面试题_代码实现.md\":\"c845b9a2\",\"面试_面试题_代码阅读.md\":\"6cea6994\",\"面试_面试题_其他问题.md\":\"79ba15a0\",\"面试_面试题_兼容及bug.md\":\"3d439627\",\"面试_面试题_常见需求.md\":\"fd736d8a\",\"面试_面试题_算法实现.md\":\"1321d2da\",\"面试_面试题_网络.md\":\"baf75f4a\"}")</script>
    <script type="module" async src="/assets/app.946f11db.js"></script>
    
  </body>
</html>