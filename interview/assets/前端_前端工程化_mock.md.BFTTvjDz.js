import{_ as s,c as i,o as a,a2 as n}from"./chunks/framework.DLPB9-dE.js";const g=JSON.parse('{"title":"前端 Mock","description":"","frontmatter":{},"headers":[],"relativePath":"前端/前端工程化/mock.md","filePath":"前端/前端工程化/mock.md","lastUpdated":1683863238000}'),l={name:"前端/前端工程化/mock.md"},h=n(`<h1 id="前端-mock" tabindex="-1">前端 Mock <a class="header-anchor" href="#前端-mock" aria-label="Permalink to &quot;前端 Mock&quot;">​</a></h1><h2 id="常见的-mock-开发方案" tabindex="-1">常见的 mock 开发方案 <a class="header-anchor" href="#常见的-mock-开发方案" aria-label="Permalink to &quot;常见的 mock 开发方案&quot;">​</a></h2><p>在前后端分离的项目中，前端一般会先模仿后台数据接口字段，生成模拟测试数据。</p><h3 id="直接在业务代码里面硬编码" tabindex="-1">直接在业务代码里面硬编码 <a class="header-anchor" href="#直接在业务代码里面硬编码" aria-label="Permalink to &quot;直接在业务代码里面硬编码&quot;">​</a></h3><p>返回数据，对代码侵入性很强，需要记得在测试完毕后移除 mock 数据，下次 mock 时又要重新硬编码</p><div class="language-js vp-adaptive-theme"><button title="Copy Code" class="copy"></button><span class="lang">js</span><pre class="shiki shiki-themes github-light github-dark vp-code"><code><span class="line"><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">export</span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;"> function</span><span style="--shiki-light:#6F42C1;--shiki-dark:#B392F0;"> fetchUserInfo</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">() {</span></span>
<span class="line"><span style="--shiki-light:#6A737D;--shiki-dark:#6A737D;">    // return http.get(&#39;/user/inof&#39;)</span></span>
<span class="line"><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">    return</span><span style="--shiki-light:#005CC5;--shiki-dark:#79B8FF;"> Promise</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">.</span><span style="--shiki-light:#6F42C1;--shiki-dark:#B392F0;">resolve</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">({</span></span>
<span class="line"><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">        code: </span><span style="--shiki-light:#005CC5;--shiki-dark:#79B8FF;">200</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">,</span></span>
<span class="line"><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">        data: {},</span></span>
<span class="line"><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">        msg: </span><span style="--shiki-light:#032F62;--shiki-dark:#9ECBFF;">&quot;SUCCESS&quot;</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">,</span></span>
<span class="line"><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">    });</span></span>
<span class="line"><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">}</span></span></code></pre></div><h3 id="在前端拦截网络请求" tabindex="-1">在前端拦截网络请求 <a class="header-anchor" href="#在前端拦截网络请求" aria-label="Permalink to &quot;在前端拦截网络请求&quot;">​</a></h3><p>在前端拦截网络请求，常见的做法是代理 xhr 或者 fetch，如<code>mockjs</code>，之前的整理：<a href="http://www.shymean.com/article/mockjs%E4%BD%BF%E7%94%A8%E5%BF%83%E5%BE%97" target="_blank" rel="noreferrer">mockjs使用心得</a></p><ul><li>根据后台接口字段，<code>Mock.mock(url, tpl)</code>拦截响应请求，返回模拟数据</li><li>将所有的 mock 至于一个单独的<code>_mock</code>模块中，根据环境参数，在开发环境引入</li></ul><div class="language-js vp-adaptive-theme"><button title="Copy Code" class="copy"></button><span class="lang">js</span><pre class="shiki shiki-themes github-light github-dark vp-code"><code><span class="line"><span style="--shiki-light:#6A737D;--shiki-dark:#6A737D;">// _mock.js</span></span>
<span class="line"><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">Mock.</span><span style="--shiki-light:#6F42C1;--shiki-dark:#B392F0;">mock</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">(</span><span style="--shiki-light:#032F62;--shiki-dark:#9ECBFF;">/</span><span style="--shiki-light:#22863A;--shiki-dark:#85E89D;--shiki-light-font-weight:bold;--shiki-dark-font-weight:bold;">\\/</span><span style="--shiki-light:#032F62;--shiki-dark:#DBEDFF;">api</span><span style="--shiki-light:#22863A;--shiki-dark:#85E89D;--shiki-light-font-weight:bold;--shiki-dark-font-weight:bold;">\\/</span><span style="--shiki-light:#032F62;--shiki-dark:#DBEDFF;">taskStatus</span><span style="--shiki-light:#032F62;--shiki-dark:#9ECBFF;">/</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">, </span><span style="--shiki-light:#032F62;--shiki-dark:#9ECBFF;">&quot;get&quot;</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">, {</span></span>
<span class="line"><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">    code: </span><span style="--shiki-light:#005CC5;--shiki-dark:#79B8FF;">0</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">,</span></span>
<span class="line"><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">    msg: </span><span style="--shiki-light:#005CC5;--shiki-dark:#79B8FF;">null</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">,</span></span>
<span class="line"><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">    data: {</span></span>
<span class="line"><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">        userId: </span><span style="--shiki-light:#005CC5;--shiki-dark:#79B8FF;">1</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">,</span></span>
<span class="line"><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">    },</span></span>
<span class="line"><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">});</span></span>
<span class="line"><span style="--shiki-light:#6A737D;--shiki-dark:#6A737D;">// ... 其他的mock接口，如果项目过大可以拆分成多个文件，然后统一引入入口文件</span></span>
<span class="line"></span>
<span class="line"></span>
<span class="line"><span style="--shiki-light:#6A737D;--shiki-dark:#6A737D;">// 然后判断环境变量，在开发环境引入，不影响线上环境</span></span>
<span class="line"><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">if</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;"> (process.env.</span><span style="--shiki-light:#005CC5;--shiki-dark:#79B8FF;">NODE_ENV</span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;"> ===</span><span style="--shiki-light:#032F62;--shiki-dark:#9ECBFF;"> &#39;development&#39;</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">) {</span></span>
<span class="line"><span style="--shiki-light:#6F42C1;--shiki-dark:#B392F0;">  require</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">(</span><span style="--shiki-light:#032F62;--shiki-dark:#9ECBFF;">&#39;./_mock&#39;</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">)</span></span>
<span class="line"><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">}</span></span></code></pre></div><p>这种方式的缺点在于</p><ul><li>不能在调试面板看见真实的请求，</li><li>仅适用于前端，如小程序、app 等无 xhr 的场景下就不使用了</li><li>对 xhr 的改写，在某些特殊业务场景下也存在一些问题</li></ul><h3 id="网络代理拦截" tabindex="-1">网络代理拦截 <a class="header-anchor" href="#网络代理拦截" aria-label="Permalink to &quot;网络代理拦截&quot;">​</a></h3><p>通过代理软件 charles、fiddler 的 mock remote、mock local 等功能进行拦截，比较真实，可以满足大部分模拟请求，甚至可以拦截线上项目的请求；缺点在于操作繁琐，也不方便统一管理 mock 模板</p><h3 id="mock-server" tabindex="-1">mock server <a class="header-anchor" href="#mock-server" aria-label="Permalink to &quot;mock server&quot;">​</a></h3><p>启动 mock server，将需要 mock 的请求重定向到这个服务器，不需要侵入代码，操作也很方便</p><p>比较流行的是<a href="https://github.com/easy-mock/easy-mock" target="_blank" rel="noreferrer">easy mock</a>，可以进行本地安装</p><p>依赖 mongodb、redis，node 版本需要 v8，本地使用的 v8.10.0</p><p>clone 仓库后，依次启动本地的 mongodb、redis，然后 npm run dev 即可启动本地服务。</p>`,19),e=[h];function t(k,p,r,o,d,E){return a(),i("div",null,e)}const y=s(l,[["render",t]]);export{g as __pageData,y as default};
