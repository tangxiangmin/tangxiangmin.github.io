import{_ as e,c as a,o as s,a2 as n}from"./chunks/framework.DLPB9-dE.js";const g=JSON.parse('{"title":"","description":"","frontmatter":{},"headers":[],"relativePath":"网络/应用层.md","filePath":"网络/应用层.md","lastUpdated":1709042257000}'),p={name:"网络/应用层.md"},i=n(`<p>先介绍一下工作中最常见的应用层协议：HTTP。</p><h2 id="http" tabindex="-1">HTTP <a class="header-anchor" href="#http" aria-label="Permalink to &quot;HTTP&quot;">​</a></h2><p>参考之前</p><ul><li><a href="https://www.shymean.com/archive/HTTP" target="_blank" rel="noreferrer">HTTP系列</a></li></ul><p>HTTP：超文本传输协议（英文：<code>HyperText Transfer Protocol</code>，缩写：HTTP）是一种用于分布式、协作式和超媒体信息系统的应用层协议，是万维网（WWW）的数据通信的基础。</p><h3 id="报文" tabindex="-1">报文 <a class="header-anchor" href="#报文" aria-label="Permalink to &quot;报文&quot;">​</a></h3><p>HTTP报文是浏览器和服务器之间发送的数据块，是信息的基本单元。</p><p>报文的格式和语义由协议规范定义，主要包含三个部分</p><ul><li>对报文进行描述的起始行</li><li>包含属性的首部块</li><li>可选的，包含数据的主体部分</li></ul><p>一个简单的<strong>请求报文</strong></p><div class="language- vp-adaptive-theme"><button title="Copy Code" class="copy"></button><span class="lang"></span><pre class="shiki shiki-themes github-light github-dark vp-code"><code><span class="line"><span>GET /index.html HTTP/1.1</span></span>
<span class="line"><span>Host: www.example.com</span></span>
<span class="line"><span>User-Agent: Mozilla/5.0</span></span></code></pre></div><p>一个简单的<strong>响应报文</strong></p><div class="language- vp-adaptive-theme"><button title="Copy Code" class="copy"></button><span class="lang"></span><pre class="shiki shiki-themes github-light github-dark vp-code"><code><span class="line"><span>HTTP/1.1 200 OK</span></span>
<span class="line"><span>Content-Type: text/html</span></span>
<span class="line"><span>Content-Length: 123</span></span>
<span class="line"><span>&lt;html&gt;</span></span>
<span class="line"><span>&lt;body&gt;</span></span>
<span class="line"><span>...</span></span>
<span class="line"><span>&lt;/body&gt;</span></span>
<span class="line"><span>&lt;/html&gt;</span></span></code></pre></div><p>请求报文和响应报文最主要的结构区别在于起始行不一样：</p><ul><li>请求报文的首部行包含请求方法，资源URL和HTTP版本号</li><li>响应报文包含HTTP版本号，请求资源的响应状态（一个三位数）和原因短语（一个英语短语文本）</li></ul><h3 id="首部行字段" tabindex="-1">首部行字段 <a class="header-anchor" href="#首部行字段" aria-label="Permalink to &quot;首部行字段&quot;">​</a></h3><p>参考：<a href="http://www.jianshu.com/p/6e86903d74f7" target="_blank" rel="noreferrer">前端必备HTTP技能之HTTP请求头响应头中常用字段详解</a></p><p>首部行携带了一些关于报文的原始信息，可分为通用首部、请求首部、响应首部、实体首部等，下面列举了一些常见的头部，每个字段又有一些常用的属性值</p><p><strong>通用头部字段</strong>（既可以出现在请求中，也可以出现在响应中）：</p><p>Cache-Control： 控制缓存行为，例如no-cache表示不使用缓存。</p><p>Connection： 指定与连接相关的属性，如keep-alive表示持久连接。</p><p>Date： 表示消息的创建时间。</p><p>Pragma： 类似于Cache-Control，用于向后兼容。</p><p><strong>请求头部字段</strong>：</p><p>Host： 指定请求的目标主机和端口号。</p><p>User-Agent： 标识客户端的用户代理，通常是浏览器信息。</p><p>Accept： 指定客户端能够处理的响应的媒体类型。</p><p>Accept-Language： 指定客户端能够处理的响应的自然语言。</p><p>Authorization： 包含用于进行身份验证的凭据，通常用于发送用户名和密码。</p><p>Cookie： 包含之前服务器通过Set-Cookie头部发送的Cookie信息。</p><p><strong>响应头部字段</strong>：</p><p>Location： 用于重定向，指定新的URI。</p><p>Server： 描述服务器信息。</p><p>WWW-Authenticate： 表示需要进行身份验证。</p><p>Set-Cookie： 用于在响应中向客户端设置Cookie。</p><p><strong>实体头部字段</strong>（在请求或响应的消息体中使用）：</p><p>Content-Type： 指定消息体的媒体类型。</p><p>Content-Length： 指定消息体的长度。</p><p>Content-Encoding： 指定消息体的编码方式，如gzip。</p><p>Content-Language： 指定消息体的自然语言。</p><p><strong>其他常用头部字段</strong>：</p><p>Referer： 表示请求的来源，即引用页。</p><p>Origin： 表示发起请求的域，用于跨域请求。</p><p>DNT (Do Not Track)： 表示用户不希望被追踪。</p><p>If-Modified-Since： 如果服务器在指定时间后对资源进行了修改，则发送请求。</p><p>Upgrade-Insecure-Requests： 表示客户端希望升级为安全连接，用于HTTPS。</p><h3 id="常见的请求方法" tabindex="-1">常见的请求方法 <a class="header-anchor" href="#常见的请求方法" aria-label="Permalink to &quot;常见的请求方法&quot;">​</a></h3><p>HTTP最初设定了多种请求方法</p><p><strong>GET</strong>： 用于请求服务器发送某个资源。客户端通过GET方法向服务器请求特定资源的表示，服务器将资源返回给客户端。</p><p><strong>POST</strong>： 用于向服务器提交数据，通常用于创建新资源。POST请求可能会导致服务器上的处理，如在数据库中创建新条目。</p><p><strong>PUT</strong>： 用于向服务器上传数据，通常用于更新已存在的资源。客户端发送的数据包含了资源的新表示。</p><p><strong>DELETE</strong>： 请求服务器删除指定的资源。</p><p><strong>HEAD</strong>： 类似于GET，但服务器只返回头部信息，不返回实际的资源。通常用于检查资源的元信息，如是否已经修改。</p><p><strong>OPTIONS</strong>： 用于获取目标资源所支持的通信选项。客户端可以查询服务器支持的方法、头部或其他信息。</p><p><strong>PATCH</strong>： 用于对资源进行部分修改。客户端发送包含要应用到资源的部分修改的请求。</p><p><strong>TRACE</strong>:回显服务器收到的请求,主要用于测试或诊断。</p><p>需要认识到的是，HTTP最初设定了多种请求方法，这些方法在本质上没有任何区别，只是让请求更加有语义而已，大部分应用都只使用了GET和POST就完成了应用的搭建。</p><blockquote><p>一个经常遇见的问题是：GET和POST有什么区别？</p></blockquote><p>就日常使用经验来看</p><ul><li>传递请求数据的方式不同，GET将参数添加在URL的查询字段后（URL位于请求报文的起始行），而POST将请求数据放在请求报文的主体部分</li><li>由于浏览器可能缓存带有查询字段的URL，因此不能保证安全而被其他访问者查看；POST“相对”而言会安全一点</li><li>某些浏览器对于URL的长度是有限制的，服务器一般也对URL长度有某些限制（超过会返回414错误），因此在需要向服务器传递大量数据的时候一般使用POST方法</li><li>貌似部分浏览器和框架对于GET会发送一个TCP包，POST会发送两个包，但并不全是这样，具体可以参考<a href="https://blog.csdn.net/zerooffdate/article/details/78962818" target="_blank" rel="noreferrer">这里</a>，这不是HTTP本身协议的问题。</li></ul><h3 id="常见的状态码" tabindex="-1">常见的状态码 <a class="header-anchor" href="#常见的状态码" aria-label="Permalink to &quot;常见的状态码&quot;">​</a></h3><p>状态码是一个三位数，第一位描述状态的一般类别（成功，失败...），后两位描述状态的详细信息</p><ul><li>1表示信息提示 <ul><li>100 Continue 表示服务器已经收到了请求的部分，并且客户端可以继续发送请求的剩余部分。</li></ul></li><li>2表示请求成功 <ul><li><code>200 OK</code>： 请求成功。通常，这个状态码表示请求已经成功。</li><li>201 Created： 请求已经被成功处理，并且服务器创建了新的资源。</li><li>204 No Content： 请求成功，但响应不包含实体的主体部分，通常用于DELETE请求。</li></ul></li><li>3表示重定向，要么告知客户端使用替代位置来访问他们感兴趣的资源，要么是服务器提供一个替代的响应而不是请求资源的内容 <ul><li>301 Moved Permanently： 请求的资源已被永久移动到新的位置，将来的请求应使用新的URL。</li><li>302 Found： 请求的资源临时移动到新的位置，将来的请求仍应使用原始的URL。</li><li><code>304 Not Modified</code>： 表示资源在客户端缓存中仍然有效，可以直接使用缓存的版本。</li></ul></li><li>4表示客户端错误，指浏览器发送了服务器无法处理的内容 <ul><li>400 Bad Request： 客户端发送的请求有语法错误，服务器无法理解。</li><li><code>401 Unauthorized</code>： 请求未经授权，需要身份验证。</li><li>403 Forbidden： 服务器理解请求，但拒绝执行。通常是因为没有足够的权限。</li><li><code>404 Not Found</code>： 请求的资源不存在。</li></ul></li><li>5表示服务端错误 <ul><li><code>500 Internal Server Error</code>： 服务器遇到了一个未知的错误，无法完成请求。</li><li>501 Not Implemented： 服务器不支持请求的功能，无法完成请求。</li><li><code>502 Bad Gateway</code>： 作为网关或代理服务器的服务器，从上游服务器收到无效的响应。</li><li>503 Service Unavailable： 服务器当前无法处理请求，通常是由于维护或过载。</li><li><code>504 Gateway Timeout</code>： 作为网关或代理服务器的服务器，在规定的时间内未能从上游服务器接收到响应。</li></ul></li></ul><p>还有一些其他不是很常用的状态码，这里没有单独列出了。</p><p>由于HTTP是一个在应用程序中直接操作的协议，返回的状态码完全由应用开发者自己控制，因此在某些时候返回的状态码与实际原因可能并不一致，需要结合实际场景分析。</p><h3 id="无状态" tabindex="-1">无状态 <a class="header-anchor" href="#无状态" aria-label="Permalink to &quot;无状态&quot;">​</a></h3><p>每个HTTP请求/响应都是一个独立的事务，服务器不会保留先前请求的状态。这使得HTTP协议设计简单，但也带来了一些额外的开销，因为每次请求都需要重新建立连接。</p><h4 id="keep-alive" tabindex="-1">keep-alive <a class="header-anchor" href="#keep-alive" aria-label="Permalink to &quot;keep-alive&quot;">​</a></h4><p>在早期，当一个HTTP请求响应完毕后，就会断开本次TCP连接。如果HTTP请求比较频繁，这种为单个请求建立TCP连接的方式就比较浪费。</p><p>可以通过配置<code>Connection：keep-alive</code>和<code>Keep-Alive:timeout=x,max=xx</code>的响应头来改善这种状态。</p><p>可以理解为HTTP的 <code>keep-alive</code>是为了让TCP活得更久一点：当一个HTTP相应完毕后，理应立即关闭本次链接，服务端此时会等待<code>timeout</code>秒，然后才关闭这个链接。</p><p>由于每个HTTP请求都是独立的，服务器不会保存客户端的状态信息。</p><p>为了处理状态，例如用户的登录状态，通常需要使用会话（Session）机制，或者将状态信息通过Cookie等方式保存在客户端。</p><h4 id="cookie" tabindex="-1">Cookie <a class="header-anchor" href="#cookie" aria-label="Permalink to &quot;Cookie&quot;">​</a></h4><p>Cookie是服务器发送到用户浏览器并保存在浏览器上的一块数据，它会在浏览器下一次发起请求时被携带并发送到服务器上。</p><p>Cookie的使用使得基于无状态的HTTP协议上记录稳定的状态信息成为了可能。</p><p>Cookie非常依赖于浏览器，不同浏览器之间的Cookie是不能通用的。可以笼统地将Cookie分为两类：会话Cookie和持久Cookie:</p><ul><li>会话Cookie是临时Cookie，用户退出浏览器时Cookie就被删除了</li><li>持久Cookie是指会被保存在硬盘上的Cookie信息，浏览器退出，计算机重启时他们仍然存在。</li><li>会话Cookie与持久Cookie的区别在于是否为他们设置了过期时间，如果没有，则为会话Cookie。接下来看看服务器是如何在响应报文中设置Cookie的</li></ul><p>服务端通过响应报文的<code>Set-Cookie</code>字段设置Cookie</p><div class="language- vp-adaptive-theme"><button title="Copy Code" class="copy"></button><span class="lang"></span><pre class="shiki shiki-themes github-light github-dark vp-code"><code><span class="line"><span>Set-Cookie: &lt;cookie-name&gt;=&lt;cookie-value&gt;; [Domain=&lt;domain-value&gt;;][Secure;][HttpOnly;][Expires=&lt;date&gt;][Max-Age=&lt;non-zero-digit&gt;][Path=&lt;path-value&gt;]</span></span></code></pre></div><p>需要注意服务端<code>Set-Cookie</code>一些特殊的修饰符</p><ul><li><code>Secure</code>，表示只有在HTTP使用SSL安全连接时才发送该cookie</li><li><code>HttpOnly</code>，表示该Cookie无法被客户端Javascript操作</li></ul><p>浏览器通过请求报文的<code>Cookie</code>字段发送Cookie</p><div class="language- vp-adaptive-theme"><button title="Copy Code" class="copy"></button><span class="lang"></span><pre class="shiki shiki-themes github-light github-dark vp-code"><code><span class="line"><span>Cookie: name=value; name2=value2; name3=value3</span></span></code></pre></div><p>在浏览器中可以通过<code>document.cookie</code>来操作cookie。</p><h4 id="session" tabindex="-1">Session <a class="header-anchor" href="#session" aria-label="Permalink to &quot;Session&quot;">​</a></h4><p>Cookie将用户身份信息保存在浏览器，并在每次请求时携带对应信息到服务器。此外，也可以直接在服务器保存用户身份，这种方式称为<code>Session</code>。</p><p>维持session会话的核心就是客户端的唯一标识，即SessionID，SessionID就像是用户的身份证账号一样，只需要提供值，服务器就会自动检索并查找到用户的身份信息。</p><p>传递sessionId一般有下面几种方式</p><ul><li>最常用的方式是通过Cookie</li><li>通过URL参数</li><li>通过表单隐藏字段</li></ul><p>服务器使用类似于散列表的结构来保存多个用户的信息，每个用户的信息使用SessionID来索引，这就是SessionID必须唯一且不能被伪造的原因。 用户信息可以保存在内存中，文件中或者数据库中。</p><p>在实际应用中，Cookie 和 Session 经常一起使用，Cookie 用于存储一些客户端相关的信息，而 Session 则用于存储敏感或用户身份验证等数据。</p><h3 id="http缓存" tabindex="-1">HTTP缓存 <a class="header-anchor" href="#http缓存" aria-label="Permalink to &quot;HTTP缓存&quot;">​</a></h3><p>缓存的好处:</p><ul><li>减轻了服务器的压力，服务器不必为来自同一个客户端的资源请求进行重复处理</li><li>提高了客户端的加载速度，从本地或者就近的缓存中读取资源，比从遥远的服务器获取资源要快得多</li></ul><p>下面是与缓存相关的一些条件请求头部</p><ul><li><code>if-Modified-Since</code> 设置更新时间，从更新时间到服务端接受请求这段时间内如果资源没有改变，允许服务端返回304 Not Modified</li><li><code>If-None-Match</code>设置客户端ETag，如果和服务端接受请求生成的ETage相同，允许服务端返回304 Not Modified</li><li><code>If-Match</code>设置客户端的ETag,当时客户端ETag和服务器生成的ETag一致才执行，适用于更新自从上次更新之后没有改变的资源</li><li><code>If-Range</code>设置客户端ETag，如果和服务端接受请求生成的ETage相同，返回缺失的实体部分；否则返回整个新的实体</li><li><code>If-Unmodified-Since</code> 设置更新时间，只有从更新时间到服务端接受请求这段时间内实体没有改变，服务端才会发送响应</li></ul><p>下面是强缓存和协商缓存的相关流程</p><div class="language- vp-adaptive-theme"><button title="Copy Code" class="copy"></button><span class="lang"></span><pre class="shiki shiki-themes github-light github-dark vp-code"><code><span class="line"><span>@startuml  cache</span></span>
<span class="line"><span>start</span></span>
<span class="line"><span>:请求资源;</span></span>
<span class="line"><span>if(浏览器私有缓存) then (Y)</span></span>
<span class="line"><span>    if(新鲜度检测) then(Y)</span></span>
<span class="line"><span>        :200(from cache);</span></span>
<span class="line"><span>        stop</span></span>
<span class="line"><span>    else (N)</span></span>
<span class="line"><span>        if(服务器再验证) then(Y)</span></span>
<span class="line"><span>            :HTTP 304;</span></span>
<span class="line"><span>            :浏览器更新新鲜度;</span></span>
<span class="line"><span>            :304(not modified);</span></span>
<span class="line"><span>            stop</span></span>
<span class="line"><span>        endif</span></span>
<span class="line"><span>    endif</span></span>
<span class="line"><span>else (N)</span></span>
<span class="line"><span>    :未命中缓存，直接请求资源;</span></span>
<span class="line"><span>endif</span></span>
<span class="line"><span></span></span>
<span class="line"><span>if(资源存在) then(Y)</span></span>
<span class="line"><span>    :新内存存入缓存;</span></span>
<span class="line"><span>    :HTTP 200;</span></span>
<span class="line"><span>    stop</span></span>
<span class="line"><span>else </span></span>
<span class="line"><span>    :HTTP 404;</span></span>
<span class="line"><span>    stop</span></span>
<span class="line"><span>@enduml</span></span></code></pre></div><p><img src="http://img.shymean.com/oPic/1620227891123_947.png" alt=""></p><h2 id="http2" tabindex="-1">HTTP2 <a class="header-anchor" href="#http2" aria-label="Permalink to &quot;HTTP2&quot;">​</a></h2><p>参考</p><ul><li><a href="https://juejin.im/post/5c6a9f85e51d4503831ad4fa" target="_blank" rel="noreferrer">从理论到实践 全面理解HTTP/2</a></li></ul><h3 id="二进制格式传输与多路复用" tabindex="-1">二进制格式传输与多路复用 <a class="header-anchor" href="#二进制格式传输与多路复用" aria-label="Permalink to &quot;二进制格式传输与多路复用&quot;">​</a></h3><p>在HTTP/2中，新增了二进制分帧层，将数据转换成二进制，也就是说HTTP/2中所有的内容都是采用二进制传输</p><p>帧是HTTP/2中数据传输的最小单位；每个帧都有stream_ID字段，表示这个帧属于哪个流，接收方把stream_ID相同的所有帧组合到一起就是被传输的内容了。HTTP/2共定义了十种帧，较为常见的有数据帧、头部帧、PING帧、SETTING帧、优先级帧和PUSH_PROMISE帧等，为将来的高级应用打好了基础</p><p>在这种<strong>多路复用</strong>传输模式下，HTTP请求变得十分廉价，我们不需要再时刻顾虑网站的http请求数是否太多、TCP连接数是否太多、是否会产生阻塞等问题了。</p><h3 id="hpack-首部压缩" tabindex="-1">HPACK 首部压缩 <a class="header-anchor" href="#hpack-首部压缩" aria-label="Permalink to &quot;HPACK 首部压缩&quot;">​</a></h3><p>HTTP/1中，每个请求和响应都会携带对应的头部信息，每个页面的请求越多，越来越多的请求导致消耗在头部的流量越来越多，尤其是每次都要传输 UserAgent、Cookie 这类不会频繁变动的内容，完全是一种浪费</p><p>为了减少冗余的头部信息带来的消耗，HTTP/2采用HPACK 算法压缩请求和响应的header。其具体原理为</p><ul><li>通信双方共同维护了一份静态表，包含了常见的头部名称与值的组合（比如method:GET，可以存在表中，然后只需要传递一个键名即可）</li><li>根据先入先出的原则，维护一份可动态添加内容的动态表</li><li>用基于该静态哈夫曼码表的哈夫曼编码数据</li></ul><p>这样可以极大地节省头部的消耗</p><h3 id="server-push" tabindex="-1">server push <a class="header-anchor" href="#server-push" aria-label="Permalink to &quot;server push&quot;">​</a></h3><p>HTTP/2的server push允许服务器在未收到请求时主动向浏览器推送资源。这样可以将资源提前推送到到浏览器：除了静态文件，还可以推送比较耗时的API</p><p>在HTTP1.1时代，也有提前获取资源的方法，如preload和prefetch，</p><ul><li>preload是在页面解析初期就告诉浏览器，这个资源是浏览器马上要用到的，可以立刻发送对资源的请求，当需要用到该资源时就可以直接用而不用等待请求和响应的返回了</li><li>prefetch是当前页面用不到但下一页面可能会用到的资源，优先级较低，只有当浏览器空闲时才会请求prefetch标记的资源。</li></ul><p>从应用层面上看，preload和server push并没有什么区别，但是server push减少浏览器请求的时间，略优于preload，在一些场景中，可以将两者结合使用。</p>`,117),l=[i];function o(t,r,c,d,h,T){return s(),a("div",null,l)}const k=e(p,[["render",o]]);export{g as __pageData,k as default};
