import{_ as a,c as i,o as e,a2 as s}from"./chunks/framework.DLPB9-dE.js";const b=JSON.parse('{"title":"webview","description":"","frontmatter":{},"headers":[],"relativePath":"App/webview.md","filePath":"App/webview.md","lastUpdated":1620234346000}'),t={name:"App/webview.md"},l=s(`<h1 id="webview" tabindex="-1">webview <a class="header-anchor" href="#webview" aria-label="Permalink to &quot;webview&quot;">​</a></h1><p>参考</p><ul><li><a href="https://juejin.im/post/5cc5adde6fb9a031f4160969" target="_blank" rel="noreferrer">移动端开发之JSBridge</a></li><li><a href="http://ju.outofmemory.cn/entry/360590" target="_blank" rel="noreferrer">Hybrid APP开发：JSSDK</a></li></ul><h2 id="通信" tabindex="-1">通信 <a class="header-anchor" href="#通信" aria-label="Permalink to &quot;通信&quot;">​</a></h2><h3 id="js调用客户端方法" tabindex="-1">JS调用客户端方法 <a class="header-anchor" href="#js调用客户端方法" aria-label="Permalink to &quot;JS调用客户端方法&quot;">​</a></h3><p><strong>客户端API注入</strong></p><p>API注入的原理： Native 获取 JavaScript环境上下文，并直接在上面挂载对象或者方法，使 js 可以直接调用。</p><p>Android 与 IOS 分别拥有对应的挂载方式，参考之前整理的客户端文章</p><ul><li><a href="https://www.shymean.com/article/iOS%E5%9F%BA%E7%A1%80%E4%B9%8Bwebview" target="_blank" rel="noreferrer">iOS基础之webview</a></li><li><a href="https://www.shymean.com/article/%E5%AE%89%E5%8D%93%E5%85%A5%E9%97%A8%E4%B9%8BWebView" target="_blank" rel="noreferrer">安卓入门之WebView</a></li></ul><p><strong>网络拦截</strong></p><p>WebView作为承载H5页面的容器，有一个特性是非常重要，即 它可以捕捉到所有在容器中发起的网络请求。其实想要 JS唤起Native 的方法，只要建立起 JS与Native通信 的桥梁即可，而这一点正好被WebView的这一特性所实现。</p><p>在网页中可以通过 <strong>发起网络请求来向Native端传递消息</strong>，一般通过<code>iframe.src</code>发起网络请求，Native端在捕捉到约定协议头（Schema）的请求时，会进行解析然后调用对应的方法，同时可以在url上携带一些参数。</p><h3 id="客户端调用js方法" tabindex="-1">客户端调用JS方法 <a class="header-anchor" href="#客户端调用js方法" aria-label="Permalink to &quot;客户端调用JS方法&quot;">​</a></h3><p>考虑以下场景</p><ul><li>在唤起Native方法后，往往还需要执行一些回调，（如客户端需要把数据通过回调函数的形式通知JS）</li><li>JS需要暴露一些接口给客户端，并在合适的时机调用（如点击返回上一页按钮时）</li></ul><p>可以将回调方法挂载在约定的全局变量上，之后客户端调用JavaScript全局变量上的回调方法就可以了。</p><p>android</p><div class="language-java vp-adaptive-theme"><button title="Copy Code" class="copy"></button><span class="lang">java</span><pre class="shiki shiki-themes github-light github-dark vp-code"><code><span class="line"><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">webview.</span><span style="--shiki-light:#6F42C1;--shiki-dark:#B392F0;">loadUrl</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">(</span><span style="--shiki-light:#032F62;--shiki-dark:#9ECBFF;">&quot;javascript:alert(&#39;Hello from ios&#39;);&quot;</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">); </span><span style="--shiki-light:#6A737D;--shiki-dark:#6A737D;">// 可以调用JavaScript的全局对象</span></span></code></pre></div><p>iOS</p><div class="language-c vp-adaptive-theme"><button title="Copy Code" class="copy"></button><span class="lang">c</span><pre class="shiki shiki-themes github-light github-dark vp-code"><code><span class="line"><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">[webView evaluateJavaScript:@</span><span style="--shiki-light:#032F62;--shiki-dark:#9ECBFF;">&quot;document.body.style.backgroundColor = &#39;blue&#39;&quot;</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;"> completionHandler:</span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">^</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">(id result, NSError </span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">*</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">error) {</span></span>
<span class="line"><span style="--shiki-light:#6F42C1;--shiki-dark:#B392F0;">    NSLog</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">(@</span><span style="--shiki-light:#032F62;--shiki-dark:#9ECBFF;">&quot;Result </span><span style="--shiki-light:#B31D28;--shiki-dark:#FDAEB7;--shiki-light-font-style:italic;--shiki-dark-font-style:italic;">%</span><span style="--shiki-light:#032F62;--shiki-dark:#9ECBFF;">@&quot;</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">, result);</span></span>
<span class="line"><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">}];</span></span></code></pre></div><h2 id="jssdk" tabindex="-1">JSSDK <a class="header-anchor" href="#jssdk" aria-label="Permalink to &quot;JSSDK&quot;">​</a></h2><p>一般会将上面JavaScript与客户端的通信进行封装，主要为了</p><ul><li>抹平JSBridge的平台实现差异</li><li>对齐端能力，内部消化版本差异</li><li>sdk封装后的代码更加符合前端习惯</li><li>权限控制、鉴权、对外开放，实现生态建设</li></ul><h2 id="其他问题" tabindex="-1">其他问题 <a class="header-anchor" href="#其他问题" aria-label="Permalink to &quot;其他问题&quot;">​</a></h2><h3 id="判断环境" tabindex="-1">判断环境 <a class="header-anchor" href="#判断环境" aria-label="Permalink to &quot;判断环境&quot;">​</a></h3><p>我们可能需要判断当前页面运行在哪个平台或者是浏览器下，可以通过<code>user-agent</code>进行判断判断</p><h3 id="ios中-wkwebview-和-uiwebview" tabindex="-1">iOS中 WKWebView 和 UIWebview <a class="header-anchor" href="#ios中-wkwebview-和-uiwebview" aria-label="Permalink to &quot;iOS中 WKWebView 和 UIWebview&quot;">​</a></h3><p>参考：</p><ul><li><a href="https://www.jianshu.com/p/79e329ff8953" target="_blank" rel="noreferrer">WKWebView和UIWebView对比</a></li></ul>`,29),r=[l];function n(h,p,o,d,k,c){return e(),i("div",null,r)}const E=a(t,[["render",n]]);export{b as __pageData,E as default};
