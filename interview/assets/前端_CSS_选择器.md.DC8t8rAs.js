import{_ as i,c as s,o as a,a2 as l}from"./chunks/framework.DLPB9-dE.js";const g=JSON.parse('{"title":"选择器","description":"","frontmatter":{},"headers":[],"relativePath":"前端/CSS/选择器.md","filePath":"前端/CSS/选择器.md","lastUpdated":1620234346000}'),t={name:"前端/CSS/选择器.md"},e=l(`<h1 id="选择器" tabindex="-1">选择器 <a class="header-anchor" href="#选择器" aria-label="Permalink to &quot;选择器&quot;">​</a></h1><p>参考之前的整理：</p><ul><li><a href="https://www.shymean.com/article/%E3%80%8ACSS%E6%9D%83%E5%A8%81%E6%8C%87%E5%8D%97%E3%80%8B%E8%AF%BB%E4%B9%A6%E7%AC%94%E8%AE%B0" target="_blank" rel="noreferrer">CSS 权威指南》读书笔记之选择器</a></li></ul><h2 id="选择器类型" tabindex="-1">选择器类型 <a class="header-anchor" href="#选择器类型" aria-label="Permalink to &quot;选择器类型&quot;">​</a></h2><p>选择器指定浏览器对不同的选择器应用不同的样式规则</p><ul><li>语义选择器 <ul><li>元素 <ul><li>标签选择器</li><li>伪元素选择器，<code>:after</code>、<code>:before</code></li><li>通配选择器，<code>*</code></li></ul></li><li>类 <ul><li>类选择器</li><li>伪类选择器，<code>:link</code>,<code>:visited</code>,<code>:hover</code>,<code>:active</code></li></ul></li><li>ID 选择器</li></ul></li><li>属性选择器 <ul><li>简单属性，如<code>a[title]</code></li><li>简单属性，如<code>a[href=&quot;http:www.google.com&quot;]</code></li><li>部分属性，部分属性选择器类似于正则语法，通过属性值的某部分来筛选元素</li></ul></li><li>结构选择器 <ul><li>分组选择器，多个选择器之间使用<code>,</code>进行分隔</li><li>多类选择器，限定只有同时包含这些类名的元素（与类名顺序无关）才能应用对应的声明规则</li></ul></li><li>后代选择器 <ul><li>空格结合符，包含所有后代子元素</li><li>子结合符，<code>&gt;</code></li><li>相邻兄弟结合符，<code>+</code></li></ul></li></ul><p>此外还可以了解 CSS3 新增的一些选择器，如<code>:not</code>、<code>nth-of-type</code>等</p><blockquote><p>伪类和伪元素有什么区别?</p></blockquote><ul><li>伪类本质上是为了弥补常规CSS选择器的不足，以便获取到更多信息；</li><li>伪元素本质上是创建了一个有内容的虚拟容器；</li></ul><p>css3中规定使用<code>::</code>表示伪元素如<code>::after</code>，<code>:</code>表示伪类如<code>:hover</code>，但实际上两种写法都是兼容的</p><p><code>::after</code>和<code>::before</code>的<code>content</code>属性，除了支持文本值外，还可以使用标签的一些属性值，包括自定义属性值，使用方法是<code>attr(href)</code>或者<code>attr(data-*)</code>，用来动态的设定伪类的内容，最常用的地方比如热点排行，消息数量气泡等。</p><h2 id="匹配规则" tabindex="-1">匹配规则 <a class="header-anchor" href="#匹配规则" aria-label="Permalink to &quot;匹配规则&quot;">​</a></h2><p>选择器是<strong>从右向左</strong>进行匹配节点</p><h2 id="样式继承和权重值" tabindex="-1">样式继承和权重值 <a class="header-anchor" href="#样式继承和权重值" aria-label="Permalink to &quot;样式继承和权重值&quot;">​</a></h2><p>参考之前的整理:</p><ul><li><a href="http://www.shymean.com/article/CSS%E7%BB%A7%E6%89%BF%E4%B8%8E%E6%9D%83%E9%87%8D%E5%80%BC" target="_blank" rel="noreferrer">CSS 继承与权重值</a></li></ul><blockquote><p>如果有多条规则应用在同一元素上，则使用层叠解决</p></blockquote><p><strong>继承</strong></p><p>子元素可以从父元素继承属性，样式继承机制是基于元素的，因此不同的元素可继承的样式可能不同，此外也包含一些通用的可继承与不可继承的属性</p><p><strong>权重值计算</strong> 样式表中权重值 ABCD 的比较:</p><ul><li>如果是内联样式，千位+1；</li><li>如果有 id 选择器，百位+1；</li><li>如果有类、伪类或者属性选择器，十位+1；</li><li>如果有标签名或伪元素选择器，个位+1；</li></ul><p>最后依次比较对应位置上的数字大小，需要注意的是并不会十进制进位（不是单纯的比较最后总数大小，虽然书上是这么说的，但是貌似不是完全正确。），也就是说 0，0，1，0 与 0，0，0，11 比较的话，前者的权重值仍然比后面高（但是一般应该没有连续嵌套 11 个标签名的做法吧，大概会被打死的...）</p><ul><li>对于<code>!important</code>，其权重值非常高，当纯在多个important时，将在这些多个important的属性中按照上述计算公式计算比较</li><li>当多个规则应用在同一个元素上时，权重越高的样式将被优先采用</li><li>当权重值相同的时候，在样式表中后定义的样式将覆盖先前定义的样式</li></ul><p><strong>注意</strong></p><p>需要理解的是，<strong>继承而来的属性值权重值是非常低的，权重值永远低于明确指定到元素的定义，甚至低于通配符</strong>。</p><p>只有当一个元素的某个属性没有被直接指定时，才会继承父级元素的值，也就是说可以使用一个更“具体的”选择符属性覆盖继承自祖先的属性而忽略权重值的问题。</p><div class="language-html vp-adaptive-theme"><button title="Copy Code" class="copy"></button><span class="lang">html</span><pre class="shiki shiki-themes github-light github-dark vp-code"><code><span class="line"><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">&lt;</span><span style="--shiki-light:#22863A;--shiki-dark:#85E89D;">style</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">&gt;</span></span>
<span class="line"><span style="--shiki-light:#6F42C1;--shiki-dark:#B392F0;">    #r</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;"> { </span><span style="--shiki-light:#005CC5;--shiki-dark:#79B8FF;">color</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">：</span><span style="--shiki-light:#005CC5;--shiki-dark:#79B8FF;">red</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;"> }</span></span>
<span class="line"><span style="--shiki-light:#22863A;--shiki-dark:#85E89D;">    span</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;"> { </span><span style="--shiki-light:#005CC5;--shiki-dark:#79B8FF;">color</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">:</span><span style="--shiki-light:#005CC5;--shiki-dark:#79B8FF;">blue</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;"> }</span></span>
<span class="line"><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">&lt;/</span><span style="--shiki-light:#22863A;--shiki-dark:#85E89D;">style</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">&gt;</span></span>
<span class="line"></span>
<span class="line"><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">&lt;</span><span style="--shiki-light:#22863A;--shiki-dark:#85E89D;">p</span><span style="--shiki-light:#6F42C1;--shiki-dark:#B392F0;"> id</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">=</span><span style="--shiki-light:#032F62;--shiki-dark:#9ECBFF;">&quot;r&quot;</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">&gt;&lt;</span><span style="--shiki-light:#22863A;--shiki-dark:#85E89D;">span</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">&gt; hello&lt;/</span><span style="--shiki-light:#22863A;--shiki-dark:#85E89D;">span</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">&gt;&lt;/</span><span style="--shiki-light:#22863A;--shiki-dark:#85E89D;">p</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">&gt;</span></span></code></pre></div><p>尽管前者的权重值远大于后者，但是 span 里面的字体颜色仍然是蓝色。</p><h2 id="顺序选择器" tabindex="-1">顺序选择器 <a class="header-anchor" href="#顺序选择器" aria-label="Permalink to &quot;顺序选择器&quot;">​</a></h2><p>顺序选择器<code>nth-of-type(an+b)</code>和 <code>nth-child(an+b)</code>等计算规则</p><h3 id="nth-child" tabindex="-1"><strong>nth-child</strong> <a class="header-anchor" href="#nth-child" aria-label="Permalink to &quot;**nth-child**&quot;">​</a></h3><p>参考<a href="https://developer.mozilla.org/zh-CN/docs/Web/CSS/:nth-child" target="_blank" rel="noreferrer">MDN 文档</a></p><p>首先找到所有当前元素的兄弟元素，然后按照位置先后顺序从1开始排序，选择的结果为CSS伪类:nth-child括号中表达式（an+b）匹配到的元素集合（n=0，1，2，3...）</p><blockquote><p>这个 CSS 伪类匹配文档树中在其之前具有 an+b-1 个兄弟节点的元素，其中 n 为正值或零值。</p></blockquote><p>简单点说就是，这个选择器匹配那些在同系列兄弟节点中的位置与模式 an+b 匹配的元素，其索引从 1 开始·</p><p>需要注意a为负数的情况，如<code>nth-child(-n+3)</code>表示匹配前三个元素，看下面的代码</p><div class="language-css vp-adaptive-theme"><button title="Copy Code" class="copy"></button><span class="lang">css</span><pre class="shiki shiki-themes github-light github-dark vp-code"><code><span class="line"><span style="--shiki-light:#22863A;--shiki-dark:#85E89D;">div</span><span style="--shiki-light:#22863A;--shiki-dark:#85E89D;"> span</span><span style="--shiki-light:#6F42C1;--shiki-dark:#B392F0;">:nth-child</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">(</span><span style="--shiki-light:#005CC5;--shiki-dark:#79B8FF;">-n+2</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">){</span></span>
<span class="line"><span style="--shiki-light:#6A737D;--shiki-dark:#6A737D;">    /* 根据规则，先找到所有的兄弟节点，然后n从0开始+1递增，找到 0 &lt; 表达式 &amp;&amp; 表达式 &lt;= 兄弟节点长度的值 &gt; */</span></span>
<span class="line"><span style="--shiki-light:#6A737D;--shiki-dark:#6A737D;">    /* 因此此处 索引值为2,1的元素满足条件 */</span></span>
<span class="line"><span style="--shiki-light:#005CC5;--shiki-dark:#79B8FF;">    background-color</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">: </span><span style="--shiki-light:#005CC5;--shiki-dark:#79B8FF;">blue</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">;</span></span>
<span class="line"><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">}</span></span>
<span class="line"><span style="--shiki-light:#22863A;--shiki-dark:#85E89D;">div</span><span style="--shiki-light:#22863A;--shiki-dark:#85E89D;"> span</span><span style="--shiki-light:#6F42C1;--shiki-dark:#B392F0;">:nth-child</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">(</span><span style="--shiki-light:#005CC5;--shiki-dark:#79B8FF;">-2n+2</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">){</span></span>
<span class="line"><span style="--shiki-light:#6A737D;--shiki-dark:#6A737D;">    /* 此处只有 n=0时 索引值为2的元素满足条件，当n为1时，获取的索引值为0，不再参与匹配 */</span></span>
<span class="line"><span style="--shiki-light:#005CC5;--shiki-dark:#79B8FF;">    background-color</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">: </span><span style="--shiki-light:#005CC5;--shiki-dark:#79B8FF;">red</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">;</span></span>
<span class="line"><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">}</span></span></code></pre></div><h3 id="nth-of-type" tabindex="-1"><strong>nth-of-type</strong> <a class="header-anchor" href="#nth-of-type" aria-label="Permalink to &quot;**nth-of-type**&quot;">​</a></h3><p>参考<a href="https://developer.mozilla.org/zh-CN/docs/Web/CSS/:nth-of-type" target="_blank" rel="noreferrer">MDN 文档</a></p><p>与<code>nth-child</code>匹配原理基本相同，区别在于只有类型相同参与索引值排序和计算</p><blockquote><p>这个 CSS 伪类 匹配那些在它之前有 an+b-1 个相同类型兄弟节点的元素，其中 n 为正值或零值。</p></blockquote><p>匹配同类型的兄弟元素中对应索引的元素，索引从 1 开始</p><h3 id="nth-last-child" tabindex="-1"><strong>nth-last-child</strong> <a class="header-anchor" href="#nth-last-child" aria-label="Permalink to &quot;**nth-last-child**&quot;">​</a></h3><p>参考<a href="https://developer.mozilla.org/zh-CN/docs/Web/CSS/:nth-last-child" target="_blank" rel="noreferrer">MDN 文档</a></p><p>从兄弟节点中从后往前匹配处于某些位置的元素，其他规则与<code>nth-child</code>基本一致。</p><p>需要注意<code>:nth-last-child(n)</code> 与 <code>:nth-last-child(n+1)</code>均表示匹配的是每一个节点，这同样是因为表达式的有效值是从1开始计算的</p><h3 id="nth-last-of-type" tabindex="-1"><strong>nth-last-of-type</strong> <a class="header-anchor" href="#nth-last-of-type" aria-label="Permalink to &quot;**nth-last-of-type**&quot;">​</a></h3><p>同上</p>`,48),n=[e];function h(p,o,d,r,k,c){return a(),s("div",null,n)}const y=i(t,[["render",h]]);export{g as __pageData,y as default};
