import{_ as a,c as e,o as r,a2 as t}from"./chunks/framework.DLPB9-dE.js";const f=JSON.parse('{"title":"","description":"","frontmatter":{},"headers":[],"relativePath":"数据结构和算法/README.md","filePath":"数据结构和算法/README.md","lastUpdated":1709648798000}'),l={name:"数据结构和算法/README.md"},p=t('<h2 id="数据结构和算法" tabindex="-1">数据结构和算法 <a class="header-anchor" href="#数据结构和算法" aria-label="Permalink to &quot;数据结构和算法&quot;">​</a></h2><p>谁说前端不需要算法？</p><p>参考：</p><ul><li><a href="https://www.algomooc.com/" target="_blank" rel="noreferrer">algomooc</a></li><li><a href="https://labuladong.gitbook.io/algo/" target="_blank" rel="noreferrer">labuladong</a></li><li><a href="https://juejin.im/post/5d5b307b5188253da24d3cd1#heading-41" target="_blank" rel="noreferrer">前端该如何准备数据结构和算法？</a></li><li><a href="https://leetcode-cn.com/explore/" target="_blank" rel="noreferrer">LeetCode 探索</a>，强烈推荐按课程学习</li></ul><h2 id="数据结构" tabindex="-1">数据结构 <a class="header-anchor" href="#数据结构" aria-label="Permalink to &quot;数据结构&quot;">​</a></h2><p>常见的数据结构有</p><ul><li>有序数据结构：栈、队列、链表，有序数据结构省空间（存储空间小）</li><li>无序数据结构：集合、字典、散列表，无序数据结构省时间（读取时间快）</li><li>复杂数据结构，树、堆、图</li></ul><p>首先需要学习数据存储最基础的两种数据结构：<a href="./数组.html">数组</a>和<a href="./链表.html">链表</a>，对应有序数据结构和无序数据结构两种类型</p><p>然后了解栈、队列、树、堆等数据结构，他们都是由数组或者链表实现的</p><p>一般的算法题，就是对这些数据结构的操作，归根到底就是基础的增删查改</p><p>这些操作或多或少都涉及到遍历 + 访问</p><p>遍历有线性和非线性两种方式，线性的就是for、while循环，非线性的就是递归。</p><ul><li>递归主体，就是要循环解决问题的代码</li><li>递归的跳出条件，递归不能一直递归下去，需要完成一定条件后跳出</li></ul><p>递归容易造成爆栈，尾部调用可以解决递归的这个问题</p><h2 id="常见解题思想" tabindex="-1">常见解题思想 <a class="header-anchor" href="#常见解题思想" aria-label="Permalink to &quot;常见解题思想&quot;">​</a></h2><p>分治 (Divide and Conquer): 分治是一种将问题分解成更小的子问题，然后解决子问题并将结果合并起来得到原问题解的方法。</p><p>贪心算法（Greedy Algorithm）：贪心算法是一种在每一步都选择当前状态下最优解的策略，以期望最终达到全局最优解。贪心算法通常适用于具有最优子结构的问题，即问题的最优解可以通过子问题的最优解来求解。</p><p>动态规划（Dynamic Programming）：动态规划是一种通过将问题分解成子问题并记录子问题的解来避免重复计算的方法。动态规划通常用于解决具有重叠子问题和最优子结构性质的问题。</p><p>回溯算法（Backtracking）：回溯算法是一种通过尝试所有可能的解决方案并在搜索过程中剪枝来找到问题的解的方法。回溯算法通常适用于组合优化问题、排列组合问题等。</p><p>深度优先搜索（Depth-First Search，DFS）：深度优先搜索是一种通过不断深入到问题的解空间中，直到找到问题的解或者无法继续搜索为止的方法。DFS通常用于图遍历、树遍历等问题。</p><p>广度优先搜索（Breadth-First Search，BFS）：广度优先搜索是一种从问题的起始状态开始逐层扩展搜索，直到找到问题的解或者搜索完整个解空间为止的方法。BFS通常用于寻找最短路径、图的连通性等问题。</p><p>分支限界法（Branch and Bound）：分支限界法是一种通过扩展当前最有希望的解决方案并剪枝来搜索问题解空间的方法。它通常用于组合优化、排列组合等问题。</p><p>双指针法（Two Pointers）：双指针法是一种通过使用两个指针在数组或者列表中移动来解决问题的方法。它通常用于查找滑动窗口、快速求解两数之和等问题。</p><h2 id="算法复杂度" tabindex="-1">算法复杂度 <a class="header-anchor" href="#算法复杂度" aria-label="Permalink to &quot;算法复杂度&quot;">​</a></h2><p>参考：<a href="https://zhuanlan.zhihu.com/p/50479555" target="_blank" rel="noreferrer">算法的时间与空间复杂度（一看就懂）</a></p><p>复杂度主要从算法所占用的「时间」和「空间」两个维度去考量</p><h3 id="时间复杂度" tabindex="-1">时间复杂度 <a class="header-anchor" href="#时间复杂度" aria-label="Permalink to &quot;时间复杂度&quot;">​</a></h3><p>时间复杂度用来衡量算法的运行次数。</p><p>常见的时间复杂度量级有：</p><p>常数阶O(1)</p><p>对数阶O(logN)</p><p>线性阶O(n)</p><p>线性对数阶O(nlogN)</p><p>平方阶O(n²)</p><p>立方阶O(n³)</p><p>K次方阶O(n^k)</p><p>指数阶(2^n)</p><h3 id="空间复杂度" tabindex="-1">空间复杂度 <a class="header-anchor" href="#空间复杂度" aria-label="Permalink to &quot;空间复杂度&quot;">​</a></h3><p>空间复杂度是对一个算法在运行过程中临时占用存储空间大小的一个量度</p>',39),o=[p];function i(n,h,d,c,s,_){return r(),e("div",null,o)}const m=a(l,[["render",i]]);export{f as __pageData,m as default};
