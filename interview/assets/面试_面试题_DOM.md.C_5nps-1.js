import{_ as a,c as e,o,a2 as s}from"./chunks/framework.DLPB9-dE.js";const h=JSON.parse('{"title":"","description":"","frontmatter":{},"headers":[],"relativePath":"面试/面试题/DOM.md","filePath":"面试/面试题/DOM.md","lastUpdated":1575336317000}'),l={name:"面试/面试题/DOM.md"},t=s('<h2 id="请描述cookie-sessionstorage-localstorage的区别" tabindex="-1">请描述<code>Cookie</code>，<code>sessionStorage</code>，<code>localStorage</code>的区别 <a class="header-anchor" href="#请描述cookie-sessionstorage-localstorage的区别" aria-label="Permalink to &quot;请描述`Cookie`，`sessionStorage`，`localStorage`的区别&quot;">​</a></h2><p>相同： 都是保存在浏览器，且同源的。</p><p>区别：</p><ul><li><p>cookies 和 Storage 的区别：</p><ul><li>cookies会在服务器端和客户端间传递的；sessionStorage 和 localStorage存放在客户端的，不会发送至服务器端，仅在本地保存。</li><li>cookies的兼容主流浏览器,包括IE6+;IE6，IE7不支持sessionStorage 和 localStorage sessionStorage 和 localStorage中能存的数据比cookie大（cookie不能超过4k）</li></ul></li><li><p>sessionStorage 和 localStorage的区别：</p><ul><li>sessionStorage存的数据在每次关闭浏览器后被删除，localStorage不会。</li><li>作用域不同，sessionStorage不在不同的浏览器窗口中共享，即使是同一个页面；localStorage 在所有同源窗口中都是共享的；cookie也是在所有同源窗口中都是共享的</li></ul></li></ul><h2 id="事件委托" tabindex="-1">事件委托 <a class="header-anchor" href="#事件委托" aria-label="Permalink to &quot;事件委托&quot;">​</a></h2><p>一个定时器，定时向容器插入<code>a</code>标签，要求任何时刻点击<code>a</code>标签都弹出对应数据，复习事件委托</p><div class="language- vp-adaptive-theme"><button title="Copy Code" class="copy"></button><span class="lang"></span><pre class="shiki shiki-themes github-light github-dark vp-code"><code><span class="line"><span>t.onclick = function(e){</span></span>\n<span class="line"><span>    var target = e.target</span></span>\n<span class="line"><span>    if (target.tagName.toUpperCase() == &quot;A&quot;){</span></span>\n<span class="line"><span>    	alert(target.innerHTML);</span></span>\n<span class="line"><span>    }</span></span>\n<span class="line"><span>}</span></span></code></pre></div><h2 id="常见的web安全问题" tabindex="-1">常见的Web安全问题 <a class="header-anchor" href="#常见的web安全问题" aria-label="Permalink to &quot;常见的Web安全问题&quot;">​</a></h2><p>XSS是跨站脚本攻击，指的是在用户浏览器渲染整个HTML文档过程中出现了不被预期的脚本指令。常见的处理措施有</p><ul><li><p>过滤用户的输入，对输出到页面的文档进行转义，可有效防止反射XSS和存储XSS</p></li><li><p>要尽力避免代码中比较常规的一些安全漏洞，比如eval等。</p></li><li><p>输入校验，包括长度限制、值类型是否正确，是否包含特殊字符</p></li><li><p>输出编码，根据输出位置进行相应的编码，遵守该数据不要超出自己所在的区域，也不要被当作指令执行</p></li></ul><p>CSRF是跨站请求伪造，攻击的发生是由各种请求造成的，对于CSRF来说，它的请求有两个关键点，跨站点和请求伪造。诱导用户访问恶意网站，并构造一个正常请求，由于正常请求会携带用户身份信息，就可以发生攻击了。常见的处理措施有</p><ul><li>检验referrer</li><li>使用随机生成的一次性token，然后对提交的请求进行校验</li></ul><p>扩展：</p><ul><li>在项目中有没有遇到什么安全漏洞的问题</li></ul>',14),i=[t];function n(p,c,r,d,g,u){return o(),e("div",null,i)}const _=a(l,[["render",n]]);export{h as __pageData,_ as default};
