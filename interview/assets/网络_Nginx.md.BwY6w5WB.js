import{_ as a,c as i,o as l,a2 as e}from"./chunks/framework.DLPB9-dE.js";const m=JSON.parse('{"title":"网络服务器响应","description":"","frontmatter":{},"headers":[],"relativePath":"网络/Nginx.md","filePath":"网络/Nginx.md","lastUpdated":null}'),t={name:"网络/Nginx.md"},n=e(`<h1 id="网络服务器响应" tabindex="-1">网络服务器响应 <a class="header-anchor" href="#网络服务器响应" aria-label="Permalink to &quot;网络服务器响应&quot;">​</a></h1><p>一般的做法是每有一个客户端连接进来，就fork一个新的服务器程序，如PHP</p><ul><li>服务器程序包含两个模块，等待连接模块和负责与客户端通信的模块</li><li>服务器启动后完成初始化操作，运行等待模块，创建套接字，等待客户端的连接</li><li>接收到客户端连接时，等待模块会恢复运行并接收连接，然后启动服务器的客户端通信模块，并移交完成连接的套接字</li><li>每次有新的客户端发起连接，都会启动一个新的客户端通信模块（这个过程需要消耗服务器性能），因此通信模块与客户端是一对一的关系</li></ul><h1 id="nginx" tabindex="-1">nginx <a class="header-anchor" href="#nginx" aria-label="Permalink to &quot;nginx&quot;">​</a></h1><ul><li><a href="https://mp.weixin.qq.com/s/BA_JZ_kMBFZBE7jjQDNc1Q" target="_blank" rel="noreferrer">前端开发者必备的 Nginx 知识</a></li></ul><h2 id="代理" tabindex="-1">代理 <a class="header-anchor" href="#代理" aria-label="Permalink to &quot;代理&quot;">​</a></h2><p>正向代理是为我们服务的，即为客户端服务的，客户端可以根据正向代理访问到它本身无法访问到的服务器资源。</p><p>正向代理对我们是透明的，对服务端是非透明的，即服务端并不知道自己收到的是来自代理的访问还是来自真实客户端的访问。</p><p>反向代理是为服务端服务的，反向代理可以帮助服务器接收来自客户端的请求，帮助服务器做请求转发，负载均衡等。</p><p>反向代理对服务端是透明的，对我们是非透明的，即我们并不知道自己访问的是代理服务器，而服务器知道反向代理在为他服务。</p><h2 id="location匹配" tabindex="-1">location匹配 <a class="header-anchor" href="#location匹配" aria-label="Permalink to &quot;location匹配&quot;">​</a></h2><p>参考</p><ul><li><a href="https://segmentfault.com/a/1190000013267839" target="_blank" rel="noreferrer">一文弄懂Nginx的location匹配</a></li></ul><p>多个项目共用同一个域名时，往往需要根据url将请求转发到不同的项目上，此时需要配置location</p><div class="language- vp-adaptive-theme"><button title="Copy Code" class="copy"></button><span class="lang"></span><pre class="shiki shiki-themes github-light github-dark vp-code"><code><span class="line"><span>location [ = | ~ | ~* | ^~ ] uri { ... }</span></span>
<span class="line"><span>location @name { ... }</span></span></code></pre></div><p>修饰符的含义</p><ul><li>= 表示精确匹配。只有请求的url路径与后面的字符串完全相等时，才会命中。</li><li>~ 表示该规则是使用正则定义的，区分大小写。</li><li>~* 表示该规则是使用正则定义的，不区分大小写。</li><li>^~ 表示如果该符号后面的字符是最佳匹配，采用该规则，不再进行后续的查找。</li></ul><p>具体的匹配过程为</p><ul><li>首先先检查使用前缀字符定义的location，选择最长匹配的项并记录下来。</li><li>如果找到了精确匹配的location，也就是使用了=修饰符的location，结束查找，使用它的配置。</li><li>然后按顺序查找使用正则定义的location，如果匹配则停止查找，使用它定义的配置。</li><li>如果没有匹配的正则location，则使用前面记录的最长匹配前缀字符location。</li></ul><p>小结</p><ul><li>location的配置有两种形式，前缀字符和正则。查找匹配的时候，先查找前缀字符，选择最长匹配项，再查找正则。正则的优先级高于前缀字符。</li><li>正则的查找是按照在配置文件中的顺序进行的。因此正则的顺序很重要，建议越精细的放的越靠前。</li><li>使用=精准匹配可以加快查找的顺序，如果根域名经常被访问的话建议使用=</li></ul><h2 id="rewrite" tabindex="-1">rewrite <a class="header-anchor" href="#rewrite" aria-label="Permalink to &quot;rewrite&quot;">​</a></h2>`,22),o=[n];function r(s,c,p,h,d,u){return l(),i("div",null,o)}const g=a(t,[["render",r]]);export{m as __pageData,g as default};
