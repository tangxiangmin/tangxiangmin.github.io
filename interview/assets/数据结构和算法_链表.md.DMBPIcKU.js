import{_ as e,c as a,o as l,a2 as t}from"./chunks/framework.DLPB9-dE.js";const _=JSON.parse('{"title":"链表","description":"","frontmatter":{},"headers":[],"relativePath":"数据结构和算法/链表.md","filePath":"数据结构和算法/链表.md","lastUpdated":1709648798000}'),r={name:"数据结构和算法/链表.md"},i=t('<h1 id="链表" tabindex="-1">链表 <a class="header-anchor" href="#链表" aria-label="Permalink to &quot;链表&quot;">​</a></h1><h2 id="链表-1" tabindex="-1">链表 <a class="header-anchor" href="#链表-1" aria-label="Permalink to &quot;链表&quot;">​</a></h2><p>主要考察</p><ul><li>链表的遍历</li><li>有环链表</li><li>双指针</li></ul><h3 id="从后向前遍历单链表" tabindex="-1">从后向前遍历单链表 <a class="header-anchor" href="#从后向前遍历单链表" aria-label="Permalink to &quot;从后向前遍历单链表&quot;">​</a></h3><p>从前向后遍历时，使用一个队列来保存遍历的节点，每次从头部插入新节点</p><p>该方法可以实现翻转链表</p><h3 id="o-1-时间内删除链表中的指定节点" tabindex="-1">O(1)时间内删除链表中的指定节点 <a class="header-anchor" href="#o-1-时间内删除链表中的指定节点" aria-label="Permalink to &quot;O(1)时间内删除链表中的指定节点&quot;">​</a></h3><ul><li>删除的节点不是尾部节点： 使用待删除的节点的next节点值覆盖当前节点值，然后删除下一个节点</li><li>删除的节点是尾部节点且等于头节点，只剩一个节点 ： 将头节点置为null</li><li>删除的节点是尾节点且前面还有节点：遍历到末尾的前一个节点删除</li></ul><h3 id="复制带随机指针的链表" tabindex="-1">复制带随机指针的链表 <a class="header-anchor" href="#复制带随机指针的链表" aria-label="Permalink to &quot;复制带随机指针的链表&quot;">​</a></h3><p><a href="https://leetcode-cn.com/explore/learn/card/linked-list/197/conclusion/766/" target="_blank" rel="noreferrer">letcode传送门</a></p><ul><li>首先通过next遍历链表，使用一个栈st保存每个节点</li><li>然后使用st克隆一堆链表节点nodes，不带next和random属性</li><li>遍历st，根据<code>st.indexOf</code>扎到随机节点的索引值index，依次设置每个节点的random为nodes[index]和next为nodes[i+1]</li></ul><h3 id="判断链表是否有环" tabindex="-1">判断链表是否有环 <a class="header-anchor" href="#判断链表是否有环" aria-label="Permalink to &quot;判断链表是否有环&quot;">​</a></h3><p>使用快慢指针，快指针每次移动两步、慢指针每次移动一步，如果在某个时刻快慢指针重合则表示有环</p><h3 id="如果链表有环-找到入环节点" tabindex="-1">如果链表有环，找到入环节点 <a class="header-anchor" href="#如果链表有环-找到入环节点" aria-label="Permalink to &quot;如果链表有环，找到入环节点&quot;">​</a></h3><p><a href="https://leetcode-cn.com/explore/learn/card/linked-list/194/two-pointer-technique/745/" target="_blank" rel="noreferrer">letcode传送门</a></p><ul><li>首先使用快慢指针判断有环，并从第一次相遇的节点开始进行标记count，</li><li>然后继续循环count++至第二次相遇时，此时count表示的就是环的长度</li><li>得到环的长度之后，将快慢指针同时指向head，并将快指针提前移动count步，后续每次循环时快慢指针都走一步，下次相遇时则为开始起环的节点</li></ul><h3 id="约瑟夫环" tabindex="-1">约瑟夫环 <a class="header-anchor" href="#约瑟夫环" aria-label="Permalink to &quot;约瑟夫环&quot;">​</a></h3><blockquote><p>0,1,...,n-1这n个数字排成一个圆圈，从数字0开始，每次从这个圆圈里删除第m个数字。求出这个圆圈里剩下的最后一个数字。</p></blockquote><ul><li>用链表模拟一个环</li><li>模拟游戏场景</li><li>记录头节点的前一个节点current，以保证我们找到的要删除的节点是current.next</li><li>每次循环m次找到目标节点删除，直到链表只剩下一个节点</li></ul><p>参考:<a href="https://mp.weixin.qq.com/s/xBiQHKdSop1HzKTF7EVhCQ" target="_blank" rel="noreferrer">数组、链表、递归三种方式解决约瑟夫环</a></p><h3 id="判断链表是否相交" tabindex="-1">判断链表是否相交 <a class="header-anchor" href="#判断链表是否相交" aria-label="Permalink to &quot;判断链表是否相交&quot;">​</a></h3><p><a href="https://leetcode-cn.com/explore/learn/card/linked-list/194/two-pointer-technique/746/" target="_blank" rel="noreferrer">https://leetcode-cn.com/explore/learn/card/linked-list/194/two-pointer-technique/746/</a></p><p>把两个单链表看作是两段线段，以两条线段相加的和不变这个条件，分别遍历两个链表。</p><p>参考: <a href="https://blog.csdn.net/qq_34364995/article/details/80518198" target="_blank" rel="noreferrer">https://blog.csdn.net/qq_34364995/article/details/80518198</a></p><p><img src="http://ww4.sinaimg.cn/large/006tNc79gy1g4adqu9i8hj31bq0q2tuc.jpg" alt=""></p><p>现有线段ACD和线段BCD，两条线段相交于C点。同时从A、B分别开始遍历ACD和BCD，遍历点记为PA和PB，经过的长度用len记录，遍历步长为1。当PA遍历到D时，PB在I，此时len为5。由于ACD已经遍历完，PA就跳到B点开始遍历BCD。当BCD遍历完时，PB跳转到A。</p><p>分解一下PA和PB的遍历轨迹就是，</p><ul><li>PA：AECHIDBFGC。</li><li>PB：BFGCHIDAEC。</li></ul><h3 id="两个链表的公共节点" tabindex="-1">两个链表的公共节点 <a class="header-anchor" href="#两个链表的公共节点" aria-label="Permalink to &quot;两个链表的公共节点&quot;">​</a></h3><p>使用快慢指针</p><ul><li>先找到两个链表的长度length1、length2</li><li>让长一点的链表先走length2-length1步，让长链表和短链表起点相同</li><li>两个链表一起前进，比较获得第一个相等的节点</li></ul><h3 id="删除倒数第k个节点" tabindex="-1">删除倒数第k个节点 <a class="header-anchor" href="#删除倒数第k个节点" aria-label="Permalink to &quot;删除倒数第k个节点&quot;">​</a></h3><p>先遍历获取链表的长度len，然后再遍历到len-k处删除节点，需遍历两次</p><p>可以优化为：使用快慢指针，快指针先移动k步，然后快慢指针一起移动，当快指针到达末尾时，慢指针对应的就是第k个节点</p>',35),n=[i];function o(h,c,d,s,p,u){return l(),a("div",null,n)}const b=e(r,[["render",o]]);export{_ as __pageData,b as default};
