import{_ as e,c as a,o as p,a2 as l}from"./chunks/framework.DLPB9-dE.js";const _=JSON.parse('{"title":"","description":"","frontmatter":{},"headers":[],"relativePath":"网络/网络层.md","filePath":"网络/网络层.md","lastUpdated":1709042257000}'),i={name:"网络/网络层.md"},o=l('<h2 id="ip协议" tabindex="-1">IP协议 <a class="header-anchor" href="#ip协议" aria-label="Permalink to &quot;IP协议&quot;">​</a></h2><p>IP是一种网络协议，它定义了在互联网上进行数据通信的规则。</p><p>每个设备（如计算机、服务器、路由器等）在网络中都被分配一个唯一的IP地址，用于标识和寻址。</p><p>IP地址由一系列数字组成，例如IPv4使用32位地址，而IPv6使用128位地址。</p><p>IP协议使用路由选择算法来确定数据包从源设备到目标设备的最佳路径。</p><p>路由选择是基于路由器维护的路由表，该表存储了网络的拓扑结构和路由信息。</p><p>路由器根据目标IP地址来选择下一跳路由器，将数据包沿着网络传递，最终将数据传递到目标设备上。</p><h3 id="ipv4" tabindex="-1">IPv4 <a class="header-anchor" href="#ipv4" aria-label="Permalink to &quot;IPv4&quot;">​</a></h3><p>IPv4是目前广泛使用的版本，IPv4使用32位地址，如<code>192.168.0.1</code>。</p><p>地址的范围是<code>0.0.0.0</code>到<code>255.255.255.255</code>，因此理论上最多有255^4个地址，约42.28亿个，随着日益增长的互联网设别，这个数量肯定不够用了。</p><p>为了解决这个问题，人们将网络分成了内部网络和外部网络，</p><ul><li>内网-&gt;家里、公里里、小区里的局域网，他们必须要通过路由器连接外网才能使用</li><li>外网-&gt;全球唯一的真实可用的IP地址，也就是真正的互联网的地址</li></ul><p>这样，整个局域网只需要一个真实的IP地址就可以接入互联网；而对于内网而言，有一部分地址范围被保留用于内部网络，不会被分配给互联网上的设备。</p><p>私有 IP 地址的范围包括：</p><ul><li><code>10.0.0.0</code> 到 <code>10.255.255.255</code></li><li><code>172.16.0.0</code> 到 <code>172.31.255.255</code></li><li><code>192.168.0.0</code> 到 <code>192.168.255.255</code></li></ul><p>为了让内部网络中的设备与互联网通信，通常会使用网络地址转换（NAT）技术，将私有 IP 地址转换为一个公共 IP 地址，以便与互联网上的其他设备进行通信。</p><p>此外，每个机器上还有一个特殊的IP地址<code>127.0.0.1</code>，用于表示本地主机（localhost）。这个地址通常被称为回环地址（loopback address），用于在本地设备上进行网络测试和通信。它永远指向设备自身，用于访问设备上的本地服务或测试网络功能，而不会通过网络传输数据。</p><h3 id="ipv6" tabindex="-1">IPv6 <a class="header-anchor" href="#ipv6" aria-label="Permalink to &quot;IPv6&quot;">​</a></h3><p>IPv6提供了更大的地址空间、改进的安全性和更好的支持移动设备等特性。</p><p>Pv6使用128位地址，如2001:0db8:85a3:0000:0000:8a2e:0370:7334。</p><p>理论上有2^128个IPv6地址，大约几百万亿，号称可以让地球上的每一粒沙都能享有一个IP地址。</p><h3 id="dns" tabindex="-1">DNS <a class="header-anchor" href="#dns" aria-label="Permalink to &quot;DNS&quot;">​</a></h3><p>DNS（Domain Name System）是因特网上的目录服务。</p><p>服务器可以通过多种方式进行标识</p><ul><li>主机名更容易被人们接受（www.foo.com），但是却没有提供多少该服务器在互联网中的位置。</li><li>在网络传输中路由器使用的是服务器IP地址来表明他自身的位置</li></ul><p>人们更喜欢好记的主机名，而路由器更喜欢定长的有层次结构的IP。因此需要一种进行主机名到IP地址转换的目录服务：DNS（又是一个新的适配器，避免服务器更改之后用户就找不到原来的服务了。</p><p>当在浏览器地址栏中输入域名后，下面是简单的DNS工作流程：</p><ul><li>浏览器从URL中抽取出主机名，并将主机名传递给DNS客户端（就运行在该主机上）</li><li>DNS客户端向DNS服务器发送解析主机名的请求报文</li><li>DNS服务器返回包含对应主机名的IP的响应报文，并被DNS客户端接受。</li><li>DNS向浏览器提供相应主机名的IP地址。浏览器向位于该IP地址的服务器发送请求报文并建立TCP连接。</li></ul><p>为了处理扩展性问题，DNS使用了大量的DNS服务器，并以层次方式组织这些服务器，通常包括：</p><ul><li>根DNS服务器</li><li>顶级域服务器</li><li>权威DNS服务器</li><li>本地DNS服务器</li></ul><p>没有任何一台DNS服务器保存了因特网上全部主机的IP映射。通过递归和迭代查询主机名对应的IP地址并返回给浏览器。</p><p>为了改善时延性能并减少DNS报文数量，DNS广发使用缓存技术。每当本地DNS服务器从某个DNS服务器接收到响应报文后，就将相应的主机名和IP地址保存起来，接下来的一段时间内接受到相应的解析请求就直接返回该IP地址，而不必再查询其他DNS服务器</p><p>一般来说有下面两种查询方式</p><ul><li>迭代查询， A问B一个问题，B不知道答案说你可以问C，然后A再去问C，C推荐D，然后A继续问D，如此迭代…</li><li>递归查询，A问B一个问题，B问C，C问D… 然后D告诉C，C告诉B，B告诉A</li></ul><h2 id="路由器寻址" tabindex="-1">路由器寻址 <a class="header-anchor" href="#路由器寻址" aria-label="Permalink to &quot;路由器寻址&quot;">​</a></h2><p>当路由器的一个接口收到一个数据包时，它首先要检查数据包的目标IP地址，以确定数据包的目标网络。</p><p>路由器内部维护着一个路由表，其中包含了目标网络和下一跳的信息。</p><p>路由器使用目标IP地址与路由表进行匹配，以找到数据包的下一跳的MAC地址。</p><p>IP协议可以根据IP地址来查找包的传输方向，从而确定下一个路由器的位置，因此在传输过程中，IP头部是不会变化的，而MAC头部的信息会随着到达的路由器而改变。</p><p>一旦路由器确定了数据包的下一跳，它会将数据包转发到与下一跳相连的网络。这个过程通常涉及到修改数据链路层头部信息（例如，更新源和目标的MAC地址）。</p><p>在下一跳网络上，接收路由器的下一个路由器（或目标设备）会继续执行相同的过程，检查目标IP地址，查找路由表，进行ARP解析，然后转发数据包,直到数据包到达目标网络。</p><p>在目标网络内，目标设备或路由器最终接收并处理数据包，通过ARP协议找到目标设备的MAC地址，然后通过目标网络内的交换机传输到具体设备上面。</p>',42),t=[o];function d(P,c,r,I,s,n){return p(),a("div",null,t)}const D=e(i,[["render",d]]);export{_ as __pageData,D as default};
