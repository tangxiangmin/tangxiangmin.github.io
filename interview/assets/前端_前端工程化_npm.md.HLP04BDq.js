import{_ as a,c as e,o as n,a2 as s}from"./chunks/framework.DLPB9-dE.js";const g=JSON.parse('{"title":"","description":"","frontmatter":{},"headers":[],"relativePath":"前端/前端工程化/npm.md","filePath":"前端/前端工程化/npm.md","lastUpdated":1684907685000}'),p={name:"前端/前端工程化/npm.md"},l=s(`<p>参考</p><ul><li><a href="https://juejin.im/post/5ab3f77df265da2392364341" target="_blank" rel="noreferrer">2018 年了，你还是只会 npm install 吗</a>，这篇文章讲的很全，不妨移步阅读</li></ul><h2 id="相关概念" tabindex="-1">相关概念 <a class="header-anchor" href="#相关概念" aria-label="Permalink to &quot;相关概念&quot;">​</a></h2><p>CommonJS、AMD、CMD、UMD、ES6各种规范</p><p>已整理至博客<a href="https://www.shymean.com/article/JavaScript%E6%A8%A1%E5%9D%97%E7%AE%A1%E7%90%86%E6%9C%BA%E5%88%B6" target="_blank" rel="noreferrer">JavaScript模块管理机制</a></p><h3 id="模块与包" tabindex="-1">模块与包 <a class="header-anchor" href="#模块与包" aria-label="Permalink to &quot;模块与包&quot;">​</a></h3><p>参考：<a href="https://docs.npmjs.com/about-packages-and-modules" target="_blank" rel="noreferrer">About packages and modules</a></p><p>模块<code>Module</code>是任何的能被nodejs程序使用require加载的模块。满足以下条件均可以称为Module：</p><ul><li>一个文件夹包含package.json文件并指定了main字段</li><li>一个文件夹包含index.js文件</li><li>一个javascript文件</li></ul><p>需要知道的是，JavaScript模块规范有<code>CommonJS</code>、<code>ES6 module</code>、<code>AMD</code>等多种形式。</p><p>大多数Package都是一个Module，下面是官网上关于<code>pacekage</code>的定义，可以大致了解一下，不必拘泥于相关概念</p><ul><li>(a)一个包含了程序和描述该程序的 package.json 文件 的 文件夹</li><li>(b)一个包含了 (a) 的 gzip 压缩文件</li><li>(c)一个可以下载得到 (b) 资源的 url (通常是 http(s) url)</li><li>(d)一个格式为 <code>&lt;name&gt;@&lt;version&gt;</code> 的字符串，可指向 npm 源(通常是官方源 npmjs.org)上已发布的可访问 url，且该 url 满足条件 (c)</li><li>(e)一个格式为 <code>&lt;name&gt;@&lt;tag&gt;</code> 的字符串，在 npm 源上该<code>&lt;tag&gt;</code>指向某 <code>&lt;version&gt;</code> 得到 <code>&lt;name&gt;@&lt;version&gt;</code>，后者满足条件 (d)</li><li>(f)一个格式为 <code>&lt;name&gt;</code> 的字符串，默认添加 latest 标签所得到的 <code>&lt;name&gt;@latest</code> 满足条件 (e)</li><li>(g)一个 git url, 该 \burl 所指向的代码库满足条件 (a)</li></ul><p><a href="https://www.npmjs.cn/" target="_blank" rel="noreferrer">npm</a>全称为<code>Node Package Manager</code>，是一个基于Node.js的<strong>包</strong>管理器，npm 存在的目的是避免 JS 开发者重复造轮子，让大家的劳动成果可以共享。</p><h3 id="package-json" tabindex="-1">package.json <a class="header-anchor" href="#package-json" aria-label="Permalink to &quot;package.json&quot;">​</a></h3><p>package.json 文件就是定义了项目的各种元信息，包括项目的名称、git仓库地址、作者等等，最重要的是其中定义了我们项目的依赖插件和环境。一般情况下，不需要将<code>nodu_modules</code>放入版本控制，只需要管理这个package.json文件，然后通过<code>npm install</code>，就会自动下载相关依赖。</p><p><code>package.json</code>的每个字段都有一些特定的用途，关于包依赖有<code>devDependencies</code>和<code>dependencies</code>两个字段，他们的区别在于：</p><ul><li>前者是开发的时候需要的依赖项，使用<code>npm i xxx -S</code>安装</li><li>后者是程序正常运行需要的包，使用<code>npm i xxx -D</code>安装</li></ul><p>此外某些框架或工具还会额外扩展<code>package.json</code>的配置，如<code>babel</code>等可以也可以直接在<code>package.json</code>中配置</p><h3 id="语义化版本" tabindex="-1">语义化版本 <a class="header-anchor" href="#语义化版本" aria-label="Permalink to &quot;语义化版本&quot;">​</a></h3><p>npm包的版本号使用<a href="https://semver.org/lang/zh-CN/" target="_blank" rel="noreferrer">semver</a> 定义。版本号实际上是一个特定含义的字符串，其格式为<code>主版本号.次版本号.修订号</code>，版本号递增规则如下</p><ul><li>主版本号：当你做了不兼容的 API 修改，</li><li>次版本号：当你做了向下兼容的功能性新增，</li><li>修订号：当你做了向下兼容的问题修正。</li></ul><p>package.json中的依赖版本号可以包含<code>^</code>、<code>~</code>、<code>&gt;=</code>等前缀</p><ul><li>caret(箭头)表示： ^2.0.2能帮你下载最新的2.x.x的包，不能下载1.x.x的包。比如最新的是2.1.0， 就是直接下载2.1.0。</li><li>tilde(波浪线)表示： ～2.0.2能帮你下载2.0.x的最新包，不能下载2.1.x的包，比 ^ 要更加谨慎一些。比如最新的包如果是2.0.3， 就会下载，而如果是2.1.3就不会下载。</li><li><code>&gt;=</code>表示需要版本号大于或等于指定版本</li><li><code>&lt;=</code>表示需要版本号小于或等于指定版本</li><li>没有任何符号就表示严格匹配，必须下载该版本号的依赖包</li></ul><p>此外，在<code>package.json</code>中任意两条规则，通过 <code>||</code> 连接起来，表示“或”逻辑，即两条规则的并集。</p><h3 id="package-lock" tabindex="-1">package-lock <a class="header-anchor" href="#package-lock" aria-label="Permalink to &quot;package-lock&quot;">​</a></h3><p>参考：<a href="https://www.shymean.com/article/%E8%AE%B0package-lock%E5%BC%95%E5%8F%91%E7%9A%84%E4%B8%80%E6%AC%A1%E4%BA%8B%E6%95%85" target="_blank" rel="noreferrer">记package-lock引发的一次事故</a></p><p><code>package-lock.json</code>是当 <code>node_modules</code>或<code>package.json</code>发生变化时自动生成的文件。这个文件主要功能是确定当前安装的包的依赖，以便后续重新安装的时候生成相同的依赖，而忽略项目开发过程中有些依赖已经发生的更新。</p><p>Lock机制是为了保证多人开发的统一性。什么是统一性？就是无论何时来了一个新人、换了个新电脑，我们npm i的包都是一致的，不管在那一台机器上执行 npm install 都会得到完全相同的 node_modules 结果。</p><p>随着项目越来越大，依赖越来越多，很难保证每一个npm包的最新版本都是适合的、有用的。Lock机制可以最大化解决此类冲突。在多人协作时同步开发环境。至于什么时候用新的包，到时候再同步lock文件就是。</p><p>基于以上原因，建议将package-lock文件锁定安装时的包的版本号，并且上传到git，以保证其他人在npm install时大家的依赖能保证一致。</p><h2 id="npm-install" tabindex="-1">npm install <a class="header-anchor" href="#npm-install" aria-label="Permalink to &quot;npm install&quot;">​</a></h2><p>参考:</p><ul><li><a href="https://docs.npmjs.com/cli/install" target="_blank" rel="noreferrer">npm-install</a></li><li><a href="https://github.com/Advanced-Frontend/Daily-Interview-Question/issues/22" target="_blank" rel="noreferrer">npm 模块安装机制</a></li></ul><h3 id="模块安装流程" tabindex="-1">模块安装流程 <a class="header-anchor" href="#模块安装流程" aria-label="Permalink to &quot;模块安装流程&quot;">​</a></h3><p>有了npm之后，我们只需要通过<code>npm install xxx</code>就可以从npm仓库里面下载别人写好的包，然后在代码里面引入相关的模块进行开发。</p><p>安装流程如下</p><ul><li>npm 模块安装机制：</li><li>发出npm install命令</li><li>查询node_modules目录之中是否已经存在指定模块 <ul><li>若存在，不再重新安装</li><li>若不存在 <ul><li>npm 向 registry 查询模块压缩包的网址</li><li>下载压缩包，存放在根目录下的.npm目录里</li><li>解压压缩包到当前项目的node_modules目录</li></ul></li></ul></li></ul><p>具体阶段可分为下面几个步骤</p><ul><li>如果工程定义了<code>preinstall</code>钩子，则先执行</li><li>根据<code>package.json</code>中的<code>dependencies</code> 和 <code>devDependencies</code> 属性中直接指定的模块确定首层依赖，构建一颗以工程本身为根节点的依赖树</li><li>分析完模块依赖，就开始获取模块，获取模块是一个递归的过程 <ul><li>获取模块信息，在下载一个模块之前，首先要确定需要下载的包semver版本，然后返回对应的压缩包地址</li><li>获取模块实体，上一步会获取到模块的压缩包地址（resolved 字段），npm 会用此地址检查本地<code>node_modules</code>是否已经安装该包，如果没有则从仓库下载，下载的文件会放在<code>node_modules</code>下</li><li>查找该模块依赖，如果有依赖则回到第1步，如果没有则停止。</li></ul></li></ul><p>这里需要理解<code>模块扁平化（dedupe）</code>的概念。一棵完整的依赖树，其中可能包含大量<strong>重复模块</strong>，重复模块指的是模块名相同且semver兼容。已重复的模块不需要重新安装，这可以使更多冗余模块在 dedupe 过程中被去掉。</p><ul><li>npm2中，<code>node_modules</code>采用\b简单的递归安装方法，不同的依赖包里面可能包含重复的底层包依赖</li><li>npm3中，<code>node_modules</code> 目录改成了更加扁平状的层级结构，得益于 node 的模块加载机制，模块可以在上层的<code>node_modules</code>目录中成功加载依赖，从而实现模块扁平化</li><li>npm5中，新增了<code>package-lock.json</code>文件，其作用是锁定依赖安装结构，内部与node_modules 目录的文件层级结构是一一对应的</li></ul><h3 id="优化install速度" tabindex="-1">优化install速度 <a class="header-anchor" href="#优化install速度" aria-label="Permalink to &quot;优化install速度&quot;">​</a></h3><p><strong>切换镜像</strong></p><p>日常工作可能需要从npm官方源、淘宝镜像、公司私有源等仓库来回切换，因此推荐<a href="https://www.npmjs.com/package/nrm" target="_blank" rel="noreferrer">nrm</a>工具管理npm源</p><div class="language- vp-adaptive-theme"><button title="Copy Code" class="copy"></button><span class="lang"></span><pre class="shiki shiki-themes github-light github-dark vp-code"><code><span class="line"><span># 列举目前配置的源列表</span></span>
<span class="line"><span>nrm ls </span></span>
<span class="line"><span># 使用淘宝源</span></span>
<span class="line"><span>nrm use taobao</span></span>
<span class="line"><span># 增加一种源，然后就可以在ls 和 use中使用了</span></span>
<span class="line"><span>nrm add xxxxx</span></span></code></pre></div><p><strong>直接从缓存安装</strong></p><p>参考：<a href="http://www.ruanyifeng.com/blog/2016/01/npm-install.html" target="_blank" rel="noreferrer">npm 模块安装机制简介</a></p><p>一个模块安装以后，本地其实保存了两份。一份是~/.npm目录下的压缩包，另一份是node_modules目录下解压后的代码。</p><p>运行npm install的时候，只会检查node_modules目录，而不会检查~/.npm目录。也就是说，如果一个模块在～/.npm下有压缩包，但是没有安装在node_modules目录中，npm 依然会从远程仓库下载一次新的压缩包</p><p>这种行为固然可以保证总是取得最新的代码，但有时并不是我们想要的。最大的问题是，它会极大地影响安装速度。因此可以通过<code>--cache-min</code>从本地的缓存目录中直接解压包文件。</p><h2 id="npm-script" tabindex="-1">npm script <a class="header-anchor" href="#npm-script" aria-label="Permalink to &quot;npm script&quot;">​</a></h2><p>参考：<a href="http://www.ruanyifeng.com/blog/2016/10/npm_scripts.html" target="_blank" rel="noreferrer">npm scripts 使用指南</a></p><p>常见的<code>cli</code>工具，都增加了一个<code>npm scripts</code>命令，如<code>npm run build</code>、<code>npm run serve</code>等</p><p>每当执行<code>npm run</code>，就会自动新建一个 Shell，在这个 Shell 里面执行指定的脚本命令。因此，只要是 Shell（一般是 Bash）可以运行的命令，就可以写在 npm 脚本里面。</p><h3 id="npx" tabindex="-1">npx <a class="header-anchor" href="#npx" aria-label="Permalink to &quot;npx&quot;">​</a></h3><p>npx是什么呢？ npx 会帮你执行依赖包里的二进制文件。</p><div class="language- vp-adaptive-theme"><button title="Copy Code" class="copy"></button><span class="lang"></span><pre class="shiki shiki-themes github-light github-dark vp-code"><code><span class="line"><span>npm i webpack -D      //非全局安装</span></span>
<span class="line"><span></span></span>
<span class="line"><span>// 无npx 执行 webpack 的命令</span></span>
<span class="line"><span>./node_modules/.bin/webpack -v</span></span>
<span class="line"><span></span></span>
<span class="line"><span>// 使用npx</span></span>
<span class="line"><span>npx webpack -v</span></span></code></pre></div><h2 id="如何发布自己的npm包" tabindex="-1">如何发布自己的npm包 <a class="header-anchor" href="#如何发布自己的npm包" aria-label="Permalink to &quot;如何发布自己的npm包&quot;">​</a></h2><h3 id="编写本地模块" tabindex="-1">编写本地模块 <a class="header-anchor" href="#编写本地模块" aria-label="Permalink to &quot;编写本地模块&quot;">​</a></h3><p>参考</p><ul><li><a href="http://blog.csdn.net/bugknightyyp/article/details/8783162" target="_blank" rel="noreferrer"> 怎么样写一个 node.js模块以及NPM Package</a></li></ul><p>首先，新建一个<code>txm</code>文件夹，管理我们的整个模块文件，</p><ul><li><code>index.js</code>，用来存放模块的主要逻辑，注意按照CommonJS规范来书写模块，即每个模块使用<code>exports</code>暴露接口</li><li><code>package.json</code>，模块的配置，比如名称，版本和相关依赖等等</li><li><code>README.md</code>，模块的介绍和使用等</li></ul><p>然后再<code>txm</code>文件夹中使用<code>npm pack</code>将整个文件夹打包，会显示生成<code>txm-0.0.1.tgz</code>(这个版本号是在package.json中定义)。</p><p>然后返回上一层，使用<code>npm install txm/txm-0.0.1.tgz</code>将txm模块包进行安装。<br> 这里需要注意不能再txm文件夹中直接使用<code>npm install txm-0.0.1.tgz</code>，会出现<code>Refusing to install xm as a dependency of itself</code>的错误信息</p><p>可以在整个项目文件夹的<code>node_modules</code>文件夹中发现我们的模块包了。 最后在项目的文件比如<code>main.js</code>中就可以直接使用<code>let txm = require(&#39;txm&#39;)</code>来加载我们的模块了。</p><h3 id="发布及注意事项" tabindex="-1">发布及注意事项 <a class="header-anchor" href="#发布及注意事项" aria-label="Permalink to &quot;发布及注意事项&quot;">​</a></h3><p>编写好本地包之后，如果需要发布到npm仓库上供其他用户使用，按照以下步骤进行</p><ul><li>将镜像切换回<code>https://registry.npmjs.org/</code>，其他源如<a href="https://npm.taobao.org" target="_blank" rel="noreferrer">淘宝npm</a>会定期从npm官网上同步包，因此只需要发布在npm上即可</li><li><code>npm adduser</code>、<code>npm login</code>登录需要发布模块的账号</li><li>注意包名和版本号，是否已经存在了</li></ul><p>目前npm的包名为了防止“误植”攻击，会自动检测相近的包名，参考<a href="https://www.w3cvip.org/topics/393" target="_blank" rel="noreferrer">https://www.w3cvip.org/topics/393</a>。</p><p>解决办法是加命名空间，然后修改发布权限</p><div class="language- vp-adaptive-theme"><button title="Copy Code" class="copy"></button><span class="lang"></span><pre class="shiki shiki-themes github-light github-dark vp-code"><code><span class="line"><span>&quot;name&quot;: &quot;@shymean/koa-mock&quot;,</span></span>
<span class="line"><span>  </span></span>
<span class="line"><span>npm publish --access=public</span></span></code></pre></div><p>具体实践可以参考之前写的一篇文章:</p><ul><li><a href="https://www.shymean.com/article/%E5%86%99%E4%B8%80%E4%B8%AA%E6%90%AD%E5%BB%BA%E6%9C%AC%E5%9C%B0mock%E6%9C%8D%E5%8A%A1%E5%99%A8%E7%9A%84%E5%91%BD%E4%BB%A4%E8%A1%8C%E5%B7%A5%E5%85%B7#4.%20npm%E6%9C%AC%E5%9C%B0%E5%8C%85%E5%8F%8A%E5%8F%91%E5%B8%83" target="_blank" rel="noreferrer">写一个搭建本地mock服务器的命令行工具</a>。</li></ul><h2 id="搭建本地npm服务器" tabindex="-1">搭建本地npm服务器 <a class="header-anchor" href="#搭建本地npm服务器" aria-label="Permalink to &quot;搭建本地npm服务器&quot;">​</a></h2><p>在某些时候不方便将模块发布到公共的npm仓库，因此就有了搭建本地npm服务器的需求</p><p>在之前可以使用<a href="https://github.com/rlidwka/sinopia" target="_blank" rel="noreferrer">sinopia</a>来搭建npm私有仓库，但sinopia已经年久失修了，目前一般使用<a href="https://github.com/verdaccio/verdaccio" target="_blank" rel="noreferrer">verdaccio</a></p><div class="language- vp-adaptive-theme"><button title="Copy Code" class="copy"></button><span class="lang"></span><pre class="shiki shiki-themes github-light github-dark vp-code"><code><span class="line"><span># 全局安装</span></span>
<span class="line"><span>npm i verdaccio -g </span></span>
<span class="line"><span></span></span>
<span class="line"><span># 启动服务</span></span>
<span class="line"><span>verdaccio</span></span>
<span class="line"><span></span></span>
<span class="line"><span># 如果希望开启守护经常，可以使用pm2 </span></span>
<span class="line"><span>pm2 start verdaccio</span></span>
<span class="line"><span></span></span>
<span class="line"><span>http://localhost:4873</span></span></code></pre></div><p>可以修改<code>vs ~/.config/verdaccio/config.yaml</code>的相关配置，比如当找不到包时如果希望去其他镜像查找，则修改<code>uplinks</code>参数</p><div class="language- vp-adaptive-theme"><button title="Copy Code" class="copy"></button><span class="lang"></span><pre class="shiki shiki-themes github-light github-dark vp-code"><code><span class="line"><span>uplinks:</span></span>
<span class="line"><span>  npmjs:</span></span>
<span class="line"><span>    url: https://registry.npmjs.org/</span></span>
<span class="line"><span>    # 可以修改为淘宝镜像 url: https://registry.npm.taobao.org/</span></span></code></pre></div><p>如果是公司级别的npm私库，可以考虑使用Docker安装verdaccio镜像，此外各大云服务提供商业提供了企业级别的私有包托管仓库，直接购买购买云服务应该也可以</p><h2 id="修改npm镜像" tabindex="-1">修改npm镜像 <a class="header-anchor" href="#修改npm镜像" aria-label="Permalink to &quot;修改npm镜像&quot;">​</a></h2><p>如果是临时修改镜像源，可以通过<code>--registry</code>参数</p><div class="language- vp-adaptive-theme"><button title="Copy Code" class="copy"></button><span class="lang"></span><pre class="shiki shiki-themes github-light github-dark vp-code"><code><span class="line"><span>npm --registry https://registry.npm.taobao.org install</span></span></code></pre></div><p>永久修改registry，则可以通过<code>npm config</code></p><div class="language- vp-adaptive-theme"><button title="Copy Code" class="copy"></button><span class="lang"></span><pre class="shiki shiki-themes github-light github-dark vp-code"><code><span class="line"><span>npm config set registry https://registry.npm.taobao.org/</span></span></code></pre></div><p>如果需要经常在多个镜像之间来回切换，可以使用nrm</p><div class="language- vp-adaptive-theme"><button title="Copy Code" class="copy"></button><span class="lang"></span><pre class="shiki shiki-themes github-light github-dark vp-code"><code><span class="line"><span>npm install -g nrm</span></span>
<span class="line"><span></span></span>
<span class="line"><span># 查看镜像</span></span>
<span class="line"><span>nrm ls</span></span>
<span class="line"><span></span></span>
<span class="line"><span># 使用某个镜像</span></span>
<span class="line"><span>nrm use taobao</span></span>
<span class="line"><span></span></span>
<span class="line"><span># 添加镜像</span></span>
<span class="line"><span>nrm add local http://localhost:4873/</span></span></code></pre></div><h2 id="其他包管理工具" tabindex="-1">其他包管理工具 <a class="header-anchor" href="#其他包管理工具" aria-label="Permalink to &quot;其他包管理工具&quot;">​</a></h2><h3 id="yarn" tabindex="-1">yarn <a class="header-anchor" href="#yarn" aria-label="Permalink to &quot;yarn&quot;">​</a></h3><p>Yarn是由Facebook、Google、Exponent 和 Tilde 联合推出了一个新的 JS 包管理工具，主要目的是弥补npm的一些设计缺陷。</p><p>在当时还是npm4.x的时代背景下，npm存在的一些缺陷</p><ul><li>npm install的时候非常慢，要安装的依赖太多了，并且是按照队列顺序安装每个依赖</li><li>同一个项目，安装的时候无法保持一致性，没错，当时还没有package-lock.json</li></ul><p>yarn具备的优点</p><ul><li>安装速度快，主要靠：并行下载、缓存离线安装</li><li>yarn.lock记录每个被安装的依赖的版本</li></ul><p>npm5.x之后做出了一些改动</p><ul><li>增加了package-lock.json</li><li>文件依赖优化，通过symlinks依赖本地模块（之前是拷贝文件到node_modules）</li></ul><p>yarn切换镜像的话，可以使用<a href="https://www.npmjs.com/package/yrm" target="_blank" rel="noreferrer">yrm</a>，跟上面的nrm基本一致。</p><h3 id="cnpm" tabindex="-1">cnpm <a class="header-anchor" href="#cnpm" aria-label="Permalink to &quot;cnpm&quot;">​</a></h3><p>不要用，不如使用npm然后改个taobao镜像。</p><h3 id="pnpm" tabindex="-1">pnpm <a class="header-anchor" href="#pnpm" aria-label="Permalink to &quot;pnpm&quot;">​</a></h3><p>NPM与Yarn都是将项目依赖的包安装到项目目录node_modules下，PNPM采用了一种不同的方法，它在您的计算机上创建一个单一的虚拟存储库，并使用硬链接将其链接到各个项目目录，而不是将文件复制到每个项目目录中。这样可以实现多个项目共享相同的包版本而无需重复复制。PNPM还支持多个注册表、私有包和基于锁定文件的确定性构建。</p><p>这样就可以通过在项目之间使用共享存储来减少磁盘空间占用和加快安装速度</p><p>目前使用PNPM可以在Monorepo中更高效地管理依赖关系。PNPM的特点之一是使用虚拟存储库和硬链接来共享依赖项，从而减少磁盘空间占用和安装时间。这对于Monorepo来说非常有用，因为不同项目可以共享相同的依赖项，而不必在每个项目中都复制一份。这样可以减少冗余，并提供更快的安装和构建速度。</p>`,104),o=[l];function i(c,t,r,d,m,h){return n(),e("div",null,o)}const k=a(p,[["render",i]]);export{g as __pageData,k as default};
