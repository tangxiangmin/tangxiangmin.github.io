import{_ as a,c as e,o as t,a2 as i}from"./chunks/framework.DLPB9-dE.js";const m=JSON.parse('{"title":"","description":"","frontmatter":{},"headers":[],"relativePath":"面试/面试题/React.md","filePath":"面试/面试题/React.md","lastUpdated":1646554062000}'),s={name:"面试/面试题/React.md"},r=i(`<h2 id="react" tabindex="-1">React <a class="header-anchor" href="#react" aria-label="Permalink to &quot;React&quot;">​</a></h2><ul><li><a href="https://juejin.im/post/5d5f44dae51d4561df7805b4" target="_blank" rel="noreferrer">2019年17道高频React面试题及详解</a></li></ul><h3 id="react设计理念" tabindex="-1">React设计理念 <a class="header-anchor" href="#react设计理念" aria-label="Permalink to &quot;React设计理念&quot;">​</a></h3><p>react只是关注view层，它的核心思想就是view = f(state)。在React中，一切都是组件，组件是 React 应用 UI 的构建块。这些组件将整个 UI 分成小的独立并可重用的部分。每个组件彼此独立，而不会影响 UI 的其余部分。</p><h3 id="为什么要改用fiber-reconciler" tabindex="-1">为什么要改用Fiber Reconciler <a class="header-anchor" href="#为什么要改用fiber-reconciler" aria-label="Permalink to &quot;为什么要改用Fiber Reconciler&quot;">​</a></h3><p>避免Stack Reconciler 递归diff运算时间过长的问题</p><h3 id="新的生命周期函数-会带来什么影响" tabindex="-1">新的生命周期函数？会带来什么影响 <a class="header-anchor" href="#新的生命周期函数-会带来什么影响" aria-label="Permalink to &quot;新的生命周期函数？会带来什么影响&quot;">​</a></h3><p>参考<a href="http://projects.wojtekmaj.pl/react-lifecycle-methods-diagram/" target="_blank" rel="noreferrer">这张图</a></p><p>由于Fiber导致diff阶段的生命周期函数可能会被重复调用，因此一些逻辑如接口请求应该放在<code>componentDidMounted</code>中处理</p><h3 id="setstate是同步的还是异步的" tabindex="-1">setState是同步的还是异步的 <a class="header-anchor" href="#setstate是同步的还是异步的" aria-label="Permalink to &quot;setState是同步的还是异步的&quot;">​</a></h3><p>在React合成事件和生命周期函数中等React可以知道当前setState运行上下文的地方是异步的，在其他地方是同步的。</p><h3 id="hoc高阶组件" tabindex="-1">HOC高阶组件 <a class="header-anchor" href="#hoc高阶组件" aria-label="Permalink to &quot;HOC高阶组件&quot;">​</a></h3><p>高阶组件是重用组件逻辑的高级方法，是一种源于 React 的组件模式。 HOC 是自定义组件，在它之内包含另一个组件。它们可以接受子组件提供的任何动态，但不会修改或复制其输入组件中的任何行为。你可以认为 HOC 是“纯（Pure）”组件。</p><p>高阶组件可以用于</p><ul><li>代码重用，逻辑和引导抽象</li><li>渲染劫持</li><li>状态抽象和控制</li><li>Props 控制</li></ul><h3 id="react合成事件" tabindex="-1">React合成事件 <a class="header-anchor" href="#react合成事件" aria-label="Permalink to &quot;React合成事件&quot;">​</a></h3><p>当用户在为onClick添加函数时，React并没有将Click时间绑定在DOM上面。 而是在document处监听所有支持的事件，当事件发生并冒泡至document处时，React将事件内容封装交给中间层SyntheticEvent（负责所有事件合成） 所以当事件触发的时候，对使用统一的分发函数dispatchEvent将指定函数执行。</p><h3 id="react项目性能优化" tabindex="-1">React项目性能优化 <a class="header-anchor" href="#react项目性能优化" aria-label="Permalink to &quot;React项目性能优化&quot;">​</a></h3><p>可以从下面几个方面入手</p><ul><li>代码分割，路由按需加载</li><li>通过<code>React.memo</code>、<code>shouldComponentUpdate</code>和<code>PureComponent</code>手动判断是否需要重新渲染</li></ul><h3 id="purecomponent中浅比较代码实现" tabindex="-1">PureComponent中浅比较代码实现 <a class="header-anchor" href="#purecomponent中浅比较代码实现" aria-label="Permalink to &quot;PureComponent中浅比较代码实现&quot;">​</a></h3><p>使用增强版的<code>Object.is</code>比较两个对象，当引用不相同时，只比较两个对象的第一层的值是否相同，</p><h3 id="react中获取ref的几种方法" tabindex="-1">React中获取ref的几种方法 <a class="header-anchor" href="#react中获取ref的几种方法" aria-label="Permalink to &quot;React中获取ref的几种方法&quot;">​</a></h3><div class="language-js vp-adaptive-theme"><button title="Copy Code" class="copy"></button><span class="lang">js</span><pre class="shiki shiki-themes github-light github-dark vp-code"><code><span class="line"><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">ref</span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">=</span><span style="--shiki-light:#032F62;--shiki-dark:#9ECBFF;">&#39;myRef&#39;</span><span style="--shiki-light:#6A737D;--shiki-dark:#6A737D;"> // this.refs[&#39;xxxname&#39;]</span></span>
<span class="line"></span>
<span class="line"><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">ref</span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">=</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">{</span><span style="--shiki-light:#E36209;--shiki-dark:#FFAB70;">el</span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">=&gt;</span><span style="--shiki-light:#005CC5;--shiki-dark:#79B8FF;">this</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">.xxx</span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">=</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">el} </span><span style="--shiki-light:#6A737D;--shiki-dark:#6A737D;">// this.xxx</span></span>
<span class="line"></span>
<span class="line"><span style="--shiki-light:#005CC5;--shiki-dark:#79B8FF;">this</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">.myRef</span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">=</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">React.</span><span style="--shiki-light:#6F42C1;--shiki-dark:#B392F0;">createRef</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">()</span></span>
<span class="line"><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">ref</span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">=</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">{this.myRef} </span><span style="--shiki-light:#6A737D;--shiki-dark:#6A737D;">// this.myRef.current</span></span>
<span class="line"></span>
<span class="line"><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">React.forwardRef </span><span style="--shiki-light:#6A737D;--shiki-dark:#6A737D;">// 将prop接收到的ref传递给子组件，可以用于在高阶组件中获取原始组件</span></span></code></pre></div><h3 id="react中组件父子组件通信的方式-非父子组件之间通信呢" tabindex="-1">React中组件父子组件通信的方式？非父子组件之间通信呢？ <a class="header-anchor" href="#react中组件父子组件通信的方式-非父子组件之间通信呢" aria-label="Permalink to &quot;React中组件父子组件通信的方式？非父子组件之间通信呢？&quot;">​</a></h3><p>可以使用</p><ul><li><code>props</code>父子通信</li><li><code>ref</code>获取子组件实例</li><li><code>context</code>，跨级祖先组件与后代组件通信</li><li><code>EventBus</code>事件总线通信</li><li><code>flux</code>、<code>redux</code>、<code>mobx</code>等全局状态管理</li></ul><h3 id="react-memo的作用是什么" tabindex="-1">React.memo的作用是什么？ <a class="header-anchor" href="#react-memo的作用是什么" aria-label="Permalink to &quot;React.memo的作用是什么？&quot;">​</a></h3><p>当组件的输入属性相同时，可以通过<code>SCU</code>或<code>PureComponent</code>避免重新渲染，这是一个很常见的优化操作，因此提供了<code>React.memo</code>达到相同的目的</p><h3 id="reactdom-createportal的作用和引用场景" tabindex="-1">ReactDOM.createPortal的作用和引用场景 <a class="header-anchor" href="#reactdom-createportal的作用和引用场景" aria-label="Permalink to &quot;ReactDOM.createPortal的作用和引用场景&quot;">​</a></h3><p>默认情况下，组件render函数返回的元素会被挂载在它的父级组件上，<code>createPortal</code>提供了将render返回的DOM元素渲染到其他地方的方式，可以用来封装如弹窗等组件</p><h3 id="react-fragment" tabindex="-1">React.Fragment <a class="header-anchor" href="#react-fragment" aria-label="Permalink to &quot;React.Fragment&quot;">​</a></h3><p>按照约定一段jsx代码需要通过单节点包裹起来，我们往往会通过一个真实的标签如<code>div</code>等来包裹，<code>Fragment</code>提供了一个使返回子元素列表而不需要新增一个真实DOM节点的方法。</p><h3 id="react中插入html字符串" tabindex="-1">React中插入html字符串? <a class="header-anchor" href="#react中插入html字符串" aria-label="Permalink to &quot;React中插入html字符串?&quot;">​</a></h3><p>使用保留prop字段<code>dangerouslySetInnerHTML</code></p><h3 id="hooks的优势和劣势有哪些" tabindex="-1">Hooks的优势和劣势有哪些？ <a class="header-anchor" href="#hooks的优势和劣势有哪些" aria-label="Permalink to &quot;Hooks的优势和劣势有哪些？&quot;">​</a></h3><h2 id="redux" tabindex="-1">Redux <a class="header-anchor" href="#redux" aria-label="Permalink to &quot;Redux&quot;">​</a></h2><h3 id="中间件实现原理" tabindex="-1">中间件实现原理 <a class="header-anchor" href="#中间件实现原理" aria-label="Permalink to &quot;中间件实现原理&quot;">​</a></h3><p>通过curry定义中间件，通过compose组合dispatch。</p>`,39),l=[r];function n(o,c,h,d,p,k){return t(),e("div",null,l)}const f=a(s,[["render",n]]);export{m as __pageData,f as default};
