import{_ as s,c as a,o as e,a2 as i}from"./chunks/framework.DLPB9-dE.js";const S=JSON.parse('{"title":"","description":"","frontmatter":{},"headers":[],"relativePath":"前端/CSS/编写样式表.md","filePath":"前端/CSS/编写样式表.md","lastUpdated":1683863238000}'),t={name:"前端/CSS/编写样式表.md"},l=i(`<h2 id="预处理器" tabindex="-1">预处理器 <a class="header-anchor" href="#预处理器" aria-label="Permalink to &quot;预处理器&quot;">​</a></h2><p>预处理器提供更有效的编写 CSS 样式表的工具，如 LESS、SCSS 以 SCSS 为例，需要理解常用特性如：变量、混合、继承、函数、循环、分支、导入组件等</p><h3 id="scss" tabindex="-1">SCSS <a class="header-anchor" href="#scss" aria-label="Permalink to &quot;SCSS&quot;">​</a></h3><ul><li><a href="https://www.shymean.com/article/%E5%88%9D%E8%AF%86SCSS" target="_blank" rel="noreferrer">初始scss</a></li><li><a href="https://www.shymean.com/article/SCSS%E8%BF%9B%E9%98%B6" target="_blank" rel="noreferrer">scss进阶</a></li></ul><h3 id="less" tabindex="-1">LESS <a class="header-anchor" href="#less" aria-label="Permalink to &quot;LESS&quot;">​</a></h3><p>使用较少</p><h2 id="后处理器" tabindex="-1">后处理器 <a class="header-anchor" href="#后处理器" aria-label="Permalink to &quot;后处理器&quot;">​</a></h2><p>后处理器主要为进一步处理样式表，使其更符合规范，</p><h3 id="postcss" tabindex="-1">PostCSS <a class="header-anchor" href="#postcss" aria-label="Permalink to &quot;PostCSS&quot;">​</a></h3><p>常见的功能有 autoprefixer、px2rem 等</p><p><a href="https://www.postcss.com.cn/" target="_blank" rel="noreferrer">官网</a></p><h2 id="避免选择器冲突" tabindex="-1">避免选择器冲突 <a class="header-anchor" href="#避免选择器冲突" aria-label="Permalink to &quot;避免选择器冲突&quot;">​</a></h2><p>维护<code>CSS</code>有几个比较困难的问题：</p><ul><li>默认全局命名空间，样式冲突十分常见</li><li>混乱的样式重用或选择器的滥用，导致改动牵一发而动全身</li><li>修改样式表的同时可能会改动页面结构，而且往往不只一个页面</li></ul><p>最后决定使用<code>BEM</code>来管理样式名称。参考</p><ul><li><a href="https://www.shymean.com/article/CSS%E4%BB%A3%E7%A0%81%E6%A0%BC%E5%BC%8F" target="_blank" rel="noreferrer">CSS代码格式</a></li><li><a href="https://www.shymean.com/article/%E5%85%B3%E4%BA%8ECSS%E7%9A%84%E6%80%9D%E8%80%83" target="_blank" rel="noreferrer">关于CSS的思考</a></li><li><a href="https://www.shymean.com/article/%E4%BD%BF%E7%94%A8BEM%E5%A3%B0%E6%98%8ECSS%E6%A0%B7%E5%BC%8F%E5%90%8D" target="_blank" rel="noreferrer">使用BEM声明CSS样式名</a></li></ul><h3 id="bem" tabindex="-1">BEM <a class="header-anchor" href="#bem" aria-label="Permalink to &quot;BEM&quot;">​</a></h3><p>参考之前的整理</p><ul><li><a href="http://www.shymean.com/article/%E4%BD%BF%E7%94%A8BEM%E5%A3%B0%E6%98%8ECSS%E6%A0%B7%E5%BC%8F%E5%90%8D" target="_blank" rel="noreferrer">使用 BEM 声明 CSS 样式名</a></li></ul><p>其核心思想是理解块、元素和修饰符的关系</p><h3 id="css-scoped" tabindex="-1">CSS Scoped <a class="header-anchor" href="#css-scoped" aria-label="Permalink to &quot;CSS Scoped&quot;">​</a></h3><p>Vue提供了一个PostCSS插件<a href="https://www.npmjs.com/package/@vue/component-compiler-utils" target="_blank" rel="noreferrer">@vue/component-compiler-utils</a>，实现了css作用域的功能</p><h3 id="css-module" tabindex="-1">CSS Module <a class="header-anchor" href="#css-module" aria-label="Permalink to &quot;CSS Module&quot;">​</a></h3><p><a href="https://github.com/css-modules/css-modules" target="_blank" rel="noreferrer">github 地址</a></p><p><strong>作用</strong> modular and reusable CSS!</p><ul><li>No more conflicts.</li><li>Explicit dependencies.</li><li>No global scope.</li></ul><p><strong>使用方法</strong> 编写样式表</p><div class="language-css vp-adaptive-theme"><button title="Copy Code" class="copy"></button><span class="lang">css</span><pre class="shiki shiki-themes github-light github-dark vp-code"><code><span class="line"><span style="--shiki-light:#6A737D;--shiki-dark:#6A737D;">/* style.css */</span></span>
<span class="line"><span style="--shiki-light:#6F42C1;--shiki-dark:#B392F0;">.className</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;"> {</span></span>
<span class="line"><span style="--shiki-light:#005CC5;--shiki-dark:#79B8FF;">    color</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">: </span><span style="--shiki-light:#005CC5;--shiki-dark:#79B8FF;">green</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">;</span></span>
<span class="line"><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">}</span></span></code></pre></div><p>在引入一个 css 模块时，会将其导出一个 JS 对象，并将局部类名映射为全局类名。</p><div class="language-js vp-adaptive-theme"><button title="Copy Code" class="copy"></button><span class="lang">js</span><pre class="shiki shiki-themes github-light github-dark vp-code"><code><span class="line"><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">import</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;"> styles </span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">from</span><span style="--shiki-light:#032F62;--shiki-dark:#9ECBFF;"> &quot;/style.css&quot;</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">;</span></span>
<span class="line"><span style="--shiki-light:#6A737D;--shiki-dark:#6A737D;">// import { className } from &quot;/style.css&quot;;</span></span>
<span class="line"></span>
<span class="line"><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">element.innerHTML </span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">=</span><span style="--shiki-light:#032F62;--shiki-dark:#9ECBFF;"> &#39;&lt;div class=&quot;&#39;</span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;"> +</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;"> styles.className </span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">+</span><span style="--shiki-light:#032F62;--shiki-dark:#9ECBFF;"> &#39;&quot;&gt;&#39;</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">;</span></span></code></pre></div>`,30),r=[l];function n(h,p,o,c,d,k){return e(),a("div",null,r)}const u=s(t,[["render",n]]);export{S as __pageData,u as default};
