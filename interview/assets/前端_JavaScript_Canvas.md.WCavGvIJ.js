import{_ as s,c as a,o as i,a2 as n}from"./chunks/framework.DLPB9-dE.js";const o=JSON.parse('{"title":"canvas","description":"","frontmatter":{},"headers":[],"relativePath":"前端/JavaScript/Canvas.md","filePath":"前端/JavaScript/Canvas.md","lastUpdated":1620234346000}'),h={name:"前端/JavaScript/Canvas.md"},l=n(`<h1 id="canvas" tabindex="-1">canvas <a class="header-anchor" href="#canvas" aria-label="Permalink to &quot;canvas&quot;">​</a></h1><h3 id="常见问题" tabindex="-1">常见问题 <a class="header-anchor" href="#常见问题" aria-label="Permalink to &quot;常见问题&quot;">​</a></h3><h3 id="如何解决在移动端利用canvas生成图片时-图片清晰度不够的问题" tabindex="-1">如何解决在移动端利用canvas生成图片时，图片清晰度不够的问题 <a class="header-anchor" href="#如何解决在移动端利用canvas生成图片时-图片清晰度不够的问题" aria-label="Permalink to &quot;如何解决在移动端利用canvas生成图片时，图片清晰度不够的问题&quot;">​</a></h3><p>这个是因为高清屏像素密度的问题，可以通过调整整个图片的分辨率（canvas画布的宽度和高度），从而生成较大的图片，图片的分辨率越大，保存的图片清晰度越高，下面是简单实现</p><div class="language-js vp-adaptive-theme"><button title="Copy Code" class="copy"></button><span class="lang">js</span><pre class="shiki shiki-themes github-light github-dark vp-code"><code><span class="line"><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">let</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;"> scale </span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">=</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;"> window.devicePixelRatio; </span><span style="--shiki-light:#6A737D;--shiki-dark:#6A737D;">//定义任意放大倍数 支持小数</span></span>
<span class="line"></span>
<span class="line"><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">let</span><span style="--shiki-light:#6F42C1;--shiki-dark:#B392F0;"> rem</span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;"> =</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;"> (</span><span style="--shiki-light:#E36209;--shiki-dark:#FFAB70;">s</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">) </span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">=&gt;</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;"> {</span></span>
<span class="line"><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">    return</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;"> window.screen.width </span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">/</span><span style="--shiki-light:#005CC5;--shiki-dark:#79B8FF;"> 750</span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;"> *</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;"> s </span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">*</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;"> scale</span></span>
<span class="line"><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">}</span></span>
<span class="line"></span>
<span class="line"><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">let</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;"> canvas </span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">=</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;"> document.</span><span style="--shiki-light:#6F42C1;--shiki-dark:#B392F0;">getElementById</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">(</span><span style="--shiki-light:#032F62;--shiki-dark:#9ECBFF;">&quot;stage&quot;</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">)</span></span>
<span class="line"><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">let</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;"> context </span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">=</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;"> canvas.</span><span style="--shiki-light:#6F42C1;--shiki-dark:#B392F0;">getContext</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">(</span><span style="--shiki-light:#032F62;--shiki-dark:#9ECBFF;">&quot;2d&quot;</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">)</span></span>
<span class="line"></span>
<span class="line"><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">let</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;"> cntElem </span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">=</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;"> document.body</span></span>
<span class="line"></span>
<span class="line"><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">let</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;"> width </span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">=</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;"> cntElem.offsetWidth; </span><span style="--shiki-light:#6A737D;--shiki-dark:#6A737D;">//获取dom 宽度</span></span>
<span class="line"><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">let</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;"> height </span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">=</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;"> cntElem.offsetHeight; </span><span style="--shiki-light:#6A737D;--shiki-dark:#6A737D;">//获取dom 高度</span></span>
<span class="line"></span>
<span class="line"><span style="--shiki-light:#6A737D;--shiki-dark:#6A737D;">// 画布的实际分辨率</span></span>
<span class="line"><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">canvas.width </span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">=</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;"> width </span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">*</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;"> scale; </span><span style="--shiki-light:#6A737D;--shiki-dark:#6A737D;">//定义canvas 宽度 * 缩放</span></span>
<span class="line"><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">canvas.height </span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">=</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;"> height </span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">*</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;"> scale; </span><span style="--shiki-light:#6A737D;--shiki-dark:#6A737D;">//定义canvas高度 *缩放</span></span>
<span class="line"></span>
<span class="line"><span style="--shiki-light:#6A737D;--shiki-dark:#6A737D;">// 画布在文档流中展示的分辨率</span></span>
<span class="line"><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">canvas.style.width </span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">=</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;"> width </span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">+</span><span style="--shiki-light:#032F62;--shiki-dark:#9ECBFF;"> &quot;px&quot;</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">;</span></span>
<span class="line"><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">canvas.style.height </span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">=</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;"> height </span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">+</span><span style="--shiki-light:#032F62;--shiki-dark:#9ECBFF;"> &quot;px&quot;</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">;</span></span></code></pre></div><h3 id="canvas中保存图片的跨域问题" tabindex="-1">canvas中保存图片的跨域问题 <a class="header-anchor" href="#canvas中保存图片的跨域问题" aria-label="Permalink to &quot;canvas中保存图片的跨域问题&quot;">​</a></h3><p>如果绘制了跨域的图片，则会导致画布被无法，调用<code>ctx.getImageData</code>、<code>canvas.toDataURL</code>等方法会抛出异常， 解决canvas图片跨域一般有</p><ul><li>如果是固定的静态资源图片，如cdn图片域名与页面url域名不一致造成的跨域，且图片数量与体积不多，可以使用base64形式的内联图片</li><li>如果图片数量较多，且图片资源服务器可控，可以配置CORS进行跨域操作</li></ul><div class="language-js vp-adaptive-theme"><button title="Copy Code" class="copy"></button><span class="lang">js</span><pre class="shiki shiki-themes github-light github-dark vp-code"><code><span class="line"><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">let</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;"> scaleImg </span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">=</span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;"> new</span><span style="--shiki-light:#6F42C1;--shiki-dark:#B392F0;"> Image</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">()</span></span>
<span class="line"><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">scaleImg.crossOrigin </span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">=</span><span style="--shiki-light:#032F62;--shiki-dark:#9ECBFF;"> &#39;Anonymous&#39;</span><span style="--shiki-light:#6A737D;--shiki-dark:#6A737D;"> // 后台配置CORS，前端声明图片为CORS</span></span>
<span class="line"><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">scaleImg.src </span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">=</span><span style="--shiki-light:#6F42C1;--shiki-dark:#B392F0;"> __uri</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">(</span><span style="--shiki-light:#032F62;--shiki-dark:#9ECBFF;">&#39;../img/xx.png&#39;</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">)</span></span></code></pre></div><ul><li>对于不可控的第三方图片，如微信头像等，一般需要先让服务端将图片下载到自己的服务器上，然后再进行处理</li></ul><div class="language-php vp-adaptive-theme"><button title="Copy Code" class="copy"></button><span class="lang">php</span><pre class="shiki shiki-themes github-light github-dark vp-code"><code><span class="line"><span style="--shiki-light:#6A737D;--shiki-dark:#6A737D;">// php下载远程图片  </span></span>
<span class="line"><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">$pic </span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">=</span><span style="--shiki-light:#032F62;--shiki-dark:#9ECBFF;"> &#39;http://avatar.csdn.net/7/5/0/1_molaifeng.jpg&#39;</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">;</span></span>
<span class="line"><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">$arr </span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">=</span><span style="--shiki-light:#005CC5;--shiki-dark:#79B8FF;"> getimagesize</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">($pic);</span></span>
<span class="line"><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">$pic </span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">=</span><span style="--shiki-light:#032F62;--shiki-dark:#9ECBFF;"> &quot;data:{</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">$arr</span><span style="--shiki-light:#032F62;--shiki-dark:#9ECBFF;">[&#39;mime&#39;]};base64,&quot;</span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;"> .</span><span style="--shiki-light:#005CC5;--shiki-dark:#79B8FF;"> base64_encode</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">(</span><span style="--shiki-light:#005CC5;--shiki-dark:#79B8FF;">file_get_contents</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">($pic));</span></span>
<span class="line"><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">?&gt;</span></span>
<span class="line"></span>
<span class="line"><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">var</span><span style="--shiki-light:#005CC5;--shiki-dark:#79B8FF;"> src</span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;"> =</span><span style="--shiki-light:#032F62;--shiki-dark:#9ECBFF;"> &quot;&lt;?php echo </span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">$pic</span><span style="--shiki-light:#032F62;--shiki-dark:#9ECBFF;"> ?&gt;&quot;</span></span></code></pre></div><h3 id="_100-100-的-canvas-占内存多大" tabindex="-1">100 * 100 的 Canvas 占内存多大？ <a class="header-anchor" href="#_100-100-的-canvas-占内存多大" aria-label="Permalink to &quot;100 * 100 的 Canvas 占内存多大？&quot;">​</a></h3><p>imageData = ctx.getImageData(sx, sy, sw, sh)这个 API回的是一个 ImageData 数组，这个数组是 Uint8 类型的，且四位表示一个像素</p><p>因此占用的内存是 100 * 100 * 4 bytes = 40,000 bytes。</p><p>结果不一定准确，后面再补充。</p><p>参考<a href="https://juejin.im/post/5bdeb357e51d4536140fc7df" target="_blank" rel="noreferrer">头条面试题：100 * 100 的 Canvas 占内存多大</a></p><h3 id="粒子效果大致的实现原理-最佳fps" tabindex="-1">粒子效果大致的实现原理，最佳fps <a class="header-anchor" href="#粒子效果大致的实现原理-最佳fps" aria-label="Permalink to &quot;粒子效果大致的实现原理，最佳fps&quot;">​</a></h3><p>粒子实际上就是画布上一个比较小的绘制单位，包含<code>speed</code>、<code>size</code>、<code>x</code>、<code>y</code>、<code>rgb</code>等属性。在画布中创造多个粒子，然后在画布的每一帧中，增量改变粒子的相关属性并重新绘制，就可以形成视觉上的粒子效果。</p><p>1秒60帧的流畅度，每一帧的时间可控制为<code>1000/60</code>ms</p><h3 id="canvas和svg有什么区别" tabindex="-1">canvas和svg有什么区别 <a class="header-anchor" href="#canvas和svg有什么区别" aria-label="Permalink to &quot;canvas和svg有什么区别&quot;">​</a></h3><p>参考：<a href="https://www.cnblogs.com/liyuspace/p/7746853.html" target="_blank" rel="noreferrer">Canvas和SVG的区别</a> Canvas和SVG是html5支持的两种可视化技术，都允许您在浏览器中创建图形，但是它们在根本上是不同的。它们很不相同</p><ul><li>Canvas 是基于像素的即时模式图形系统，最适合较小的表面或较大数量的对象，Canvas不支持鼠标键盘等事件。</li><li>SVG 是基于形状的保留模式图形系统，更加适合较大的表面或较小数量的对象。</li></ul><h2 id="canvas引入自定义字体" tabindex="-1">canvas引入自定义字体 <a class="header-anchor" href="#canvas引入自定义字体" aria-label="Permalink to &quot;canvas引入自定义字体&quot;">​</a></h2><p>通过css定义字体名</p><div class="language-css vp-adaptive-theme"><button title="Copy Code" class="copy"></button><span class="lang">css</span><pre class="shiki shiki-themes github-light github-dark vp-code"><code><span class="line"><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">@font-face</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;"> {</span></span>
<span class="line"><span style="--shiki-light:#005CC5;--shiki-dark:#79B8FF;">  font-family</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">: </span><span style="--shiki-light:#032F62;--shiki-dark:#9ECBFF;">&quot;_________&quot;</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">;  //下划线填字体名称</span></span>
<span class="line"><span style="--shiki-light:#005CC5;--shiki-dark:#79B8FF;">  src</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">: </span><span style="--shiki-light:#005CC5;--shiki-dark:#79B8FF;">url</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">(</span><span style="--shiki-light:#032F62;--shiki-dark:#9ECBFF;">&quot;_________&quot;</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">);  //下划线填字体文件</span></span>
<span class="line"><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">}</span></span></code></pre></div><p>然后在canvas中使用对应的字体名即可，需注意</p><ul><li>必须再等到字体下载完成之后再去渲染canvas,字体才能有作用</li><li>canvas中所引用的字体必须在文档流中有标签(span,p等)引用改字体!!!这就是最大的坑了!!!</li></ul><p>上面问题待验证，参考</p><ul><li><a href="https://segmentfault.com/q/1010000008146516" target="_blank" rel="noreferrer">利用font-face定义的字体怎么在canvas里应用</a></li></ul><h2 id="canvas图像处理" tabindex="-1">canvas图像处理 <a class="header-anchor" href="#canvas图像处理" aria-label="Permalink to &quot;canvas图像处理&quot;">​</a></h2><ul><li><a href="http://imweb.io/topic/59f5c4c0b72024f03c7f49bd" target="_blank" rel="noreferrer">利用canvas实现一个抠图小工具</a></li><li><a href="https://wcc723.github.io/canvas/2014/12/08/html5-canvas-02/" target="_blank" rel="noreferrer">試試看Canvas (2)，調整Canvas圖片色調</a>，可以将图片替换成其他颜色</li></ul><h2 id="性能优化" tabindex="-1">性能优化 <a class="header-anchor" href="#性能优化" aria-label="Permalink to &quot;性能优化&quot;">​</a></h2><p>需要遵循的「最佳实践」。</p><ul><li>将渲染阶段的开销转嫁到计算阶段之上。</li><li>使用多个分层的 Canvas 绘制复杂场景。</li><li>不要频繁设置绘图上下文的 font 属性。</li><li>不在动画中使用 putImageData 方法。</li><li>通过计算和判断，避免无谓的绘制操作。</li><li>将固定的内容预先绘制在离屏 Canvas 上以提高性能。</li><li>使用 Worker 和拆分任务的方法避免复杂算法阻塞动画运行。</li></ul><p><a href="http://taobaofed.org/blog/2016/02/22/canvas-performance/" target="_blank" rel="noreferrer">http://taobaofed.org/blog/2016/02/22/canvas-performance/</a></p><h2 id="扩展阅读" tabindex="-1">扩展阅读 <a class="header-anchor" href="#扩展阅读" aria-label="Permalink to &quot;扩展阅读&quot;">​</a></h2><h3 id="png压缩原理" tabindex="-1">PNG压缩原理 <a class="header-anchor" href="#png压缩原理" aria-label="Permalink to &quot;PNG压缩原理&quot;">​</a></h3><p>参考</p><ul><li><a href="https://segmentfault.com/a/1190000018557449" target="_blank" rel="noreferrer">PNG压缩原理</a></li></ul><p>PNG图片的数据结构其实跟http请求的结构很像，都是一个数据头，后面跟着很多的数据块。 <img src="https://segmentfault.com/img/bVbp1Nj?w=1000&amp;h=360" alt=""></p><p>使用编码模式打开png图片，得到的是一串十六进制编码，编码头部的<code>8950 4e47 0d0a 1a0a</code>代表该文件就是PNG图片，后续跟着图片的基础信息，然后是图片的颜色等信息</p><p>PNG压缩的基本思路是:将编码中大量重复的表示颜色的数字去掉，在解析时再还原回去，保证图片以较小的体积进行传输。颜色越单一，颜色值越少，颜色差异越小的png图片，压缩率就越大，体积就越小。</p><p>压缩主要分为两个过程</p><ul><li>预解析（Prediction），png图片用差分编码（Delta encoding）对图片进行预处理，处理每一个的像素点中每条通道的值，差分编码的目的是：尽可能的将png图片数据值转换成一组重复的、低的值，这样的值更容易被压缩</li><li>压缩（Compression）：执行Deflate压缩，移除重复的数据和无用的信息</li></ul>`,44),t=[l];function e(p,k,r,d,E,c){return i(),a("div",null,t)}const y=s(h,[["render",e]]);export{o as __pageData,y as default};
