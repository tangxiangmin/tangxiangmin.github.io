import{_ as s,c as i,o as a,a2 as l}from"./chunks/framework.DLPB9-dE.js";const g=JSON.parse('{"title":"数组","description":"","frontmatter":{},"headers":[],"relativePath":"数据结构和算法/数组.md","filePath":"数据结构和算法/数组.md","lastUpdated":1709648798000}'),t={name:"数据结构和算法/数组.md"},n=l(`<h1 id="数组" tabindex="-1">数组 <a class="header-anchor" href="#数组" aria-label="Permalink to &quot;数组&quot;">​</a></h1><h2 id="数组-1" tabindex="-1">数组 <a class="header-anchor" href="#数组-1" aria-label="Permalink to &quot;数组&quot;">​</a></h2><p>数组是绝大部分编程语言都内置的数据结构，用来存放一堆相同的元素，可以通过索引值访问数组中的元素。</p><p>遍历数组很简单，借助一个自增的索引值</p><div class="language-js vp-adaptive-theme"><button title="Copy Code" class="copy"></button><span class="lang">js</span><pre class="shiki shiki-themes github-light github-dark vp-code"><code><span class="line"><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">for</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">(</span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">let</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;"> i </span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">=</span><span style="--shiki-light:#005CC5;--shiki-dark:#79B8FF;"> 0</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">; i </span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">&lt;</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;"> arr.</span><span style="--shiki-light:#005CC5;--shiki-dark:#79B8FF;">length</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">;</span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">++</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">i) {</span></span>
<span class="line"><span style="--shiki-light:#6A737D;--shiki-dark:#6A737D;">    // arr[i]</span></span>
<span class="line"><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">}</span></span></code></pre></div><p>遍历数组是非常常用的功能，以至于某些语言可能还提供了其他快捷遍历数组的方法</p><div class="language-js vp-adaptive-theme"><button title="Copy Code" class="copy"></button><span class="lang">js</span><pre class="shiki shiki-themes github-light github-dark vp-code"><code><span class="line"><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">for</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">(</span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">const</span><span style="--shiki-light:#005CC5;--shiki-dark:#79B8FF;"> idx</span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;"> in</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;"> arr){</span></span>
<span class="line"><span style="--shiki-light:#6A737D;--shiki-dark:#6A737D;">    // </span></span>
<span class="line"><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">}</span></span>
<span class="line"><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">for</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">(</span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">const</span><span style="--shiki-light:#005CC5;--shiki-dark:#79B8FF;"> num</span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;"> of</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;"> arr){</span></span>
<span class="line"><span style="--shiki-light:#6A737D;--shiki-dark:#6A737D;">    //</span></span>
<span class="line"><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">}</span></span></code></pre></div><p>数组的很多题目都需要通过遍历</p><p>常见的数组题目包括</p><ul><li>数组的改变、移动</li><li>数组的旋转</li><li>统计数组中的元素</li><li>数组的遍历</li><li>二维数组及滚动数组</li><li>特定顺序遍历二维数组</li><li>二维数组变换</li><li>前缀和数组</li></ul><h3 id="调整数组顺序使奇数位于偶数前面" tabindex="-1">调整数组顺序使奇数位于偶数前面 <a class="header-anchor" href="#调整数组顺序使奇数位于偶数前面" aria-label="Permalink to &quot;调整数组顺序使奇数位于偶数前面&quot;">​</a></h3><p>使用前后两个指针，前后同时遍历，头指针遇见偶数、尾指针遇见奇数时交换位置</p><h3 id="从增序数组中找到和为s的两个数" tabindex="-1">从增序数组中找到和为S的两个数 <a class="header-anchor" href="#从增序数组中找到和为s的两个数" aria-label="Permalink to &quot;从增序数组中找到和为S的两个数&quot;">​</a></h3><ul><li>设定一个小索引left，从0开始，设定一个大索引right，从array.length开始</li><li>判断array[left] + array[right]的值s是否符合条件</li><li>符合条件 - 返回</li><li>大于sum，right向左移动；小于sum，left向右移动</li><li>若left=right，没有符合条件的结果</li></ul><h3 id="连续子数组的最大和" tabindex="-1">连续子数组的最大和 <a class="header-anchor" href="#连续子数组的最大和" aria-label="Permalink to &quot;连续子数组的最大和&quot;">​</a></h3><p><a href="https://leetcode-cn.com/explore/featured/card/array-and-string/201/two-pointer-technique/789/" target="_blank" rel="noreferrer">letcode传送门</a></p><ul><li>记录一个当前连续子数组最大值 max 默认值为数组第一项</li><li>记录一个当前连续子数组累加值 sum 默认值为数组第一项</li><li>从数组第二个数开始，若 sum&lt;0 则当前的sum不再对后面的累加有贡献，sum = 当前数</li><li>若 sum&gt;0 则sum = sum + 当前数</li><li>比较 sum 和 max ，max = 两者最大值</li></ul>`,17),e=[n];function h(p,r,k,d,o,c){return a(),i("div",null,e)}const u=s(t,[["render",h]]);export{g as __pageData,u as default};
