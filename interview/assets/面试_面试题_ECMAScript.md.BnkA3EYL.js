import{_ as s,c as a,o as i,a2 as n}from"./chunks/framework.DLPB9-dE.js";const g=JSON.parse('{"title":"","description":"","frontmatter":{},"headers":[],"relativePath":"面试/面试题/ECMAScript.md","filePath":"面试/面试题/ECMAScript.md","lastUpdated":1576499115000}'),l={name:"面试/面试题/ECMAScript.md"},e=n(`<h2 id="parseint-string-radix" tabindex="-1">parseInt(string, radix) <a class="header-anchor" href="#parseint-string-radix" aria-label="Permalink to &quot;parseInt(string, radix)&quot;">​</a></h2><p><code>parseInt(100, 40)</code>输出多少？由于<code>radix</code>的有效值在<code>2-36</code>之间，因此会输出<code>NAN</code></p><h2 id="_1-2-3-length" tabindex="-1">[1,2,,3,].length <a class="header-anchor" href="#_1-2-3-length" aria-label="Permalink to &quot;[1,2,,3,].length&quot;">​</a></h2><p>返回4，会默认忽略最后一个逗号，如果希望保留，则需要在末尾追加一位<code>[1,2,,3,,]</code></p><h2 id="作用域的规则" tabindex="-1">作用域的规则 <a class="header-anchor" href="#作用域的规则" aria-label="Permalink to &quot;作用域的规则&quot;">​</a></h2><p>JS的函数作用域的含义是指，属于这个函数的全部变量都可以在整个函数的范围内使用， 包含变量和函数在内的所有声明都会在任何代码执行前首先被处理。</p><ul><li>函数声明会提升，但函数表达式不会</li><li>函数声明提升优先级大于变量声明提升</li></ul><h2 id="描述一下作用域链" tabindex="-1">描述一下作用域链 <a class="header-anchor" href="#描述一下作用域链" aria-label="Permalink to &quot;描述一下作用域链&quot;">​</a></h2><p>JS里面的函数作用域和块级作用域都可以进行嵌套，当对变量进行<strong>右查询</strong>时，如果在当前作用域中无法找到某个变量时，引擎就会在外层嵌套的作用域继续查找，直到找到该变量或者抵达全局作用域为止，否则会抛出<strong>ReferenceError错误</strong>。这种一层一层查找变量的方式就是作用域链 扩展：</p><ul><li>左查询与右查询</li></ul><h2 id="谈谈你对于闭包的理解" tabindex="-1">谈谈你对于闭包的理解 <a class="header-anchor" href="#谈谈你对于闭包的理解" aria-label="Permalink to &quot;谈谈你对于闭包的理解&quot;">​</a></h2><p>JS里面的作用域是<strong>词法作用域</strong>，因此无论函数在哪里被调用，也无论它何时被调用，它的词法作用域都只由函数被声明时所处的位置决定。 对于不在函数内部声明却在函数内部使用的<strong>自由变量</strong>，同样遵循词法作用域的限制。当函数在其声明的词法作用域之外执行，仍旧可以访问函数声明时的词法作用域，此时就产生了闭包。</p><p>扩展：</p><ul><li>常见的闭包陷阱，如循环中的闭包</li><li>闭包的使用，如封装模块</li></ul><h2 id="this的指向" tabindex="-1">this的指向 <a class="header-anchor" href="#this的指向" aria-label="Permalink to &quot;this的指向&quot;">​</a></h2><p>虽然JS采用的是词法作用域，但this并不是在编写时绑定的，而是是在函数运行时自动绑定到函数作用域的，它的上下文取决于函数调用时的各种条件。</p><ul><li>函数是否在 new 中调用？如果是的话 this 绑定的是新创建的对象。</li><li>函数是否通过 call、apply（显式绑定）或者 bind 硬绑定调用？如果是的话，this 绑定的是 指定的对象。</li><li>函数是否在某个上下文对象中调用（隐式绑定）？如果是的话，this 绑定的是那个上下文对象。</li><li>如果都不是的话，使用默认绑定。如果在严格模式下，就绑定到 undefined，否则绑定到 全局对象。</li></ul><p>扩展：</p><ul><li>箭头函数</li></ul><h2 id="call和apply的相似和区别" tabindex="-1">call和apply的相似和区别 <a class="header-anchor" href="#call和apply的相似和区别" aria-label="Permalink to &quot;call和apply的相似和区别&quot;">​</a></h2><ul><li>都是改变函数内部的this指向</li><li>call后面的参数均表示函数的单个参数，apply的第二个参数用数组包含函数的多个参数</li></ul><h2 id="使用箭头函数有哪些注意事项" tabindex="-1">使用箭头函数有哪些注意事项 <a class="header-anchor" href="#使用箭头函数有哪些注意事项" aria-label="Permalink to &quot;使用箭头函数有哪些注意事项&quot;">​</a></h2><p>当回调函数需要动态this的时候，就不能使用箭头函数，比如jQuery中的事件绑定函数等，在其实现内部会手动进行this绑定。</p><h2 id="构造函数调用时发生了什么" tabindex="-1">构造函数调用时发生了什么 <a class="header-anchor" href="#构造函数调用时发生了什么" aria-label="Permalink to &quot;构造函数调用时发生了什么&quot;">​</a></h2><ul><li>创建了一个新对象</li><li>将新创建的空对象的隐式原型指向其构造函数的显示原型。</li><li>将this指向这个新对象</li><li>如果无返回值或者返回一个非对象值，则将新对象返回；如果返回值是一个新对象的话那么直接直接返回该对象。</li></ul><h3 id="函数中的arguments是数组吗-如何使用数组的方法" tabindex="-1">函数中的arguments是数组吗？如何使用数组的方法 <a class="header-anchor" href="#函数中的arguments是数组吗-如何使用数组的方法" aria-label="Permalink to &quot;函数中的arguments是数组吗？如何使用数组的方法&quot;">​</a></h3><p>是一个类数组对象，</p><ul><li>可以通过<code>Array.prototype.slice.call()</code>等方法使用数组方法</li><li>也可以将其转换成数组：<code>Array.from</code>、<code>[...arguments]</code>，然后再使用数组方法</li></ul><h3 id="如何编写代码实现构造函数不用new关键字会报错" tabindex="-1">如何编写代码实现构造函数不用new关键字会报错 <a class="header-anchor" href="#如何编写代码实现构造函数不用new关键字会报错" aria-label="Permalink to &quot;如何编写代码实现构造函数不用new关键字会报错&quot;">​</a></h3><p>使用<code>this instanceof XXX</code>判断</p><div class="language-js vp-adaptive-theme"><button title="Copy Code" class="copy"></button><span class="lang">js</span><pre class="shiki shiki-themes github-light github-dark vp-code"><code><span class="line"><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">function</span><span style="--shiki-light:#6F42C1;--shiki-dark:#B392F0;"> XXX</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">(</span><span style="--shiki-light:#E36209;--shiki-dark:#FFAB70;">username</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">, </span><span style="--shiki-light:#E36209;--shiki-dark:#FFAB70;">score</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">){</span></span>
<span class="line"><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">  if</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">(</span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">!</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">(</span><span style="--shiki-light:#005CC5;--shiki-dark:#79B8FF;">this</span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;"> instanceof</span><span style="--shiki-light:#6F42C1;--shiki-dark:#B392F0;"> Player</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">)){</span></span>
<span class="line"><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">    throw</span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;"> new</span><span style="--shiki-light:#6F42C1;--shiki-dark:#B392F0;"> Error</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">(</span><span style="--shiki-light:#032F62;--shiki-dark:#9ECBFF;">&#39;XXX must be called with new&#39;</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">)</span></span>
<span class="line"><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">  }</span></span>
<span class="line"></span>
<span class="line"><span style="--shiki-light:#6A737D;--shiki-dark:#6A737D;">  // ES2015 syntax</span></span>
<span class="line"><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">  if</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">(</span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">!new</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">.</span><span style="--shiki-light:#005CC5;--shiki-dark:#79B8FF;">target</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">){</span></span>
<span class="line"><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">    throw</span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;"> new</span><span style="--shiki-light:#6F42C1;--shiki-dark:#B392F0;"> Error</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">(</span><span style="--shiki-light:#032F62;--shiki-dark:#9ECBFF;">&#39;XXX must be called with new&#39;</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">)</span></span>
<span class="line"><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">  }</span></span>
<span class="line"><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">}</span></span></code></pre></div><p>Vue里面采用第一种实现</p><div class="language- vp-adaptive-theme"><button title="Copy Code" class="copy"></button><span class="lang"></span><pre class="shiki shiki-themes github-light github-dark vp-code"><code><span class="line"><span>function Vue (options) {</span></span>
<span class="line"><span>  if (!(this instanceof Vue)) {</span></span>
<span class="line"><span>    warn(&#39;Vue is a constructor and should be called with the \`new\` keyword&#39;)</span></span>
<span class="line"><span>  }</span></span>
<span class="line"><span>}</span></span></code></pre></div>`,33),t=[e];function h(p,r,d,k,o,c){return i(),a("div",null,t)}const u=s(l,[["render",h]]);export{g as __pageData,u as default};
