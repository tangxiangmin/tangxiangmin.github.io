import{_ as l,c as a,o as i,a2 as e}from"./chunks/framework.DLPB9-dE.js";const b=JSON.parse('{"title":"","description":"","frontmatter":{},"headers":[],"relativePath":"面试/面试题/网络.md","filePath":"面试/面试题/网络.md","lastUpdated":1683863238000}'),t={name:"面试/面试题/网络.md"},o=e('<h2 id="常见问题" tabindex="-1">常见问题 <a class="header-anchor" href="#常见问题" aria-label="Permalink to &quot;常见问题&quot;">​</a></h2><ul><li>GET 和 POST 的区别？常见状态码？</li><li>cookie和session的区别</li><li>HTTP中间人攻击</li><li>HTTPS的原理？证书是如何校验的？</li><li>HTTP2新特性</li></ul><h2 id="描述输入url到浏览器接收到html文档" tabindex="-1">描述输入URL到浏览器接收到HTML文档 <a class="header-anchor" href="#描述输入url到浏览器接收到html文档" aria-label="Permalink to &quot;描述输入URL到浏览器接收到HTML文档&quot;">​</a></h2><ul><li>浏览器需要解析URL，获取域名</li><li>委托操作系统进行DNS查询，获取域名对应的IP地址</li><li>操作系统协议栈构造套接字，建立套接字需要进行三次握手，断开连接需要进行四次挥手</li><li>TCP/IP包包含IP地址（寻找目标主机）和MAC地址（通过广播寻找下一个通向目标主机的中转设备），在网络传输中，包中的IP地址是不变的，但是MAC是会发生变化的。</li><li>在调制解调器器中对信号进行转换，数字信号 <code>&lt;-&gt;</code> 光、电信</li><li>服务器包含两个模块：等待连接模块和负责与客户端通信的模块，当新客户端发起请求时，就创建一个新的套接字</li><li>服务器根据URL，直接返回静态资源；或者调用对应的CGI程序，解析URL，调用对应的控制器方法，进行逻辑处理，最后生成填充数据后的模板，返回HTML文档</li><li>响应的HTML文档经过网络传输，如果数据量较大，将会被拆分成多个数据包，然后通过窗口号进行管理，最后还原数据</li><li>HTML文档最终被浏览器接收并解析，然后进行渲染</li></ul><h2 id="http状态码及其含义" tabindex="-1">HTTP状态码及其含义 <a class="header-anchor" href="#http状态码及其含义" aria-label="Permalink to &quot;HTTP状态码及其含义&quot;">​</a></h2><ul><li>1</li><li>2 成功</li><li>3 重定向</li><li>4 客户端错误</li><li>5 服务端错误</li></ul><h2 id="ajax请求中get和post的区别" tabindex="-1">ajax请求中get和post的区别 <a class="header-anchor" href="#ajax请求中get和post的区别" aria-label="Permalink to &quot;ajax请求中get和post的区别&quot;">​</a></h2><h2 id="说一说cdn的工作原理" tabindex="-1">说一说CDN的工作原理 <a class="header-anchor" href="#说一说cdn的工作原理" aria-label="Permalink to &quot;说一说CDN的工作原理&quot;">​</a></h2><p>当业务需要接入到 CDN 时，用户只需调整自己的 DNS 配置信息，将IP记录改为 CNAME 记录，将内容改为 CDN 厂商所提供的接入域名即可。 浏览器解析CDN域名，得到的是CNAME记录，再次对CNAME进行解析，得到CDN服务器的地址，接着访问对应的缓存服务器，缓存服务器会根据浏览器提供的域名，访问实际的数据服务器，获得响应后，一方面向浏览器返回数据，一方面缓存数据（后续访问在缓存失效前可直接返回数据）。</p><h2 id="https你了解吗" tabindex="-1">HTTPS你了解吗 <a class="header-anchor" href="#https你了解吗" aria-label="Permalink to &quot;HTTPS你了解吗&quot;">​</a></h2><p>由于http使用明文发送报文，因此容易发生中间人攻击，为了防止信息在网络传输过程中被修改，因此需要被通信内容进行加密，加密有两种方式：共享密钥加密和公开密钥加密。</p><p>为了防止共享密钥加密的密钥被窃取，同时为了避免公开密钥加密导致的效率问题，因此一般的处理方式是使用公开密钥加密传输共享密钥加密的密钥，然后使用共享密钥加密对通信内容进行加密。</p><p>为了保证上述过程中公开密钥的合法性，需要通过数字证书，由服务器运营人员申请，向第三方权威机构来进行认证。</p><h2 id="简单tcp三次握手和四次挥手的过程" tabindex="-1">简单TCP三次握手和四次挥手的过程 <a class="header-anchor" href="#简单tcp三次握手和四次挥手的过程" aria-label="Permalink to &quot;简单TCP三次握手和四次挥手的过程&quot;">​</a></h2><p>三次握手：</p><ul><li>客户端–发送带有SYN标志的数据包–一次握手–服务端</li><li>服务端–发送带有SYN/ACK标志的数据包–二次握手–客户端</li><li>客户端–发送带有带有ACK标志的数据包–三次握手–服务端</li></ul><p>四次挥手：</p><ul><li>客户端-发送一个FIN，用来关闭客户端到服务器的数据传送</li><li>服务器-收到这个FIN，它发回一个ACK，确认序号为收到的序号加1 。和SYN一样，一个FIN将占用一个序号</li><li>服务器-关闭与客户端的连接，发送一个FIN给客户端</li><li>客户端-发回ACK报文确认，并将确认序号设置为收到序号加1</li></ul><h2 id="跨域以及常见的解决方案" tabindex="-1">跨域以及常见的解决方案 <a class="header-anchor" href="#跨域以及常见的解决方案" aria-label="Permalink to &quot;跨域以及常见的解决方案&quot;">​</a></h2><p>同源策略：JavaScript脚本只能读取和所属文档来源相同的窗口和文档的属性。 浏览器处于安全性的考虑，对JavsScript做了同源限制，但是在某些时候，这些限制却过于严格了，在项目中常用的跨域措施有</p><ul><li>多个子域名之间的跨域,修改<code>document.domain</code></li><li>CORS跨域资源共享标准，服务器返回<code>Access-Control-Allow-Origin</code></li><li>JSONP，script标签的src属性不受同源限制</li><li>服务器代理</li><li>postMessage</li></ul><p>扩展：</p><ul><li>跨域请求多出的一次 OPTIONS 请求</li><li><code>Access-Control-Allow</code>其他头部</li><li>JSONP的实现与不足</li></ul><h2 id="谈谈你对于缓存的理解" tabindex="-1">谈谈你对于缓存的理解 <a class="header-anchor" href="#谈谈你对于缓存的理解" aria-label="Permalink to &quot;谈谈你对于缓存的理解&quot;">​</a></h2><p>Web缓存对于性能优化十分重要，可以有效减少HTTP请求。 Web缓存是指一个Web资源（如html页面，图片，js，数据等）存在于Web服务器和客户端（浏览器）之间的副本。下一个请求如果是相同的URL，则会根据缓存机制决定是直接使用副本响应访问请求，还是向源服务器再次发送请求</p><p>扩展：</p><ul><li><code>Cache-Control: max-age</code>和<code>Expries</code>的区别，前者指定资源的新鲜度秒数，后者指定资源的过期时间，由于服务器时区并不一定同步，因此后者优先级不如前者</li><li><code>no-cache</code>和<code>no-store</code>的区别 <ul><li>no-cache 在发布缓存副本之前，强制要求缓存把请求提交给原始服务器进行验证。</li><li>no-store 缓存不应存储有关客户端请求或服务器响应的任何内容。</li></ul></li></ul><h2 id="本地起了一个http-server-为什么只能在同一个wifi-局域网-上访问" tabindex="-1">本地起了一个http server，为什么只能在同一个WIFI(局域网)上访问？ <a class="header-anchor" href="#本地起了一个http-server-为什么只能在同一个wifi-局域网-上访问" aria-label="Permalink to &quot;本地起了一个http server，为什么只能在同一个WIFI(局域网)上访问？&quot;">​</a></h2><p>没有公网IP当然就不能被外网访问了。常见的WIFI情况下，一般的ip会是~192.168.0.x·这样的，只是对局域网(同WIFI下)可见，并没有部署到公开外网，因此外网是访问不了的。</p><h2 id="localhost、127-0-0-1、本机ip和inaddr-any的区别" tabindex="-1">localhost、127.0.0.1、本机ip和INADDR_ANY的区别 <a class="header-anchor" href="#localhost、127-0-0-1、本机ip和inaddr-any的区别" aria-label="Permalink to &quot;localhost、127.0.0.1、本机ip和INADDR_ANY的区别&quot;">​</a></h2><p>参考</p><ul><li><a href="http://blog.csdn.net/xifeijian/article/details/12879395" target="_blank" rel="noreferrer">http://blog.csdn.net/xifeijian/article/details/12879395</a></li><li><a href="http://blog.csdn.net/msdnwolaile/article/details/51278867" target="_blank" rel="noreferrer">http://blog.csdn.net/msdnwolaile/article/details/51278867</a></li></ul><p>解释</p><ul><li><p>localhost也叫local ，正确的解释是：本地服务器</p></li><li><p>127.0.0.1在windows等系统的正确解释是：本机地址（本机服务器）</p></li><li><p>localhot（local）是不经网卡传输！这点很重要，它不受网络防火墙和网卡相关的的限制。</p></li><li><p>127.0.0.1是通过网卡传输，依赖网卡，并受到网络防火墙和网卡相关的限制。</p></li></ul><p>IPv4的环回地址为：127.0.0.0到127.255.255.255都是环回地址（只是有两个特殊的保留），此地址中的任何地址都不会出现在网络中。所以说127.0.0.1是保留地址之一，只是被经常的使用，来检验本机TCP/IP协议栈而已</p><p>操作系统解析网络地址是有优先级的。 优先级最高的就是host查找，首先读取 然后是netbios广播查找，最后查找DNS。</p><h3 id="整理" tabindex="-1">整理 <a class="header-anchor" href="#整理" aria-label="Permalink to &quot;整理&quot;">​</a></h3><ul><li>localhost可以理解为一个域名，但是被系统解释为本机地址，因此不经网卡传输，不受网络防火墙和网卡相关的的限制</li><li>127.0.0.1是环回地址，是主机用于向自身发送通信的一个特殊地址，就可以绕开TCP/IP协议栈的下层，不用再通过什么链路层，物理层，以太网传出去了，而是可以直接在自己的网络层，运输层进行处理了</li><li>本机IP没什么好说的，在局域网有局域网的对应IP，因特网对于这个大局域网的入口IP而已</li></ul><h3 id="拓展" tabindex="-1">拓展 <a class="header-anchor" href="#拓展" aria-label="Permalink to &quot;拓展&quot;">​</a></h3><p>一个域名可以绑定多个ip吗？ 多用在负载均衡中。参考<a href="https://www.zhihu.com/question/36891472" target="_blank" rel="noreferrer">https://www.zhihu.com/question/36891472</a></p>',40),r=[o];function h(c,s,n,d,p,u){return i(),a("div",null,r)}const T=l(t,[["render",h]]);export{b as __pageData,T as default};
