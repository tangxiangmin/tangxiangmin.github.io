import{_ as i,c as s,o as a,a2 as l}from"./chunks/framework.DLPB9-dE.js";const g=JSON.parse('{"title":"","description":"","frontmatter":{},"headers":[],"relativePath":"前端/业务相关/多媒体.md","filePath":"前端/业务相关/多媒体.md","lastUpdated":1684907685000}'),e={name:"前端/业务相关/多媒体.md"},h=l(`<h2 id="音频" tabindex="-1">音频 <a class="header-anchor" href="#音频" aria-label="Permalink to &quot;音频&quot;">​</a></h2><p>部分前端业务需要播放音频，这里整理一下常见的问题</p><h3 id="格式兼容" tabindex="-1">格式兼容 <a class="header-anchor" href="#格式兼容" aria-label="Permalink to &quot;格式兼容&quot;">​</a></h3><p>不同的浏览器对音频格式的支持不同，Audio 标签默认支持的主流的音频文件格式有 MP3、WAV、OGG</p><ul><li>MP3（MPEG-1 Audio Layer 3）是一种使用有损压缩算法的音频格式。它能够显著减小文件大小，同时保持较高的音质。MP3 格式广泛应用于音乐下载和流媒体领域。由于其压缩算法的特性，MP3 文件的质量在一定程度上会受到影响，特别是低比特率的 MP3 文件可能会有明显的音质损失。</li><li>WAV（Waveform Audio File Format）是一种无损音频格式，以线性脉冲编码调制（LPCM）进行存储。它通常包含未经压缩的音频数据，因此质量保持较高。WAV 文件相对较大，适合存储音频的原始副本或需要保持最高音质的场景。</li><li>OGG 是一种开放的、免费的音频容器格式，支持多种音频编码，其中最常见的是 Vorbis 编码。OGG 文件可以提供较高的音质，并且在相对较小的文件大小下实现。相对于 MP3，OGG 可以在相同的比特率下提供更好的音频质量。然而，由于它的广泛兼容性相对较低，可能不被所有音频播放器或设备支持。</li></ul><p>总结一下</p><ul><li>WAV 格式音质最好，但是文件体积较大。</li><li>MP3 压缩率较高，普及率高，音质相比 WAV 要差。</li><li>OGG 与 MP3 在相同位速率(Bit Rate)编码的情况下，OGG 体积更小，并且 OGG 是免费的不用交专利费</li></ul><h3 id="自动播放" tabindex="-1">自动播放 <a class="header-anchor" href="#自动播放" aria-label="Permalink to &quot;自动播放&quot;">​</a></h3><p>出于用户体验和广告滥用的考虑，现代浏览器对自动播放音频有一些限制。通常情况下，需要用户与页面进行交互后，才能触发音频的自动播放。</p><div class="language-js vp-adaptive-theme"><button title="Copy Code" class="copy"></button><span class="lang">js</span><pre class="shiki shiki-themes github-light github-dark vp-code"><code><span class="line"><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">var</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;"> audio </span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">=</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;"> document.</span><span style="--shiki-light:#6F42C1;--shiki-dark:#B392F0;">querySelector</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">(</span><span style="--shiki-light:#032F62;--shiki-dark:#9ECBFF;">&#39;audio&#39;</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">);</span></span>
<span class="line"><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">document.</span><span style="--shiki-light:#6F42C1;--shiki-dark:#B392F0;">addEventListener</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">(</span><span style="--shiki-light:#032F62;--shiki-dark:#9ECBFF;">&#39;click&#39;</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">, </span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">function</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">() {</span></span>
<span class="line"><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">  audio.</span><span style="--shiki-light:#6F42C1;--shiki-dark:#B392F0;">play</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">();</span></span>
<span class="line"><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">});</span></span></code></pre></div><h3 id="预加载" tabindex="-1">预加载 <a class="header-anchor" href="#预加载" aria-label="Permalink to &quot;预加载&quot;">​</a></h3><p>在 iOS safari 浏览器初始化一个新的音频流时会有几秒的延时。原因是因为 iOS 需要实例化一个新的音频对象，再通过网络请求音频资源，音频资源加载完毕之后才能进行播放</p><p>preload可以指定音频的预加载策略，也就是在播放之前需要提前加载好音频的哪些资源。</p><div class="language-html vp-adaptive-theme"><button title="Copy Code" class="copy"></button><span class="lang">html</span><pre class="shiki shiki-themes github-light github-dark vp-code"><code><span class="line"><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">&lt;</span><span style="--shiki-light:#22863A;--shiki-dark:#85E89D;">audio</span><span style="--shiki-light:#6F42C1;--shiki-dark:#B392F0;"> src</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">=</span><span style="--shiki-light:#032F62;--shiki-dark:#9ECBFF;">&quot;audiofile.mp3&quot;</span><span style="--shiki-light:#6F42C1;--shiki-dark:#B392F0;"> preload</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">=</span><span style="--shiki-light:#032F62;--shiki-dark:#9ECBFF;">&quot;auto&quot;</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">&gt;&lt;/</span><span style="--shiki-light:#22863A;--shiki-dark:#85E89D;">audio</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">&gt;</span></span></code></pre></div><p>该属性有三个枚举值<code>none</code>、<code>metadata</code>、<code>auto</code>，查到某些说法是在iOS Safari浏览器下和微信浏览器中预加载并不会生效</p><p>也可以通过<code>load()</code>方法触发音频文件的加载。如果浏览器不支持preload属性，则此方法也不会有效果。</p><div class="language-js vp-adaptive-theme"><button title="Copy Code" class="copy"></button><span class="lang">js</span><pre class="shiki shiki-themes github-light github-dark vp-code"><code><span class="line"><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">audio.</span><span style="--shiki-light:#6F42C1;--shiki-dark:#B392F0;">load</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">();</span></span></code></pre></div><p>因此，音频预加载更通用的方案是：第一次触摸的时候，音频静音，同时触发音频play()然后很快再pause()，此时可以有类似preload的预加载行为。</p><h3 id="播放多个音频" tabindex="-1">播放多个音频 <a class="header-anchor" href="#播放多个音频" aria-label="Permalink to &quot;播放多个音频&quot;">​</a></h3><p>项目中有切换不同音乐播放，如果采用更改 Audio 标签的 src 的方式，iOS 下会出现不能播放音乐或者播放延迟太高问题。</p><p>这种 bug 出现的原因是音频文件不能缓存在 iOS 系统上，每当页面访问其他音频文件时，都从网络访问音频文件，</p><p>解决方法：可以在页面中声明多个 Audio 标签，把需要引入的音频文件预先引入，播放哪个再调用相应文件。</p><p>这个方案的缺点是在 iOS 系统下每一个 Audio 占一个线程，如果有多个的 Audio ，则很占资源</p><p>另外一个思路是把多个音频文件合并成为一个文件，播放其他音频的时候只需要调用合并之后的音频文件的相应时段，虽然比较繁琐，但是兼容性很好</p><h3 id="工具库" tabindex="-1">工具库 <a class="header-anchor" href="#工具库" aria-label="Permalink to &quot;工具库&quot;">​</a></h3><p>如果要做类似于网页音乐播放器之类的应用，可以考虑一些比较主流的音频工具库</p><ul><li><a href="https://howlerjs.com/" target="_blank" rel="noreferrer"><code>Howler.js</code></a>，提供了简单易用的 API，支持音频播放、暂停、音量控制、循环播放等功能，并具有优秀的性能和兼容性。</li></ul><h2 id="视频" tabindex="-1">视频 <a class="header-anchor" href="#视频" aria-label="Permalink to &quot;视频&quot;">​</a></h2><p>与音频类型，视频也是前端业务中比较常见的多媒体</p><h3 id="格式兼容-1" tabindex="-1">格式兼容 <a class="header-anchor" href="#格式兼容-1" aria-label="Permalink to &quot;格式兼容&quot;">​</a></h3><p>常见的视频格式如 MP4、WebM 和 Ogg 在不同浏览器上的支持情况可能有所差异</p><h3 id="自定义ui" tabindex="-1">自定义UI <a class="header-anchor" href="#自定义ui" aria-label="Permalink to &quot;自定义UI&quot;">​</a></h3><p>如果要自定义视频播放器，需要实现的组件包括</p><ul><li>操作按钮，如播放、暂停、音量控制等</li><li>进度条，拖拽控制播放进度</li><li>全屏，如果视频全屏播放则需要<a href="https://developer.mozilla.org/en-US/docs/Web/API/Fullscreen_API" target="_blank" rel="noreferrer">Fullscreen_API MDN</a></li></ul><h3 id="自动播放-1" tabindex="-1">自动播放 <a class="header-anchor" href="#自动播放-1" aria-label="Permalink to &quot;自动播放&quot;">​</a></h3><h3 id="外部字幕" tabindex="-1">外部字幕 <a class="header-anchor" href="#外部字幕" aria-label="Permalink to &quot;外部字幕&quot;">​</a></h3><h3 id="预加载-1" tabindex="-1">预加载 <a class="header-anchor" href="#预加载-1" aria-label="Permalink to &quot;预加载&quot;">​</a></h3><p>可以通过video标签的preload属性来控制视频预加载，加快视频资源的播放</p><ul><li>auto：浏览器将自动选择加载策略，默认值。浏览器可能会根据当前网络状况和设备性能自动决定何时加载视频。</li><li>metadata：仅加载视频的元数据（如时长、尺寸等），不加载视频内容。这对于获取视频信息而不立即播放视频很有用。</li><li>none：不预加载视频，直到用户明确要求播放视频才进行加载。</li></ul><p>可以通过<code>buffered</code>属性得到视频已被缓冲的部分</p><div class="language-js vp-adaptive-theme"><button title="Copy Code" class="copy"></button><span class="lang">js</span><pre class="shiki shiki-themes github-light github-dark vp-code"><code><span class="line"><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">video.</span><span style="--shiki-light:#6F42C1;--shiki-dark:#B392F0;">addEventListener</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">(</span><span style="--shiki-light:#032F62;--shiki-dark:#9ECBFF;">&#39;progress&#39;</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">, </span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">function</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">() {</span></span>
<span class="line"><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">  var</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;"> buffered </span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">=</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;"> video.buffered;</span></span>
<span class="line"><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">  if</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;"> (buffered.</span><span style="--shiki-light:#005CC5;--shiki-dark:#79B8FF;">length</span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;"> &gt;</span><span style="--shiki-light:#005CC5;--shiki-dark:#79B8FF;"> 0</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">) {</span></span>
<span class="line"><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">    console.</span><span style="--shiki-light:#6F42C1;--shiki-dark:#B392F0;">log</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">(</span><span style="--shiki-light:#032F62;--shiki-dark:#9ECBFF;">&#39;已缓冲的时间范围：&#39;</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">);</span></span>
<span class="line"><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">    for</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;"> (</span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">var</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;"> i </span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">=</span><span style="--shiki-light:#005CC5;--shiki-dark:#79B8FF;"> 0</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">; i </span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">&lt;</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;"> buffered.</span><span style="--shiki-light:#005CC5;--shiki-dark:#79B8FF;">length</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">; i</span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">++</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">) {</span></span>
<span class="line"><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">      console.</span><span style="--shiki-light:#6F42C1;--shiki-dark:#B392F0;">log</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">(</span><span style="--shiki-light:#032F62;--shiki-dark:#9ECBFF;">&#39;开始时间：&#39;</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">, buffered.</span><span style="--shiki-light:#6F42C1;--shiki-dark:#B392F0;">start</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">(i));</span></span>
<span class="line"><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">      console.</span><span style="--shiki-light:#6F42C1;--shiki-dark:#B392F0;">log</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">(</span><span style="--shiki-light:#032F62;--shiki-dark:#9ECBFF;">&#39;结束时间：&#39;</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">, buffered.</span><span style="--shiki-light:#6F42C1;--shiki-dark:#B392F0;">end</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">(i));</span></span>
<span class="line"><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">    }</span></span>
<span class="line"><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">  }</span></span>
<span class="line"><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">});</span></span></code></pre></div><h2 id="直播" tabindex="-1">直播 <a class="header-anchor" href="#直播" aria-label="Permalink to &quot;直播&quot;">​</a></h2><p>参考</p><ul><li><a href="https://blog.csdn.net/qq_34829447/article/details/83834796" target="_blank" rel="noreferrer">https://blog.csdn.net/qq_34829447/article/details/83834796</a></li><li><a href="https://segmentfault.com/a/1190000010440054%EF%BC%8C%E8%BF%99%E7%AF%87%E6%96%87%E7%AB%A0%E4%BB%8B%E7%BB%8D%E7%9A%84%E5%BE%88%E8%AF%A6%E7%BB%86" target="_blank" rel="noreferrer">https://segmentfault.com/a/1190000010440054，这篇文章介绍的很详细</a></li></ul><h3 id="直播视频格式" tabindex="-1">直播视频格式 <a class="header-anchor" href="#直播视频格式" aria-label="Permalink to &quot;直播视频格式&quot;">​</a></h3><ul><li>hls更准确的说是一种视频协议，文件对应的后缀是ts，适配Safari浏览器，是苹果推出的视频协议</li><li>flv是早期的flash格式</li><li>MP4和WEBM是偏点播使用的视频格式（如爱奇艺）</li><li>TS和FLV是偏直播使用的视频格式（如斗鱼）</li></ul><h3 id="常用协议" tabindex="-1">常用协议 <a class="header-anchor" href="#常用协议" aria-label="Permalink to &quot;常用协议&quot;">​</a></h3><ul><li>hls协议，播放器使用video作为点播和直播的基石（将M3U8索引文件[是ts文件的索引]给video进行播放，播放时会被解析成多个ts直播流片段，浏览器会实时向服务器请求M3U8文件里面是每个片段，之后会再次下载，之后会再次请求M3U8等等，从而保证直播的实时和连续）</li><li>RTMP协议（开发客户端通常采用），TMP是Real Time Messaging Protocol（实时消息传输协议）的首字母缩写。该协议基于TCP，是一个协议族，包括RTMP基本协议及RTMPT/RTMPS/RTMPE等多种变种。RTMP是一种设计用来进行实时数据通信的网络协议，主要用来在Flash、AIR平台和支持RTMP协议的流媒体/交互服务器之间进行音视频和数据通信。</li><li>HTTP-FLV协议（兼备RTMP低延时和HLS传输快的特性，视频格式是FLV）</li></ul><h3 id="hls" tabindex="-1">hls <a class="header-anchor" href="#hls" aria-label="Permalink to &quot;hls&quot;">​</a></h3><p>接口返回一个hls的链接 ，然后交给客户端播放即可</p><p>todo</p>`,51),t=[h];function n(p,k,r,d,E,o){return a(),s("div",null,t)}const u=i(e,[["render",n]]);export{g as __pageData,u as default};
