import{_ as a,c as e,o as p,a2 as r}from"./chunks/framework.DLPB9-dE.js";const P=JSON.parse('{"title":"","description":"","frontmatter":{},"headers":[],"relativePath":"计算机基础/软件工程.md","filePath":"计算机基础/软件工程.md","lastUpdated":1709042257000}'),t={name:"计算机基础/软件工程.md"},i=r('<h2 id="概念" tabindex="-1">概念 <a class="header-anchor" href="#概念" aria-label="Permalink to &quot;概念&quot;">​</a></h2><p>软件工程是涉及开发、设计、测试、维护和管理软件的系统化、规范化的过程。它涵盖了许多关键概念和活动，以下是软件工程的主要组成部分：</p><p>软件需求工程：确定和定义软件系统的需求，包括功能需求、性能需求、用户需求等，以确保软件满足用户的期望。</p><p>软件设计：在需求的基础上，制定软件的整体结构和组织，包括模块划分、接口设计、数据结构设计等，以实现软件的可扩展性、可维护性和可重用性。</p><p>软件构建：实际编码和实现软件设计，将设计转化为可执行的程序代码，采用适当的编程语言和开发工具。</p><p>软件测试：进行各种测试活动，包括单元测试、集成测试、系统测试和验收测试，以验证软件的功能、性能和质量，并发现和修复潜在的错误和缺陷。</p><p>软件部署：将软件部署到目标环境中，配置和安装所需的硬件和软件环境，确保软件能够正确运行并满足用户的需求。</p><p>软件维护：对软件进行修复、改进和升级，以满足用户的新需求、修复已知问题，并确保软件的可靠性和可用性。</p><p>软件项目管理：规划、组织和控制软件项目的各个方面，包括资源管理、进度管理、风险管理等，以确保项目按时、按质量要求完成。</p><p>质量保证：实施质量管理活动，包括代码审查、性能优化、质量度量和过程改进等，以确保软件达到高质量标准。</p><p>配置管理：管理软件开发过程中的版本控制、配置控制和变更管理，以确保软件的可追溯性和一致性。</p><p>软件工程伦理：考虑和遵守与软件开发相关的伦理原则和法律要求，包括隐私保护、知识产权和软件许可等。</p><p>这些组成部分相互交织，构成了软件工程的全面过程，旨在开发高质量、可靠和可维护的软件系统。</p><h2 id="程序设计原则" tabindex="-1">程序设计原则 <a class="header-anchor" href="#程序设计原则" aria-label="Permalink to &quot;程序设计原则&quot;">​</a></h2><p>程序设计原则是在软件开发过程中指导代码编写的基本准则，通常被称为SOLID原则，它们是面向对象设计和编程的基石：</p><p>单一职责原则（Single Responsibility Principle - SRP）： 意味着一个类应该只有一个修改的理由。换句话说，一个类应该只有一个责任。这有助于降低类的复杂性，并使其更容易理解和维护。</p><p>开放/封闭原则（Open/Closed Principle - OCP）： 意味着软件实体（类、模块、函数等）应该对扩展开放，但对修改封闭。通过这个原则，可以通过添加新功能来扩展系统，而不必修改已有的代码。</p><p>里氏替换原则（Liskov Substitution Principle - LSP）： 表明子类型（派生类或子类）应该能够替代其基类型（基类或父类）而不影响程序的正确性。即，如果一个程序中使用了基类，替换为其子类不应该引起程序错误。</p><p>迪米特法则（Law of Demeter）： 也称为最少知识原则，强调一个对象应该对其他对象有最少的了解。换句话说，一个类不应该直接调用其他对象的内部细节，而应该通过接口进行通信，降低对象之间的耦合度。</p><p>接口隔离原则（Interface Segregation Principle - ISP）： 意味着一个类不应该被迫实现它不使用的接口。应该创建多个专门的接口，而不是一个庞大的通用接口，以便类只需实现其相关的接口。</p><p>依赖反转原则（Dependency Inversion Principle - DIP）： 表明高层模块不应该依赖于低层模块，而两者都应该依赖于抽象。抽象不应该依赖于具体实现，而具体实现应该依赖于抽象。这有助于降低模块间的耦合性。</p><p>此外还有一个合成/聚合原则（Composition/Aggregation Principle - CAP）： 意味着应该优先使用合成或聚合关系，而不是继承关系，以实现代码重用和灵活性。通过组合现有的类来创建新的类，而不是通过继承来达到代码重用的目的</p><p>SOLID主要关注类的设计和关系，而CAP关注对象的组合和关联</p><h2 id="设计模式" tabindex="-1">设计模式 <a class="header-anchor" href="#设计模式" aria-label="Permalink to &quot;设计模式&quot;">​</a></h2><p>设计模式</p><p>参考</p><ul><li>博客整理：<a href="https://www.shymean.com/article/%E5%9C%A8%E5%89%8D%E7%AB%AF%E4%B8%9A%E5%8A%A1%E5%9C%BA%E6%99%AF%E4%B8%8B%E7%9A%84%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F" target="_blank" rel="noreferrer">在前端业务场景下的设计模式</a></li><li>《深入PHP 面向对象、模式与实践》</li><li><a href="https://mp.weixin.qq.com/s/X2St9iPXPB0hkXsDiulxIQ" target="_blank" rel="noreferrer">JavaScript设计模式经典-面向对象中六大原则</a></li><li><a href="https://juejin.im/post/5dfde295e51d45580359a663#heading-2" target="_blank" rel="noreferrer">JavaScript设计模式笔记：3个设计原则、14个设计模式、9个技巧（干货）介绍</a></li></ul><p>软件工程的难点在于变化，对于迭代而言，最优的做法是横向扩展代码，而不是去旧代码里面修改，这样可以极大程度降低对旧代码的影响，节省调试、测试和后续维护的成本。</p><p>设计模式就是一些教大家解耦封装代码的方式。</p><h3 id="发布-订阅模式-观察者模式" tabindex="-1">发布-订阅模式（观察者模式） <a class="header-anchor" href="#发布-订阅模式-观察者模式" aria-label="Permalink to &quot;发布-订阅模式（观察者模式）&quot;">​</a></h3><p>应用：eventBus</p><p>观察者模式：没有第三者进入，发布者和订阅者直接交互 发布订阅模式：发布者和订阅者通过第三者</p><h3 id="工厂模式" tabindex="-1">工厂模式 <a class="header-anchor" href="#工厂模式" aria-label="Permalink to &quot;工厂模式&quot;">​</a></h3><p>应用：ActionCreator</p><p>封装各种创建对象的细节逻辑</p><h3 id="单例模式" tabindex="-1">单例模式 <a class="header-anchor" href="#单例模式" aria-label="Permalink to &quot;单例模式&quot;">​</a></h3><p>应用：网络请求单例、本地数据存储单例、弹窗</p><p>可以通过static静态属性或者闭包实现</p><h3 id="代理模式" tabindex="-1">代理模式 <a class="header-anchor" href="#代理模式" aria-label="Permalink to &quot;代理模式&quot;">​</a></h3><p>代理模式封装了对于某个对象访问和操作的逻辑，所有逻辑均通过代理进行，</p><p>应用：ES6的<code>Proxy</code></p><h3 id="装饰器模式" tabindex="-1">装饰器模式 <a class="header-anchor" href="#装饰器模式" aria-label="Permalink to &quot;装饰器模式&quot;">​</a></h3><p>应用：中间件</p><p>在不影响原有逻辑的前提下增量添加新的功能</p><h3 id="策略模式" tabindex="-1">策略模式 <a class="header-anchor" href="#策略模式" aria-label="Permalink to &quot;策略模式&quot;">​</a></h3><p>应用：表单验证、重构<code>if...else</code></p><p>将各种逻辑规则封装成单个的策略，然后根据参数运行某个策略即可</p><h3 id="原型模式" tabindex="-1">原型模式 <a class="header-anchor" href="#原型模式" aria-label="Permalink to &quot;原型模式&quot;">​</a></h3><p>主要是从一个对象复制得到一个新的对象，可以复用现有对象的一些数据</p><p>在JS中主要考察对象的深拷贝</p>',50),o=[i];function l(n,h,s,c,d,_){return p(),e("div",null,o)}const f=a(t,[["render",l]]);export{P as __pageData,f as default};
