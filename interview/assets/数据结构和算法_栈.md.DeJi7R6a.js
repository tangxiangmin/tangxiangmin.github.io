import{_ as e,c as a,o as t,a2 as r}from"./chunks/framework.DLPB9-dE.js";const f=JSON.parse('{"title":"","description":"","frontmatter":{},"headers":[],"relativePath":"数据结构和算法/栈.md","filePath":"数据结构和算法/栈.md","lastUpdated":1709648798000}'),o={name:"数据结构和算法/栈.md"},l=r('<h2 id="单调栈" tabindex="-1">单调栈 <a class="header-anchor" href="#单调栈" aria-label="Permalink to &quot;单调栈&quot;">​</a></h2><p>参考：</p><ul><li><a href="https://mp.weixin.qq.com/s/OQJxZbFkFbt6uT_-1B2s_Q" target="_blank" rel="noreferrer">https://mp.weixin.qq.com/s/OQJxZbFkFbt6uT_-1B2s_Q</a></li><li><a href="https://www.jianshu.com/p/6bbd3653a57f" target="_blank" rel="noreferrer">https://www.jianshu.com/p/6bbd3653a57f</a></li></ul><p>而所谓 单调栈 则是在栈的 先进后出 基础之上额外添加一个特性：从栈顶到栈底的元素是严格递增（or递减）。</p><p>具体进栈过程如下：</p><ul><li>对于单调递增栈，若当前进栈元素为 e，从栈顶开始遍历元素，把小于 e 或者等于 e 的元素弹出栈，直接遇到一个大于 e 的元素或者栈为空为止，然后再把 e 压入栈中。</li><li>对于单调递减栈，则每次弹出的是大于 e 或者等于 e 的元素。</li></ul><h2 id="实现最小栈" tabindex="-1">实现最小栈 <a class="header-anchor" href="#实现最小栈" aria-label="Permalink to &quot;实现最小栈&quot;">​</a></h2><p>使用两个栈，一个栈A保存原始数据，一个栈B在每次入栈时与B栈顶元素进行比较，如果比其小则入栈，如果比起大则将栈顶元素再次入栈，保证栈顶是最小元素。两个栈出栈时需要同时出栈。</p><h3 id="给定栈的入栈顺序-判断给定列表是否满足其出栈顺序" tabindex="-1">给定栈的入栈顺序，判断给定列表是否满足其出栈顺序 <a class="header-anchor" href="#给定栈的入栈顺序-判断给定列表是否满足其出栈顺序" aria-label="Permalink to &quot;给定栈的入栈顺序，判断给定列表是否满足其出栈顺序&quot;">​</a></h3><p><a href="http://www.conardli.top/docs/dataStructure/%E6%A0%88%E5%92%8C%E9%98%9F%E5%88%97/%E6%A0%88%E7%9A%84%E5%8E%8B%E5%85%A5%E5%BC%B9%E5%87%BA%E5%BA%8F%E5%88%97.html#%E6%80%9D%E8%B7%AF" target="_blank" rel="noreferrer">参考</a></p><p>入栈顺序pushV<code>[1,2,3,4,5]</code>，判断出栈顺序popV<code>[4,5,3,2,1]</code>是否合法</p><ul><li>首先找到popV顶部的元素4，然后将pushV中该idx对应索引值后面的元素[5]认为未入栈，则pushV为[1,2,3,4]</li><li>将popV和pushV顶部元素4弹出，重复步骤1，popV[1,2,3,4]顶部元素为5，pushV中不包含5，则从未入栈元素中一次入栈，直至找到5为止,此时pushV为[1,2,3,5]</li><li>当pushV为空时表示满足出栈顺序</li></ul>',12),p=[l];function i(s,h,n,c,_,d){return t(),a("div",null,p)}const m=e(o,[["render",i]]);export{f as __pageData,m as default};
