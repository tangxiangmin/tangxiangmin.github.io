import{_ as a,c as e,o as t,a2 as s}from"./chunks/framework.DLPB9-dE.js";const b=JSON.parse('{"title":"web安全","description":"","frontmatter":{},"headers":[],"relativePath":"前端/业务相关/web安全.md","filePath":"前端/业务相关/web安全.md","lastUpdated":1646554062000}'),i={name:"前端/业务相关/web安全.md"},r=s(`<h1 id="web安全" tabindex="-1">web安全 <a class="header-anchor" href="#web安全" aria-label="Permalink to &quot;web安全&quot;">​</a></h1><p>参考：<a href="https://developer.mozilla.org/zh-CN/docs/Web/Security" target="_blank" rel="noreferrer">Web 安全 - MDN</a></p><h2 id="javascript语言安全" tabindex="-1">JavaScript语言安全 <a class="header-anchor" href="#javascript语言安全" aria-label="Permalink to &quot;JavaScript语言安全&quot;">​</a></h2><h3 id="js原型污染" tabindex="-1">JS原型污染 <a class="header-anchor" href="#js原型污染" aria-label="Permalink to &quot;JS原型污染&quot;">​</a></h3><p>攻击者通过某种手段修改 JavaScript 对象的原型（prototype），然后影响浏览器或NodeJS环境下的代码</p><p>参考</p><ul><li><a href="https://juejin.im/post/5d271332f265da1b934e2d48" target="_blank" rel="noreferrer">最新：Lodash 严重安全漏洞背后你不得不知道的 JavaScript 知识</a></li><li><a href="https://juejin.cn/post/6963950629240733727" target="_blank" rel="noreferrer">前端原型链污染漏洞竟可以拿下服务器shell？</a></li></ul><p>在使用<code>merge</code>、<code>extend</code>等方法时，如果被恶意参数修改了JavaScript内置原型对象的方法<code>如Object.prototype.toString</code>之类的，就可能产生攻击。</p><h3 id="如何防止代码被调试" tabindex="-1">如何防止代码被调试 <a class="header-anchor" href="#如何防止代码被调试" aria-label="Permalink to &quot;如何防止代码被调试&quot;">​</a></h3><p>页面不断debugger，当调试模式打开时，就会阻塞代码执行，当时间超过阈值，就发送到服务端并拉黑该ip</p><div class="language-js vp-adaptive-theme"><button title="Copy Code" class="copy"></button><span class="lang">js</span><pre class="shiki shiki-themes github-light github-dark vp-code"><code><span class="line"><span style="--shiki-light:#6F42C1;--shiki-dark:#B392F0;">setInterval</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">(()</span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">=&gt;</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">{</span></span>
<span class="line"><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">    debugger</span></span>
<span class="line"><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">    console.</span><span style="--shiki-light:#6F42C1;--shiki-dark:#B392F0;">log</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">(</span><span style="--shiki-light:#032F62;--shiki-dark:#9ECBFF;">&#39;check in debug mode&#39;</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">)</span></span>
<span class="line"><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">},</span><span style="--shiki-light:#005CC5;--shiki-dark:#79B8FF;">400</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">)</span></span></code></pre></div><p>对应的破解方案：<a href="https://segmentfault.com/a/1190000012359015" target="_blank" rel="noreferrer">突破前端反调试--阻止页面不断debugger</a>，可以通过Chrome控制台的<code>Deactivate breakpoints</code>禁用断点。此外还可以直接修改源码，然后通过网络代理替换修改后的js文件。</p><p>所以前端代码大部分时候都是在浏览器中裸奔的，即使进行了压缩、混淆等方式，只要有心，还是会被破解，因此比较重要的核心逻辑，还是需要放在后端进行校验和处理。</p><h2 id="web前端安全" tabindex="-1">web前端安全 <a class="header-anchor" href="#web前端安全" aria-label="Permalink to &quot;web前端安全&quot;">​</a></h2><p>前端安全主要表现为通过浏览器间接影响到用户数据的安全问题。</p><h3 id="xss" tabindex="-1">XSS <a class="header-anchor" href="#xss" aria-label="Permalink to &quot;XSS&quot;">​</a></h3><p>跨站脚本攻击(Cross Site Scripting)指的是恶意攻击者往Web页面里插入恶意Script代码，当用户浏览该页时，嵌入其中Web里面的Script代码会被执行（注入的JS代码跟网页原有的 JS 有同样的权限），从而达到恶意攻击用户的目的（比如盗取用户的cookie）。</p><p>有下列分类反射性XSS、储存性XSS、DOM XSS等类型。</p><p>XSS的问题是找到目标网站可插入执行脚本的漏洞，比如某段编辑内容，如果不处理用户的输入就直接存储到数据库中，则用户访问对页面时，恶意脚本被渲染到页面上，就可能执行对应的攻击。</p><p>可见XSS的攻击目标是访问带有漏洞页面的这些客户端用户，常见的攻击目的有</p><ul><li>利用JS获取访问用户的身份信息如cookie等，获取相关身份权限，然后执行相关操作</li><li>劫持网站，劫持后用于钓鱼、挂广告、挂木马等行为</li></ul><p>因此不要信任用户的输入，过滤掉常见的标签，script alert 尖括号&lt;&gt;等，在输入一些敏感字符的时候，要进行编码转换。此外对比较敏感的cookie进行<code>http-only</code>限制，禁止客户端JS的访问权限</p><h3 id="csrf" tabindex="-1">CSRF <a class="header-anchor" href="#csrf" aria-label="Permalink to &quot;CSRF&quot;">​</a></h3><p>跨站请求伪造，指的是用了当前操作者的权限来偷偷地完成某个操作，比如目标网站的删除文章功能接受到来自恶意网站客户端发出的删除文章请求，这个请求是跨站点的，并且是伪造的（不是目标网站用户的本意）。</p><p>实现方式是在恶意网站上先构建一个GET请求（由于Ajax的同源限制，可以使用img的src请求等），然后欺骗目标网站用户访问该恶意网站，则在访问时会发起对应请求（并附带对应的Cookie等用户识别信息），此时攻击也会发生</p><p>可以通过检查origin和reffer、<code>samesite cookie</code>、表单提交时增加随机token参数等方式避免攻击</p><p>参考：</p><ul><li><a href="https://juejin.im/post/58c669b6a22b9d0058b3c630" target="_blank" rel="noreferrer"> 跨站请求伪造已死！</a></li><li><a href="https://juejin.im/post/5c8a33dcf265da2dc538fc7d" target="_blank" rel="noreferrer">Cookie的SameSite属性</a></li></ul><h3 id="界面操作劫持" tabindex="-1">界面操作劫持 <a class="header-anchor" href="#界面操作劫持" aria-label="Permalink to &quot;界面操作劫持&quot;">​</a></h3><p>伪造钓鱼网站、嵌套iframe等</p><p>攻击者会发送给受害者一个合法链接，当链接被点击时，用户被导向一个似是而非的非法网站，从而达到骗取用户信任、窃取用户资料的目的。</p><h2 id="后端安全" tabindex="-1">后端安全 <a class="header-anchor" href="#后端安全" aria-label="Permalink to &quot;后端安全&quot;">​</a></h2><h3 id="sql注入" tabindex="-1">SQL注入 <a class="header-anchor" href="#sql注入" aria-label="Permalink to &quot;SQL注入&quot;">​</a></h3><p>恶意用户在前端的表单字段中进行SQL拼装，如果对用户的表单提交不进行校验，后端直接拿到数据就拼接 SQL 语句去查询数据库，最后生成的SQL就会有问题。</p><p>比如</p><div class="language- vp-adaptive-theme"><button title="Copy Code" class="copy"></button><span class="lang"></span><pre class="shiki shiki-themes github-light github-dark vp-code"><code><span class="line"><span>strSQL = &quot;SELECT * FROM users WHERE (name = &#39;&quot; + userName + &quot;&#39;) and (pw = &#39;&quot;+ passWord +&quot;&#39;);&quot;</span></span></code></pre></div><p>其中userName和passWord是用户提交的参数，如果不进行校验，恶意用户提交了</p><div class="language- vp-adaptive-theme"><button title="Copy Code" class="copy"></button><span class="lang"></span><pre class="shiki shiki-themes github-light github-dark vp-code"><code><span class="line"><span>userName = &quot;1&#39; OR &#39;1&#39;=&#39;1&quot;;</span></span></code></pre></div><p>那么拼接得到的SQL语句就变成了</p><div class="language- vp-adaptive-theme"><button title="Copy Code" class="copy"></button><span class="lang"></span><pre class="shiki shiki-themes github-light github-dark vp-code"><code><span class="line"><span>strSQL = &quot;SELECT * FROM users WHERE (name = &#39;1&#39; OR &#39;1&#39;=&#39;1&#39;) and (pw = &#39;1&#39; OR &#39;1&#39;=&#39;1&#39;);&quot;</span></span></code></pre></div><p>实际上执行的SQL变成了</p><div class="language- vp-adaptive-theme"><button title="Copy Code" class="copy"></button><span class="lang"></span><pre class="shiki shiki-themes github-light github-dark vp-code"><code><span class="line"><span>strSQL = &quot;SELECT * FROM users;&quot;</span></span></code></pre></div><p>也就是说根据不需要账号和密码，也能够登陆网站了。</p><p>目前大部分后台ORM框架都支持<a href="https://zh.wikipedia.org/wiki/%E5%8F%83%E6%95%B8%E5%8C%96%E6%9F%A5%E8%A9%A2" target="_blank" rel="noreferrer">参数化查询</a>，这是目前被认为最有效的预防SQL注入的防御手段。</p><p>其原理是：数据库服务器不会将参数的内容视为SQL指令的一部分来处理，而是在数据库完成SQL指令的编译后，才套用参数运行，因此就算参数中含有具破坏性的指令，也不会被数据库所运行。</p><h3 id="文件上传攻击" tabindex="-1">文件上传攻击 <a class="header-anchor" href="#文件上传攻击" aria-label="Permalink to &quot;文件上传攻击&quot;">​</a></h3><p>用户上传一个可执行的脚本文件，并通过此脚本文件获得了执行服务端命令的能力。</p><ul><li>文件上传的目录设置为不可执行</li><li>判断文件类型。</li><li>对上传的文件类型进行白名单校验，只允许上传可靠类型。</li><li>上传的文件需要进行重新命名，使攻击者无法猜想上传文件的访问路径，将极大地增加攻击成本。</li><li>限制上传文件的大小。</li><li>单独设置文件服务器的域名。</li></ul><h2 id="网络安全" tabindex="-1">网络安全 <a class="header-anchor" href="#网络安全" aria-label="Permalink to &quot;网络安全&quot;">​</a></h2><h3 id="http-heads攻击" tabindex="-1">Http Heads攻击 <a class="header-anchor" href="#http-heads攻击" aria-label="Permalink to &quot;Http Heads攻击&quot;">​</a></h3><p>攻击者想办法让目标机器停止提供服务：</p><p>一是使用<a href="https://zh.wikipedia.org/wiki/SYN_flood" target="_blank" rel="noreferrer">SYN flood</a>迫使服务器的缓冲区满，不接收新的请求；</p><p>TCP建立连接时会进行三次握手，客户端发出SYN，服务器响应ACK-SYN，同时等待客户端的ACK消息，恶意客户端如果一直不发送ACK消息，都会使服务器花点时间等待ACK，浪费资源，而正常的用户可能因为网路堵塞无法建立正确的链接。</p><p>SYN flood对于现代网络而言貌似已经没啥用了。</p><p>二是使用IP欺骗，迫使服务器把非法用户的连接复位，影响合法用户的连接</p><h3 id="中间人攻击" tabindex="-1">中间人攻击 <a class="header-anchor" href="#中间人攻击" aria-label="Permalink to &quot;中间人攻击&quot;">​</a></h3><p>中间人攻击(Man-in-the-MiddleAttack，简称“MITM攻击”)是指攻击者与通讯的两端分别创建独立的联系，并交换其所收到的数据，使通讯的两端认为他们正在通过一个私密的连接与对方 直接对话，但事实上整个会话都被攻击者完全控制。</p><p>大致过程如下</p><ul><li>服务器向客户端发送公钥。</li><li>攻击者截获公钥，保留在自己手上。然后攻击者自己生成一个【伪造的】公钥，发给客户端。</li><li>客户端收到伪造的公钥后，生成加密hash值发给服务器。</li><li>攻击者获得加密hash值，用自己的私钥解密获得真秘钥。同时生成假的加密hash值，发给服务器。</li><li>服务器用私钥解密获得假秘钥。</li></ul><p>Fider、Charles等抓包工具实际上就是使用这种方式来截获https的信息的，因此当浏览器提示 遇见不可信任的证书时，需要注意证书的安全性。</p><h3 id="子资源完整性" tabindex="-1">子资源完整性 <a class="header-anchor" href="#子资源完整性" aria-label="Permalink to &quot;子资源完整性&quot;">​</a></h3><p>参考:<a href="https://developer.mozilla.org/zh-CN/docs/Web/Security/Subresource_Integrity" target="_blank" rel="noreferrer">Subresource Integrity</a></p><p>由于前端大部分资源如图片、js、css等都是通过链接进行请求，一般资源都是放在CDN上面的，如果，经常遇见的http请求导致运营商劫持插入广告等情况</p><blockquote><p>子资源完整性通过确保 Web 应用程序获得的文件未经第三方注入或其他任何形式的修改来降低这种攻击的风险。</p></blockquote><p>使用方式：将使用 base64 编码过后的文件哈希值写入你所引用的 <code>&lt;script&gt;</code> 或 <code>&lt;link&gt;</code> 标签的 integrity 属性值中即可启用子资源完整性功能。</p><p>存在一定兼容性问题，且校验不通过会导致整个文件加载失败，如果是单页应用，则可能导致页面空白，这种结果可能更不能接受，因此目前这个属性应用场景较少</p>`,66),l=[r];function p(o,n,h,d,c,u){return t(),e("div",null,l)}const g=a(i,[["render",p]]);export{b as __pageData,g as default};
