import{_ as e,c as a,o as t,a2 as l}from"./chunks/framework.DLPB9-dE.js";const _=JSON.parse('{"title":"","description":"","frontmatter":{},"headers":[],"relativePath":"前端/库与框架/Immutable.md","filePath":"前端/库与框架/Immutable.md","lastUpdated":1620234346000}'),r={name:"前端/库与框架/Immutable.md"},i=l('<p>参考</p><ul><li><p><a href="https://github.com/immutable-js/immutable-js" target="_blank" rel="noreferrer">immutable-js 项目源码</a></p></li><li><p><a href="https://github.com/ronffy/immer-tutorial" target="_blank" rel="noreferrer">immer-tutorial</a></p></li><li><p><a href="https://www.cnblogs.com/greatluoluo/p/8469224.html" target="_blank" rel="noreferrer">在react/redux中使用Immutable</a></p></li></ul><h2 id="为什么使用immutable" tabindex="-1">为什么使用Immutable <a class="header-anchor" href="#为什么使用immutable" aria-label="Permalink to &quot;为什么使用Immutable&quot;">​</a></h2><p>React.js 是一个 UI = f(states) 的框架，为了解决更新的问题， React.js 使用了 virtual dom ， virtual dom 通过 diff 修改 dom ，来实现高效的 dom 更新。</p><p>但是有一个问题。当 state 更新时，如果数据没变，你也会去做 virtual dom 的 diff ，这就产生了浪费。这种情况其实很常见</p><p>可以使用PureComponent来避免不必要的更新，但其只是浅比较，无法判断组件的修改？自己去做复杂比较的话，性能又会非常差</p><p>在react中为了保证纯函数和state的变化，需要写大量的{...state}之类的代码，可以使用Immutable 来处理。</p><p>方案就是使用 immutable.js 可以解决这个问题。因为每一次 state 更新只要有数据改变，那么 PureRenderMixin 可以立刻判断出数据改变，可以大大提升性能</p><p>Immutable.js 需要使用其内置的api来操作数据，比较繁琐，且需要区分是 Immutable 对象还是原生对象，容易混淆操作。对现有代码的迁移成本也很高，可以使用immer.js</p><h3 id="优点" tabindex="-1">优点 <a class="header-anchor" href="#优点" aria-label="Permalink to &quot;优点&quot;">​</a></h3><ul><li>降低 Mutable 数据变化带来的复杂度</li><li>节省内存空间</li><li>Undo/Redo，Copy/Paste，随意穿越！</li><li>拥抱函数式编程</li></ul><h3 id="缺点" tabindex="-1">缺点 <a class="header-anchor" href="#缺点" aria-label="Permalink to &quot;缺点&quot;">​</a></h3><ul><li>容易与原生对象混用</li><li>对已有代码侵入性较强，迁移成本较高</li><li>开发效率和应用项目之前需要平衡</li></ul>',13),m=[i];function o(s,u,n,p,d,c){return t(),a("div",null,m)}const b=e(r,[["render",o]]);export{_ as __pageData,b as default};
